# 介绍

Groovy…

- 建立在Java虚拟机上的一种敏捷和动态的语言
- 建立在Java的强大功能之上，而且因受Python、Ruby和Smalltalk等语言的启发，它还有其他强大的功能
- 使Java开发人员可以轻松获得现代编程特性
- 提供静态类型检查和静态编译代码的能力，以确保健壮性和性能
- 支持领域特定的语言和其他紧凑的语法，使您的代码变得易于阅读和维护
- 通过强大的处理原语、OO能力和Ant DSL，使得编写shell和构建脚本变得简单
- 在开发web、GUI、数据库或控制台应用程序时，通过减少脚手架代码来提高开发人员的工作效率
- 通过支持单元测试和即时模拟来简化测试
- 与所有现有的Java类和库无缝集成
- 直接编译成Java字节码，这样您就可以在可以使用Java的地方使用它

## 1. Groovy语言规范

### 1.1. 语法

本章讨论Groovy编程语言的语法。该语言的语法源于Java语法，但通过特定的Groovy构造对其进行了增强，并允许进行某些简化。

#### 1.1.1. 注释

##### 单行注释

单行注释以`//`开头，可以在行中的任何位置找到它。`//`后面的字符，直到行尾，都被认为是注释的一部分。
```groovy
// a standalone single line comment
println "hello" // a comment till the end of the line
```

##### 多行注释

多行注释以 `/*` 开头，可以在行中的任何位置找到它。`/*`后面的字符将被认为是注释的一部分，包括新行字符，直到第一个`*/`结束注释为止。因此，多行注释可以放在语句的末尾，甚至语句内部。

```groovy
/* a standalone multiline comment
   spanning two lines */
println "hello" /* a multiline comment starting
                   at the end of a statement */
println 1 /* one */ + 2 /* two */
```

##### Groovydoc注释


与多行注释类似，Groovydoc注释也是多行注释，但是以`/**`开头，以`*/`结尾。第一个Groovydoc注释行后面的行可以选择以星号`*`开头。这些注释主要涉及:

- 类型定义 (classes, interfaces, enums, annotations),
- 字段和属性定义
- 方法定义

虽然编译器和Groovydoc注释上面的语言元素没有关联，但是您应该在代码之前加上注释。
```groovy
/**
 * A Class description
 */
class Person {
    /** the name of the person */
    String name

    /**
     * Creates a greeting method for a certain person.
     *
     * @param otherPerson the person to greet
     * @return a greeting message
     */
    String greet(String otherPerson) {
       "Hello ${otherPerson}"
    }
}
```

Groovydoc遵循与Java自己的Javadoc相同的约定。因此，您将能够使用与Javadoc相同的标识,另外,在3.0.0之后,Groovy支持**Runtime Groovydoc**,Groovydoc能在运行时得到保留.


|      | Runtime Groovydoc is disabled by default. It can be enabled by adding JVM option `-Dgroovy.attach.runtime.groovydoc=true` |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

运行时Groovydoc以`/**@`开始,以 `*/`结束, 例如:

```groovy
/**@
 * Some class groovydoc for Foo
 */
class Foo {
    /**@
     * Some method groovydoc for bar
     */
    void bar() {
    }
}

assert Foo.class.groovydoc.content.contains('Some class groovydoc for Foo') 
assert Foo.class.getMethod('bar', new Class[0]).groovydoc.content.contains('Some method groovydoc for bar') 
```

|      | Get the runtime groovydoc for class `Foo`  |
| ---- | ------------------------------------------ |
|      | Get the runtime groovydoc for method `bar` |

##### Shebang line

除了单行注释之外，还有一个特殊的行注释，通常称为UNIX系统可以理解的*shebang line*行，它允许脚本直接从命令行运行，前提是您已经安装了Groovy发行版，并且在对应的路径上可以使用“Groovy”命令。

```groovy
#!/usr/bin/env groovy
println "Hello from the shebang line"
```

|      | The `#` character must be the first character of the file. Any indentation would yield a compilation error. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 1.1.2. 关键之

下面的列表是Groovy语言的所有关键字:

| as     | assert  | break      | case       |
| ------ | ------- | ---------- | ---------- |
| catch  | class   | const      | continue   |
| def    | default | do         | else       |
| enum   | extends | false      | finally    |
| for    | goto    | if         | implements |
| import | in      | instanceof | interface  |
| new    | null    | package    | return     |
| super  | switch  | this       | throw      |
| throws | trait   | true       | try        |
| var    | while   |            |            |

#### 1.1.3. 标识符

##### 一般标识符

标识符以字母、美元或下划线开头。他们不能从数字开始。

字母只能是以下范围:

- 'a' to 'z' (lowercase ascii letter)
- 'A' to 'Z' (uppercase ascii letter)
- '\u00C0' to '\u00D6'
- '\u00D8' to '\u00F6'
- '\u00F8' to '\u00FF'
- '\u0100' to '\uFFFE'

下面的字符可以包含字母和数字。以下是一些有效标识符的例子(变量名):

```groovy
def name
def item3
def with_underscore
def $dollarStart
```

但以下是无效的标识符:

```groovy
def 3tier
def a+b
def a#b
```

当跟随一个点时，所有关键字都是有效的标识符:

```groovy
foo.as
foo.assert
foo.break
foo.case
foo.catch
```

##### 引用标识符

引号的标识符出现在点表达式的点之后. 例如, `person.name`表达式的一部分`name`能通过 `person.name`,`person."name"`或者 `person.'name'`引用. 当某些标识符包含Java语言规范禁止的非法字符，但是Groovy允许引用这些字符时，这一点特别有趣. 例如，像破折号、空格、感叹号等字符。

```groovy
def map = [:]

map."an identifier with a space and double quotes" = "ALLOWED"
map.'with-dash-signs-and-single-quotes' = "ALLOWED"

assert map."an identifier with a space and double quotes" == "ALLOWED"
assert map.'with-dash-signs-and-single-quotes' == "ALLOWED"
```

As we shall see in the [following section on strings](https://docs.groovy-lang.org/latest/html/documentation/#all-strings), Groovy provides different string literals. All kind of strings are actually allowed after the dot:

```groovy
map.'single quote'
map."double quote"
map.'''triple single quote'''
map."""triple double quote"""
map./slashy string/
map.$/dollar slashy string/$
```


普通字符串和Groovy的gstring(内插的字符串)之间有区别，在后者的情况下，内插的值被插入到最后的字符串中，用于计算整个标识符:

```groovy
def firstname = "Homer"
map."Simpson-${firstname}" = "Homer Simpson"

assert map.'Simpson-Homer' == "Homer Simpson"
```

#### 1.1.4. 字符串

由字符串组成的文本被称为字符串. Groovy 允许你实例化`java.lang.String` 对象一样实例化GStrings (`groovy.lang.GString`) ,在其他语言中被称为内嵌字符串.

##### 单引号字符串

单引号字符串是由单引号包裹起来的字符串:

```groovy
'a single-quoted string'
```

|      | Single-quoted strings are plain `java.lang.String` and don’t support interpolation. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### 字符串连接

所有的Groovy字符串能够被`+`操作符连接.

```groovy
assert 'ab' == 'a' + 'b'
```

##### 三重引号字符串

三重引号字符串是由三重单引号包裹起来的字符串:

```groovy
'''a triple-single-quoted string'''
```

|      | Triple-single-quoted strings are plain `java.lang.String` and don’t support interpolation. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

三重引号字符串能够跨越多行. 字符串的内容可以跨行边界，而不需要将字符串分割成几部分，也不需要连接或换行字符:

```groovy
def aMultilineString = '''line one
line two
line three'''
```

如果您的代码是缩进的，例如在类的方法体中，您的字符串将包含缩进的空白。 Groovy开发工具包包含用于去掉缩进的方法 `String#stripIndent()` , 使用一个分隔符字符来标识要从字符串开头删除的文本`String#stripMargin()` 

当创建一个下面的字符串:

```groovy
def startingAndEndingWithANewline = '''
line one
line two
line three
'''
```

可以通过用反斜杠转义换行来去掉这个字符:

```groovy
def strippedFirstNewline = '''\
line one
line two
line three
'''

assert !strippedFirstNewline.startsWith('\n')
```

###### 转义特殊字符

你可以通过反斜杠`\`来转义单引号字符避免终止字符串.

```groovy
'an escaped single quote: \' needs a backslash'
```

你可以用双反斜杠转义转义字符本身:

```groovy
'an escaped escape character: \\ needs a double backslash'
```

一些特殊字符也使用反斜杠作为转义字符::

| Escape sequence | Character                                                    |
| :-------------- | :----------------------------------------------------------- |
| \b              | backspace                                                    |
| \f              | formfeed                                                     |
| \n              | newline                                                      |
| \r              | carriage return                                              |
| \s              | single space                                                 |
| \t              | tabulation                                                   |
| \\              | backslash                                                    |
| \'              | single quote within a single-quoted string (and optional for triple-single-quoted and double-quoted strings) |
| \"              | double quote within a double-quoted string (and optional for triple-double-quoted and single-quoted strings) |

稍后讨论其他类型的字符串时，我们将看到更多转义细节。

###### Unicode转义字符

对于键盘上不存在的字符，可以使用unicode转义序列:一个反斜杠，后跟'u'，然后是4个十六进制数字。
例如，欧元货币符号可以表示为:

```groovy
'The Euro currency symbol: \u20AC'
```

##### 双引号字符串

双引号字符串是由双引号包围的一系列字符:

```groovy
"a double-quoted string"
```

|      | Double-quoted strings are plain `java.lang.String` if there’s no interpolated expression, but are `groovy.lang.GString` instances if interpolation is present. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

|      | To escape a double quote, you can use the backslash character: "A double quote: \"". |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### 字符串插值

除了单引号和三重单引号的字符串外，任何Groovy表达式都可以在所有字符串中插入。插值表达式是在字符串求值时用字符串的值替换字符串中的占位符的行为。占位符表达式被'${}'包围。花括号可以省略为明确的虚线表达式，即我们可以使用一个$前缀在这些情况下。如果将GString传递给使用String的方法，占位符内的表达式值将被计算为其字符串表示形式(通过调用该表达式上的' toString() ')，结果字符串将被传递给该方法。

在这里，我们有一个字符串与一个占位符引用一个局部变量:

```groovy
def name = 'Guillaume' // a plain string
def greeting = "Hello ${name}"

assert greeting.toString() == 'Hello Guillaume'
```

任何Groovy表达式都是有效的，正如我们在这个例子中看到的算术表达式:

```groovy
def sum = "The sum of 2 and 3 equals ${2 + 3}"
assert sum.toString() == 'The sum of 2 and 3 equals 5'
```

|      | Not only are expressions allowed in between the `${}` placeholder, but so are statements. However, a statement’s value is just `null`. So if several statements are inserted in that placeholder, the last one should somehow return a meaningful value to be inserted. For instance, "The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}" is supported and works as expected but a good practice is usually to stick to simple expressions inside GString placeholders. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

除了‘${}’占位符之外，我们还可以使用一个单独的‘$’符号作为点表达式的前缀:

```groovy
def person = [name: 'Guillaume', age: 36]
assert "$person.name is $person.age years old" == 'Guillaume is 36 years old'
```

但是只有点表达式组成的才是有效的,例如 `a.b`, `a.b.c`等等. 包含括号的表达式(如方法调用、闭包的大括号、不属于属性表达式或算术运算符的点)是无效的。下面给出一个数字的变量定义


```groovy
def number = 3.14
```

下面的语句会抛出`groovy.lang.MissingPropertyException`异常,因为Groovy认为您试图访问该数字的“toString”属性，而该属性并不存在:

```groovy
shouldFail(MissingPropertyException) {
    println "$number.toString()"
}
```

|      | You can think of `"$number.toString()"` as being interpreted by the parser as `"${number.toString}()"`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

类似地，如果表达式是模稜两可的，你需要保留花括号:

```groovy
String thing = 'treasure'
assert 'The x-coordinate of the treasure is represented by treasure.x' ==
    "The x-coordinate of the $thing is represented by $thing.x"   // <= Not allowed: ambiguous!!
assert 'The x-coordinate of the treasure is represented by treasure.x' ==
        "The x-coordinate of the $thing is represented by ${thing}.x"  // <= Curly braces required
```

如果你需要转义GString中的' $ '或' ${}'占位符，使它们看起来没有插值表达式，你只需要使用' \ '反斜杠字符来转义美元符号:

```groovy
assert '$5' == "\$5"
assert '${name}' == "\${name}"
```

###### 插值闭包表达式的特殊情况

到目前为止，我们已经看到我们可以在' ${}'占位符中插入任意表达式，但是对于闭包表达式有一个特殊的情况和符号。当占位符包含一个箭头' ${→}'时，表达式实际上是一个闭包表达式—您可以将它看作一个闭包，在它前面有一个美元前缀:

```groovy
def sParameterLessClosure = "1 + 2 == ${-> 3}" 
assert sParameterLessClosure == '1 + 2 == 3'

def sOneParamClosure = "1 + 2 == ${ w -> w << 3}" 
assert sOneParamClosure == '1 + 2 == 3'
```

|      | The closure is a parameterless closure which doesn’t take arguments. |
| ---- | ------------------------------------------------------------ |
|      | Here, the closure takes a single `java.io.StringWriter` argument, to which you can append content with the `<<` leftShift operator. In either case, both placeholders are embedded closures. |

从外观上看，它似乎是一种更冗长的定义表达式的方法，但是闭包与纯粹的表达式相比有一个有趣的优点:延迟求值。

让我们考虑以下例子:

```groovy
def number = 1 
def eagerGString = "value == ${number}"
def lazyGString = "value == ${ -> number }"

assert eagerGString == "value == 1" 
assert lazyGString ==  "value == 1" 

number = 2 
assert eagerGString == "value == 1" 
assert lazyGString ==  "value == 2" 
```

|      | We define a `number` variable containing `1` that we then interpolate within two GStrings, as an expression in `eagerGString` and as a closure in `lazyGString`. |
| ---- | ------------------------------------------------------------ |
|      | We expect the resulting string to contain the same string value of 1 for `eagerGString`. |
|      | Similarly for `lazyGString`                                  |
|      | Then we change the value of the variable to a new number     |
|      | With a plain interpolated expression, the value was actually bound at the time of creation of the GString. |
|      | But with a closure expression, the closure is called upon each coercion of the GString into String, resulting in an updated string containing the new number value. |

|      | An embedded closure expression taking more than one parameter will generate an exception at runtime. Only closures with zero or one parameters are allowed. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### 与Java的互操作性

当一个方法(无论继承java和groovy)需要一个String入参, 但是传递的是GString示例,GString的toString()方法会自动透明地调用

```groovy
String takeString(String message) {         
    assert message instanceof String        
    return message
}

def message = "The message is ${'hello'}"   
assert message instanceof GString           

def result = takeString(message)            
assert result instanceof String
assert result == 'The message is hello'
```

|      | We create a GString variable                                 |
| ---- | ------------------------------------------------------------ |
|      | We double check it’s an instance of the GString              |
|      | We then pass that GString to a method taking a String as parameter |
|      | The signature of the `takeString()` method explicitly says its sole parameter is a String |
|      | We also verify that the parameter is indeed a String and not a GString. |

###### GString和String哈希值

虽然可以使用内插字符串代替普通的Java字符串，但它们与字符串的区别在于:它们的hashcode不同。普通Java字符串是不可变的，而GString的结果字符串表示可以根据它的内插值而变化。即使对于相同的结果字符串，GStrings和字符串也没有相同的hashCode。

```groovy
assert "one: ${1}".hashCode() != "one: 1".hashCode()
```

GString和Strings有不同的hashCode值,应该避免使用GString作为map的key值, 特别是当我们试图用String而不是GString检索关联的值时。

```groovy
def key = "a"
def m = ["${key}": "letter ${key}"]     

assert m["a"] == null                   
```

|      | The map is created with an initial pair whose key is a GString |
| ---- | ------------------------------------------------------------ |
|      | When we try to fetch the value with a String key, we will not find it, as Strings and GString have different hashCode values |

##### 三重双引号字符串

三重双引号字符串的行为类似于双引号字符串，但它们是多行字符串，类似于三重单引号字符串。

```groovy
def name = 'Groovy'
def template = """
    Dear Mr ${name},

    You're the winner of the lottery!

    Yours sincerly,

    Dave
"""

assert template.toString().contains('Groovy')
```

|      | Neither double quotes nor single quotes need be escaped in triple-double-quoted strings. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### 斜线字符串

除了常用的带引号字符串外，Groovy还提供了斜线字符串，使用'/'作为开始和结束分隔符。斜线字符串对于定义正则表达式和模式特别有用，因为不需要转义反斜线。正则表达式的例子.

```groovy
def fooPattern = /.*foo.*/
assert fooPattern == '.*foo.*'
```

只有前斜杠需要用反斜杠转义:

```groovy
def escapeSlash = /The character \/ is a forward slash/
assert escapeSlash == 'The character / is a forward slash'
```

斜线字符串可以跨越多行:

```groovy
def multilineSlashy = /one
    two
    three/

assert multilineSlashy.contains('\n')
```

正则表达在某种意义上算是一种有不同转义规则的GString,因此它支持插入表达式:

```groovy
def color = 'blue'
def interpolatedSlashy = /a ${color} car/

assert interpolatedSlashy == 'a blue car'
```

###### 特殊案例

一个空的斜杠字符串不能用双斜杠表示，因为它被Groovy解析器理解为行注释。这就是为什么下面的断言实际上不能编译，因为它看起来像一个未终止的语句:

```groovy
assert '' == //
```


请记住，不需要转义反斜杠。另一种考虑方法是，实际上不支持转义。斜线字符串' /\t/ '将不包含制表符，而是一个反斜杠，后跟字符't'。转义只允许斜杠字符，即。'/ \/folder/ '将是一个斜线字符串，包含'/folder' '。斜杠转义的结果是斜杠字符串不能以反斜杠结束。否则它将退出斜线字符串终止符。你可以使用一个特殊的技巧，' /以斜杠${'\'}/ '结尾。但是最好避免在这种情况下使用斜线。

##### $/字符串

$/字符串是多行gstring是否以开头`$/`和结尾`/$`分隔.转义字符是美元符号，它可以转义另一个美元或正斜杠。但是$和前向斜杠都不需要转义，除非要转义一个字符串子序列的$，该子序列的起始位置类似于GString占位符序列，或者需要转义一个序列，该序列的起始位置类似于一个闭合的$斜杠字符串分隔符。

这里有一些例子

```groovy
def name = "Guillaume"
def date = "April, 1st"

def dollarSlashy = $/
    Hello $name,
    today we're ${date}.

    $ dollar sign
    $$ escaped dollar sign
    \ backslash
    / forward slash
    $/ escaped forward slash
    $$$/ escaped opening dollar slashy
    $/$$ escaped closing dollar slashy
/$

assert [
    'Guillaume',
    'April, 1st',
    '$ dollar sign',
    '$ escaped dollar sign',
    '\\ backslash',
    '/ forward slash',
    '/ escaped forward slash',
    '$/ escaped opening dollar slashy',
    '/$ escaped closing dollar slashy'
].every { dollarSlashy.contains(it) }
```

它的创建是为了克服斜线字符串转义规则的一些限制。当它的转义规则适合您的字符串内容时使用它(通常如果它有一些您不想转义的斜线)。

##### 字符串汇总表

| String name          | String syntax | Interpolated | Multiline | Escape character |
| -------------------- | ------------- | ------------ | --------- | ---------------- |
| Single-quoted        | `'…'`         |              |           | `\`              |
| Triple-single-quoted | `'''…'''`     |              |           | `\`              |
| Double-quoted        | `"…"`         |              |           | `\`              |
| Triple-double-quoted | `"""…"""`     |              |           | `\`              |
| Slashy               | `/…/`         |              |           | `\`              |
| Dollar slashy        | `$/…/$`       |              |           | `$`              |

##### 字符

与Java不同，Groovy没有显式的字符文字。但是，您可以通过三种不同的方法明确地将Groovy字符串变成实际的字符:

```groovy
char c1 = 'A' 
assert c1 instanceof Character

def c2 = 'B' as char 
assert c2 instanceof Character

def c3 = (char)'C' 
assert c3 instanceof Character
```

|      | by being explicit when declaring a variable holding the character by specifying the `char` type |
| ---- | ------------------------------------------------------------ |
|      | by using type coercion with the `as` operator                |
|      | by using a cast to char operation                            |

|      | The first option *1* is interesting when the character is held in a variable, while the other two (*2* and *3*) are more interesting when a char value must be passed as argument of a method call. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 1.1.5. 数字

Groovy支持不同种类的整数和十进制文字，由通常的Java“数字”类型支持。

##### Integral literals

The integral literal types are the same as in Java:

- `byte`
- `char`
- `short`
- `int`
- `long`
- `java.lang.BigInteger`

You can create integral numbers of those types with the following declarations:

```groovy
// primitive types
byte  b = 1
char  c = 2
short s = 3
int   i = 4
long  l = 5

// infinite precision
BigInteger bi =  6
```

If you use optional typing by using the `def` keyword, the type of the integral number will vary: it’ll adapt to the capacity of the type that can hold that number.

For positive numbers:

```groovy
def a = 1
assert a instanceof Integer

// Integer.MAX_VALUE
def b = 2147483647
assert b instanceof Integer

// Integer.MAX_VALUE + 1
def c = 2147483648
assert c instanceof Long

// Long.MAX_VALUE
def d = 9223372036854775807
assert d instanceof Long

// Long.MAX_VALUE + 1
def e = 9223372036854775808
assert e instanceof BigInteger
```

As well as for negative numbers:

```groovy
def na = -1
assert na instanceof Integer

// Integer.MIN_VALUE
def nb = -2147483648
assert nb instanceof Integer

// Integer.MIN_VALUE - 1
def nc = -2147483649
assert nc instanceof Long

// Long.MIN_VALUE
def nd = -9223372036854775808
assert nd instanceof Long

// Long.MIN_VALUE - 1
def ne = -9223372036854775809
assert ne instanceof BigInteger
```

###### Alternative non-base 10 representations

Numbers can also be represented in binary, octal, hexadecimal and decimal bases.

Binary literal

Binary numbers start with a `0b` prefix:

```groovy
int xInt = 0b10101111
assert xInt == 175

short xShort = 0b11001001
assert xShort == 201 as short

byte xByte = 0b11
assert xByte == 3 as byte

long xLong = 0b101101101101
assert xLong == 2925l

BigInteger xBigInteger = 0b111100100001
assert xBigInteger == 3873g

int xNegativeInt = -0b10101111
assert xNegativeInt == -175
```

Octal literal

Octal numbers are specified in the typical format of `0` followed by octal digits.

```groovy
int xInt = 077
assert xInt == 63

short xShort = 011
assert xShort == 9 as short

byte xByte = 032
assert xByte == 26 as byte

long xLong = 0246
assert xLong == 166l

BigInteger xBigInteger = 01111
assert xBigInteger == 585g

int xNegativeInt = -077
assert xNegativeInt == -63
```

Hexadecimal literal

Hexadecimal numbers are specified in the typical format of `0x` followed by hex digits.

```groovy
int xInt = 0x77
assert xInt == 119

short xShort = 0xaa
assert xShort == 170 as short

byte xByte = 0x3a
assert xByte == 58 as byte

long xLong = 0xffff
assert xLong == 65535l

BigInteger xBigInteger = 0xaaaa
assert xBigInteger == 43690g

Double xDouble = new Double('0x1.0p0')
assert xDouble == 1.0d

int xNegativeInt = -0x77
assert xNegativeInt == -119
```

##### Decimal literals

The decimal literal types are the same as in Java:

- `float`
- `double`
- `java.lang.BigDecimal`

You can create decimal numbers of those types with the following declarations:

```groovy
// primitive types
float  f = 1.234
double d = 2.345

// infinite precision
BigDecimal bd =  3.456
```

Decimals can use exponents, with the `e` or `E` exponent letter, followed by an optional sign, and a integral number representing the exponent:

```groovy
assert 1e3  ==  1_000.0
assert 2E4  == 20_000.0
assert 3e+1 ==     30.0
assert 4E-2 ==      0.04
assert 5e-1 ==      0.5
```

Conveniently for exact decimal number calculations, Groovy choses `java.lang.BigDecimal` as its decimal number type. In addition, both `float` and `double` are supported, but require an explicit type declaration, type coercion or suffix. Even if `BigDecimal` is the default for decimal numbers, such literals are accepted in methods or closures taking `float` or `double` as parameter types.

|      | Decimal numbers can’t be represented using a binary, octal or hexadecimal representation. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Underscore in literals

When writing long literal numbers, it’s harder on the eye to figure out how some numbers are grouped together, for example with groups of thousands, of words, etc. By allowing you to place underscore in number literals, it’s easier to spot those groups:

```groovy
long creditCardNumber = 1234_5678_9012_3456L
long socialSecurityNumbers = 999_99_9999L
double monetaryAmount = 12_345_132.12
long hexBytes = 0xFF_EC_DE_5E
long hexWords = 0xFFEC_DE5E
long maxLong = 0x7fff_ffff_ffff_ffffL
long alsoMaxLong = 9_223_372_036_854_775_807L
long bytes = 0b11010010_01101001_10010100_10010010
```

##### Number type suffixes

We can force a number (including binary, octals and hexadecimals) to have a specific type by giving a suffix (see table below), either uppercase or lowercase.

| Type       | Suffix     |
| :--------- | :--------- |
| BigInteger | `G` or `g` |
| Long       | `L` or `l` |
| Integer    | `I` or `i` |
| BigDecimal | `G` or `g` |
| Double     | `D` or `d` |
| Float      | `F` or `f` |

Examples:

```groovy
assert 42I == new Integer('42')
assert 42i == new Integer('42') // lowercase i more readable
assert 123L == new Long("123") // uppercase L more readable
assert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integer
assert 456G == new BigInteger('456')
assert 456g == new BigInteger('456')
assert 123.45 == new BigDecimal('123.45') // default BigDecimal type used
assert 1.200065D == new Double('1.200065')
assert 1.234F == new Float('1.234')
assert 1.23E23D == new Double('1.23E23')
assert 0b1111L.class == Long // binary
assert 0xFFi.class == Integer // hexadecimal
assert 034G.class == BigInteger // octal
```

##### Math operations

Although [operators](https://docs.groovy-lang.org/latest/html/documentation/#_operators) are covered later on, it’s important to discuss the behavior of math operations and what their resulting types are.

Division and power binary operations aside (covered below),

- binary operations between `byte`, `char`, `short` and `int` result in `int`
- binary operations involving `long` with `byte`, `char`, `short` and `int` result in `long`
- binary operations involving `BigInteger` and any other integral type result in `BigInteger`
- binary operations involving `BigDecimal` with `byte`, `char`, `short`, `int` and `BigInteger` result in `BigDecimal`
- binary operations between `float`, `double` and `BigDecimal` result in `double`
- binary operations between two `BigDecimal` result in `BigDecimal`

The following table summarizes those rules:

|                | byte | char | short | int  | long | BigInteger | float  | double | BigDecimal |
| :------------- | :--- | :--- | :---- | :--- | :--- | :--------- | :----- | :----- | :--------- |
| **byte**       | int  | int  | int   | int  | long | BigInteger | double | double | BigDecimal |
| **char**       |      | int  | int   | int  | long | BigInteger | double | double | BigDecimal |
| **short**      |      |      | int   | int  | long | BigInteger | double | double | BigDecimal |
| **int**        |      |      |       | int  | long | BigInteger | double | double | BigDecimal |
| **long**       |      |      |       |      | long | BigInteger | double | double | BigDecimal |
| **BigInteger** |      |      |       |      |      | BigInteger | double | double | BigDecimal |
| **float**      |      |      |       |      |      |            | double | double | double     |
| **double**     |      |      |       |      |      |            |        | double | double     |
| **BigDecimal** |      |      |       |      |      |            |        |        | BigDecimal |

|      | Thanks to Groovy’s operator overloading, the usual arithmetic operators work as well with `BigInteger` and `BigDecimal`, unlike in Java where you have to use explicit methods for operating on those numbers. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### The case of the division operator

The division operators `/` (and `/=` for division and assignment) produce a `double` result if either operand is a `float` or `double`, and a `BigDecimal` result otherwise (when both operands are any combination of an integral type `short`, `char`, `byte`, `int`, `long`, `BigInteger` or `BigDecimal`).

`BigDecimal` division is performed with the `divide()` method if the division is exact (i.e. yielding a result that can be represented within the bounds of the same precision and scale), or using a `MathContext` with a [precision](http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#precision()) of the maximum of the two operands' precision plus an extra precision of 10, and a [scale](http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#scale()) of the maximum of 10 and the maximum of the operands' scale.

|      | For integer division like in Java, you should use the `intdiv()` method, as Groovy doesn’t provide a dedicated integer division operator symbol. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### The case of the power operator

The power operation is represented by the `**` operator, with two parameters: the base and the exponent. The result of the power operation depends on its operands, and the result of the operation (in particular if the result can be represented as an integral value).

The following rules are used by Groovy’s power operation to determine the resulting type:

- If the exponent is a decimal value
  - if the result can be represented as an `Integer`, then return an `Integer`
  - else if the result can be represented as a `Long`, then return a `Long`
  - otherwise return a `Double`
- If the exponent is an integral value
  - if the exponent is strictly negative, then return an `Integer`, `Long` or `Double` if the result value fits in that type
  - if the exponent is positive or zero
    - if the base is a `BigDecimal`, then return a `BigDecimal` result value
    - if the base is a `BigInteger`, then return a `BigInteger` result value
    - if the base is an `Integer`, then return an `Integer` if the result value fits in it, otherwise a `BigInteger`
    - if the base is a `Long`, then return a `Long` if the result value fits in it, otherwise a `BigInteger`

We can illustrate those rules with a few examples:

```groovy
// base and exponent are ints and the result can be represented by an Integer
assert    2    **   3    instanceof Integer    //  8
assert   10    **   9    instanceof Integer    //  1_000_000_000

// the base is a long, so fit the result in a Long
// (although it could have fit in an Integer)
assert    5L   **   2    instanceof Long       //  25

// the result can't be represented as an Integer or Long, so return a BigInteger
assert  100    **  10    instanceof BigInteger //  10e20
assert 1234    ** 123    instanceof BigInteger //  170515806212727042875...

// the base is a BigDecimal and the exponent a negative int
// but the result can be represented as an Integer
assert    0.5  **  -2    instanceof Integer    //  4

// the base is an int, and the exponent a negative float
// but again, the result can be represented as an Integer
assert    1    **  -0.3f instanceof Integer    //  1

// the base is an int, and the exponent a negative int
// but the result will be calculated as a Double
// (both base and exponent are actually converted to doubles)
assert   10    **  -1    instanceof Double     //  0.1

// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal
assert    1.2  **  10    instanceof BigDecimal //  6.1917364224

// the base is a float or double, and the exponent is an int
// but the result can only be represented as a Double value
assert    3.4f **   5    instanceof Double     //  454.35430372146965
assert    5.6d **   2    instanceof Double     //  31.359999999999996

// the exponent is a decimal value
// and the result can only be represented as a Double value
assert    7.8  **   1.9  instanceof Double     //  49.542708423868476
assert    2    **   0.1f instanceof Double     //  1.0717734636432956
```

#### 1.1.6. Booleans

Boolean is a special data type that is used to represent truth values: `true` and `false`. Use this data type for simple flags that track true/false [conditions](https://docs.groovy-lang.org/latest/html/documentation/#_conditional_operators).

Boolean values can be stored in variables, assigned into fields, just like any other data type:

```groovy
def myBooleanVariable = true
boolean untypedBooleanVar = false
booleanField = true
```

`true` and `false` are the only two primitive boolean values. But more complex boolean expressions can be represented using [logical operators](https://docs.groovy-lang.org/latest/html/documentation/#_bitwise_and_logical_operators).

In addition, Groovy has [special rules](https://docs.groovy-lang.org/latest/html/documentation/#Groovy-Truth) (often referred to as *Groovy Truth*) for coercing non-boolean objects to a boolean value.

#### 1.1.7. Lists

Groovy uses a comma-separated list of values, surrounded by square brackets, to denote lists. Groovy lists are plain JDK `java.util.List`, as Groovy doesn’t define its own collection classes. The concrete list implementation used when defining list literals are `java.util.ArrayList` by default, unless you decide to specify otherwise, as we shall see later on.

```groovy
def numbers = [1, 2, 3]         

assert numbers instanceof List  
assert numbers.size() == 3      
```

|      | We define a list numbers delimited by commas and surrounded by square brackets, and we assign that list into a variable |
| ---- | ------------------------------------------------------------ |
|      | The list is an instance of Java’s `java.util.List` interface |
|      | The size of the list can be queried with the `size()` method, and shows our list contains 3 elements |

In the above example, we used a homogeneous list, but you can also create lists containing values of heterogeneous types:

```groovy
def heterogeneous = [1, "a", true]  
```

|      | Our list here contains a number, a string and a boolean value |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

We mentioned that by default, list literals are actually instances of `java.util.ArrayList`, but it is possible to use a different backing type for our lists, thanks to using type coercion with the `as` operator, or with explicit type declaration for your variables:

```groovy
def arrayList = [1, 2, 3]
assert arrayList instanceof java.util.ArrayList

def linkedList = [2, 3, 4] as LinkedList    
assert linkedList instanceof java.util.LinkedList

LinkedList otherLinked = [3, 4, 5]          
assert otherLinked instanceof java.util.LinkedList
```

|      | We use coercion with the `as` operator to explicitly request a `java.util.LinkedList` implementation |
| ---- | ------------------------------------------------------------ |
|      | We can say that the variable holding the list literal is of type `java.util.LinkedList` |

You can access elements of the list with the `[]` subscript operator (both for reading and setting values) with positive indices or negative indices to access elements from the end of the list, as well as with ranges, and use the `<<` leftShift operator to append elements to a list:

```groovy
def letters = ['a', 'b', 'c', 'd']

assert letters[0] == 'a'     
assert letters[1] == 'b'

assert letters[-1] == 'd'    
assert letters[-2] == 'c'

letters[2] = 'C'             
assert letters[2] == 'C'

letters << 'e'               
assert letters[ 4] == 'e'
assert letters[-1] == 'e'

assert letters[1, 3] == ['b', 'd']         
assert letters[2..4] == ['C', 'd', 'e']    
```

|      | Access the first element of the list (zero-based counting)   |
| ---- | ------------------------------------------------------------ |
|      | Access the last element of the list with a negative index: -1 is the first element from the end of the list |
|      | Use an assignment to set a new value for the third element of the list |
|      | Use the `<<` leftShift operator to append an element at the end of the list |
|      | Access two elements at once, returning a new list containing those two elements |
|      | Use a range to access a range of values from the list, from a start to an end element position |

As lists can be heterogeneous in nature, lists can also contain other lists to create multi-dimensional lists:

```groovy
def multi = [[0, 1], [2, 3]]     
assert multi[1][0] == 2          
```

|      | Define a list of list of numbers                             |
| ---- | ------------------------------------------------------------ |
|      | Access the second element of the top-most list, and the first element of the inner list |

#### 1.1.8. Arrays

Groovy reuses the list notation for arrays, but to make such literals arrays, you need to explicitely define the type of the array through coercion or type declaration.

```groovy
String[] arrStr = ['Ananas', 'Banana', 'Kiwi']  

assert arrStr instanceof String[]    
assert !(arrStr instanceof List)

def numArr = [1, 2, 3] as int[]      

assert numArr instanceof int[]       
assert numArr.size() == 3
```

|      | Define an array of strings using explicit variable type declaration |
| ---- | ------------------------------------------------------------ |
|      | Assert that we created an array of strings                   |
|      | Create an array of ints with the `as` operator               |
|      | Assert that we created an array of primitive ints            |

You can also create multi-dimensional arrays:

```groovy
def matrix3 = new Integer[3][3]         
assert matrix3.size() == 3

Integer[][] matrix2                     
matrix2 = [[1, 2], [3, 4]]
assert matrix2 instanceof Integer[][]
```

|      | You can define the bounds of a new array          |
| ---- | ------------------------------------------------- |
|      | Or declare an array without specifying its bounds |

Access to elements of an array follows the same notation as for lists:

```groovy
String[] names = ['Cédric', 'Guillaume', 'Jochen', 'Paul']
assert names[0] == 'Cédric'     

names[2] = 'Blackdrag'          
assert names[2] == 'Blackdrag'
```

|      | Retrieve the first element of the array                      |
| ---- | ------------------------------------------------------------ |
|      | Set the value of the third element of the array to a new value |

|      | Java’s array initializer notation is not supported by Groovy, as the curly braces can be misinterpreted with the notation of Groovy closures. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Java-style array initialization

Groovy has always supported literal list/array definitions using square brackets and has avoided Java-style curly braces so as not to conflict with closure definitions. In the case where the curly braces come immediately after an array type declaration however, there is no ambiguity with closure definitions, so the Java style is now also supported.

Examples:

```groovy
def primes = new int[] {2, 3, 5, 7, 11}
assert primes.size() == 5 && primes.sum() == 28
assert primes.class.name == '[I'

def pets = new String[] {'cat', 'dog'}
assert pets.size() == 2 && pets.sum() == 'catdog'
assert pets.class.name == '[Ljava.lang.String;'

// traditional Groovy alternative still supported
String[] groovyBooks = [ 'Groovy in Action', 'Making Java Groovy' ]
assert groovyBooks.every{ it.contains('Groovy') }
```

#### 1.1.9. Maps

Sometimes called dictionaries or associative arrays in other languages, Groovy features maps. Maps associate keys to values, separating keys and values with colons, and each key/value pairs with commas, and the whole keys and values surrounded by square brackets.

```groovy
def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF']   

assert colors['red'] == '#FF0000'    
assert colors.green  == '#00FF00'    

colors['pink'] = '#FF00FF'           
colors.yellow  = '#FFFF00'           

assert colors.pink == '#FF00FF'
assert colors['yellow'] == '#FFFF00'

assert colors instanceof java.util.LinkedHashMap
```

|      | We define a map of string color names, associated with their hexadecimal-coded html colors |
| ---- | ------------------------------------------------------------ |
|      | We use the subscript notation to check the content associated with the `red` key |
|      | We can also use the property notation to assert the color green’s hexadecimal representation |
|      | Similarly, we can use the subscript notation to add a new key/value pair |
|      | Or the property notation, to add the `yellow` color          |

|      | When using names for the keys, we actually define string keys in the map. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

|      | Groovy creates maps that are actually instances of `java.util.LinkedHashMap`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

If you try to access a key which is not present in the map:

```groovy
assert colors.unknown == null
```

You will retrieve a `null` result.

In the examples above, we used string keys, but you can also use values of other types as keys:

```groovy
def numbers = [1: 'one', 2: 'two']

assert numbers[1] == 'one'
```

Here, we used numbers as keys, as numbers can unambiguously be recognized as numbers, so Groovy will not create a string key like in our previous examples. But consider the case you want to pass a variable in lieu of the key, to have the value of that variable become the key:

```groovy
def key = 'name'
def person = [key: 'Guillaume']      

assert !person.containsKey('name')   
assert person.containsKey('key')     
```

|      | The `key` associated with the `'Guillaume'` name will actually be the `"key"` string, not the value associated with the `key` variable |
| ---- | ------------------------------------------------------------ |
|      | The map doesn’t contain the `'name'` key                     |
|      | Instead, the map contains a `'key'` key                      |

|      | You can also pass quoted strings as well as keys: ["name": "Guillaume"]. This is mandatory if your key string isn’t a valid identifier, for example if you wanted to create a string key containing a hash like in: ["street-name": "Main street"]. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

When you need to pass variable values as keys in your map definitions, you must surround the variable or expression with parentheses:

```groovy
person = [(key): 'Guillaume']        

assert person.containsKey('name')    
assert !person.containsKey('key')    
```

|      | This time, we surround the `key` variable with parentheses, to instruct the parser we are passing a variable rather than defining a string key |
| ---- | ------------------------------------------------------------ |
|      | The map does contain the `name` key                          |
|      | But the map doesn’t contain the `key` key as before          |

### 1.2. Operators

This chapter covers the operators of the Groovy programming language.

#### 1.2.1. Arithmetic operators

Groovy supports the usual familiar arithmetic operators you find in mathematics and in other programming languages like Java. All the Java arithmetic operators are supported. Let’s go through them in the following examples.

##### Normal arithmetic operators

The following binary arithmetic operators are available in Groovy:

| Operator | Purpose        | Remarks                                                      |
| :------- | :------------- | :----------------------------------------------------------- |
| `+`      | addition       |                                                              |
| `-`      | subtraction    |                                                              |
| `*`      | multiplication |                                                              |
| `/`      | division       | Use `intdiv()` for integer division, and see the section about [integer division](https://docs.groovy-lang.org/latest/html/documentation/#integer_division) for more information on the return type of the division. |
| `%`      | remainder      |                                                              |
| `**`     | power          | See the section about [the power operation](https://docs.groovy-lang.org/latest/html/documentation/#power_operator) for more information on the return type of the operation. |

Here are a few examples of usage of those operators:

```groovy
assert  1  + 2 == 3
assert  4  - 3 == 1
assert  3  * 5 == 15
assert  3  / 2 == 1.5
assert 10  % 3 == 1
assert  2 ** 3 == 8
```

##### Unary operators

The `+` and `-` operators are also available as unary operators:

```groovy
assert +3 == 3
assert -4 == 0 - 4

assert -(-1) == 1  
```

|      | Note the usage of parentheses to surround an expression to apply the unary minus to that surrounded expression. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

In terms of unary arithmetics operators, the `++` (increment) and `--` (decrement) operators are available, both in prefix and postfix notation:

```groovy
def a = 2
def b = a++ * 3             

assert a == 3 && b == 6

def c = 3
def d = c-- * 2             

assert c == 2 && d == 6

def e = 1
def f = ++e + 3             

assert e == 2 && f == 5

def g = 4
def h = --g + 1             

assert g == 3 && h == 4
```

|      | The postfix increment will increment `a` after the expression has been evaluated and assigned into `b` |
| ---- | ------------------------------------------------------------ |
|      | The postfix decrement will decrement `c` after the expression has been evaluated and assigned into `d` |
|      | The prefix increment will increment `e` before the expression is evaluated and assigned into `f` |
|      | The prefix decrement will decrement `g` before the expression is evaluated and assigned into `h` |

##### Assignment arithmetic operators

The binary arithmetic operators we have seen above are also available in an assignment form:

- `+=`
- `-=`
- `*=`
- `/=`
- `%=`
- `**=`

Let’s see them in action:

```groovy
def a = 4
a += 3

assert a == 7

def b = 5
b -= 3

assert b == 2

def c = 5
c *= 3

assert c == 15

def d = 10
d /= 2

assert d == 5

def e = 10
e %= 3

assert e == 1

def f = 3
f **= 2

assert f == 9
```

#### 1.2.2. Relational operators

Relational operators allow comparisons between objects, to know if two objects are the same or different, or if one is greater than, less than, or equal to the other.

The following operators are available:

| Operator | Purpose                            |
| :------- | :--------------------------------- |
| `==`     | equal                              |
| `!=`     | different                          |
| `<`      | less than                          |
| `<=`     | less than or equal                 |
| `>`      | greater than                       |
| `>=`     | greater than or equal              |
| `===`    | identical (Since Groovy 3.0.0)     |
| `!==`    | not identical (Since Groovy 3.0.0) |

Here are some examples of simple number comparisons using these operators:

```groovy
assert 1 + 2 == 3
assert 3 != 4

assert -2 < 3
assert 2 <= 2
assert 3 <= 4

assert 5 > 1
assert 5 >= -2
```

Both `===` and `!==` are supported which are the same as calling the `is()` method, and negating a call to the `is()` method respectively.

```groovy
import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode
class Creature { String type }

def cat = new Creature(type: 'cat')
def copyCat = cat
def lion = new Creature(type: 'cat')

assert cat.equals(lion) // Java logical equality
assert cat == lion      // Groovy shorthand operator

assert cat.is(copyCat)  // Groovy identity
assert cat === copyCat  // operator shorthand
assert cat !== lion     // negated operator shorthand
```

#### 1.2.3. Logical operators

Groovy offers three logical operators for boolean expressions:

- `&&`: logical "and"
- `||`: logical "or"
- `!`: logical "not"

Let’s illustrate them with the following examples:

```groovy
assert !false           
assert true && true     
assert true || false    
```

|      | "not" false is true     |
| ---- | ----------------------- |
|      | true "and" true is true |
|      | true "or" false is true |

##### Precedence

The logical "not" has a higher priority than the logical "and".

```groovy
assert (!false && false) == false   
```

|      | Here, the assertion is true (as the expression in parentheses is false), because "not" has a higher precedence than "and", so it only applies to the first "false" term; otherwise, it would have applied to the result of the "and", turned it into true, and the assertion would have failed |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The logical "and" has a higher priority than the logical "or".

```groovy
assert true || true && false        
```

|      | Here, the assertion is true, because "and" has a higher precedence than "or", therefore the "or" is executed last and returns true, having one true argument; otherwise, the "and" would have executed last and returned false, having one false argument, and the assertion would have failed |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Short-circuiting

The logical `||` operator supports short-circuiting: if the left operand is true, it knows that the result will be true in any case, so it won’t evaluate the right operand. The right operand will be evaluated only if the left operand is false.

Likewise for the logical `&&` operator: if the left operand is false, it knows that the result will be false in any case, so it won’t evaluate the right operand. The right operand will be evaluated only if the left operand is true.

```groovy
boolean checkIfCalled() {   
    called = true
}

called = false
true || checkIfCalled()
assert !called              

called = false
false || checkIfCalled()
assert called               

called = false
false && checkIfCalled()
assert !called              

called = false
true && checkIfCalled()
assert called               
```

|      | We create a function that sets the `called` flag to true whenever it’s called |
| ---- | ------------------------------------------------------------ |
|      | In the first case, after resetting the called flag, we confirm that if the left operand to `||` is true, the function is not called, as `||` short-circuits the evaluation of the right operand |
|      | In the second case, the left operand is false and so the function is called, as indicated by the fact our flag is now true |
|      | Likewise for `&&`, we confirm that the function is not called with a false left operand |
|      | But the function is called with a true left operand          |

#### 1.2.4. Bitwise operators

Groovy offers 4 bitwise operators:

- `&`: bitwise "and"
- `|`: bitwise "or"
- `^`: bitwise "xor" (exclusive "or")
- `~`: bitwise negation

Bitwise operators can be applied on a `byte` or an `int` and return an `int`:

```groovy
int a = 0b00101010
assert a == 42
int b = 0b00001000
assert b == 8
assert (a & a) == a                     
assert (a & b) == b                     
assert (a | a) == a                     
assert (a | b) == a                     

int mask = 0b11111111                   
assert ((a ^ a) & mask) == 0b00000000   
assert ((a ^ b) & mask) == 0b00100010   
assert ((~a) & mask)    == 0b11010101   
```

|      | bitwise and                                  |
| ---- | -------------------------------------------- |
|      | bitwise and returns common bits              |
|      | bitwise or                                   |
|      | bitwise or returns all '1' bits              |
|      | setting a mask to check only the last 8 bits |
|      | bitwise exclusive or on self returns 0       |
|      | bitwise exclusive or                         |
|      | bitwise negation                             |

It’s worth noting that the internal representation of primitive types follow the [Java Language Specification](http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html). In particular, primitive types are signed, meaning that for a bitwise negation, it is always good to use a mask to retrieve only the necessary bits.

In Groovy, bitwise operators have the particularity of being [overloadable](https://docs.groovy-lang.org/latest/html/documentation/#Operator-Overloading), meaning that you can define the behavior of those operators for any kind of object.

#### 1.2.5. Conditional operators

##### Not operator

The "not" operator is represented with an exclamation mark (`!`) and inverts the result of the underlying boolean expression. In particular, it is possible to combine the `not` operator with the [Groovy truth](https://docs.groovy-lang.org/latest/html/documentation/#Groovy-Truth):

```groovy
assert (!true)    == false                      
assert (!'foo')   == false                      
assert (!'')      == true                       
```

|      | the negation of `true` is `false`                            |
| ---- | ------------------------------------------------------------ |
|      | 'foo' is a non empty string, evaluating to `true`, so negation returns `false` |
|      | '' is an empty string, evaluating to `false`, so negation returns `true` |

##### Ternary operator

The ternary operator is a shortcut expression that is equivalent to an if/else branch assigning some value to a variable.

Instead of:

```groovy
if (string!=null && string.length()>0) {
    result = 'Found'
} else {
    result = 'Not found'
}
```

You can write:

```groovy
result = (string!=null && string.length()>0) ? 'Found' : 'Not found'
```

The ternary operator is also compatible with the [Groovy truth](https://docs.groovy-lang.org/latest/html/documentation/#Groovy-Truth), so you can make it even simpler:

```groovy
result = string ? 'Found' : 'Not found'
```

##### Elvis operator

The "Elvis operator" is a shortening of the ternary operator. One instance of where this is handy is for returning a 'sensible default' value if an expression resolves to `false`-ish (as in [Groovy truth](https://docs.groovy-lang.org/latest/html/documentation/#Groovy-Truth)). A simple example might look like this:

```groovy
displayName = user.name ? user.name : 'Anonymous'   
displayName = user.name ?: 'Anonymous'              
```

|      | with the ternary operator, you have to repeat the value you want to assign |
| ---- | ------------------------------------------------------------ |
|      | with the Elvis operator, the value, which is tested, is used if it is not `false`-ish |

Usage of the Elvis operator reduces the verbosity of your code and reduces the risks of errors in case of refactorings, by removing the need to duplicate the expression which is tested in both the condition and the positive return value.

##### Elvis assignment operator

Groovy 3.0.0 introduces the Elvis operator, for example:

```groovy
import groovy.transform.ToString

@ToString
class Element {
    String name
    int atomicNumber
}

def he = new Element(name: 'Helium')
he.with {
    name = name ?: 'Hydrogen'   // existing Elvis operator
    atomicNumber ?= 2           // new Elvis assignment shorthand
}
assert he.toString() == 'Element(Helium, 2)'
```

#### 1.2.6. Object operators

##### Safe navigation operator

The Safe Navigation operator is used to avoid a `NullPointerException`. Typically when you have a reference to an object you might need to verify that it is not `null` before accessing methods or properties of the object. To avoid this, the safe navigation operator will simply return `null` instead of throwing an exception, like so:

```groovy
def person = Person.find { it.id == 123 }    
def name = person?.name                      
assert name == null                          
```

|      | `find` will return a `null` instance                         |
| ---- | ------------------------------------------------------------ |
|      | use of the null-safe operator prevents from a `NullPointerException` |
|      | result is `null`                                             |

##### Direct field access operator

Normally in Groovy, when you write code like this:

```groovy
class User {
    public final String name                 
    User(String name) { this.name = name}
    String getName() { "Name: $name" }       
}
def user = new User('Bob')
assert user.name == 'Name: Bob'              
```

|      | public field `name`                              |
| ---- | ------------------------------------------------ |
|      | a getter for `name` that returns a custom string |
|      | calls the getter                                 |

The `user.name` call triggers a call to the property of the same name, that is to say, here, to the getter for `name`. If you want to retrieve the field instead of calling the getter, you can use the direct field access operator:

```groovy
assert user.@name == 'Bob'                   
```

|      | use of `.@` forces usage of the field instead of the getter |
| ---- | ----------------------------------------------------------- |
|      |                                                             |

##### Method pointer operator

The method pointer operator (`.&`) can be used to store a reference to a method in a variable, in order to call it later:

```groovy
def str = 'example of method reference'            
def fun = str.&toUpperCase                         
def upper = fun()                                  
assert upper == str.toUpperCase()                  
```

|      | the `str` variable contains a `String`                       |
| ---- | ------------------------------------------------------------ |
|      | we store a reference to the `toUpperCase` method on the `str` instance inside a variable named `fun` |
|      | `fun` can be called like a regular method                    |
|      | we can check that the result is the same as if we had called it directly on `str` |

There are multiple advantages in using method pointers. First of all, the type of such a method pointer is a `groovy.lang.Closure`, so it can be used in any place a closure would be used. In particular, it is suitable to convert an existing method for the needs of the strategy pattern:

```groovy
def transform(List elements, Closure action) {                    
    def result = []
    elements.each {
        result << action(it)
    }
    result
}
String describe(Person p) {                                       
    "$p.name is $p.age"
}
def action = this.&describe                                       
def list = [
    new Person(name: 'Bob',   age: 42),
    new Person(name: 'Julia', age: 35)]                           
assert transform(list, action) == ['Bob is 42', 'Julia is 35']    
```

|      | the `transform` method takes each element of the list and calls the `action` closure on them, returning a new list |
| ---- | ------------------------------------------------------------ |
|      | we define a function that takes a `Person` and returns a `String` |
|      | we create a method pointer on that function                  |
|      | we create the list of elements we want to collect the descriptors |
|      | the method pointer can be used where a `Closure` was expected |

Method pointers are bound by the receiver and a method name. Arguments are resolved at runtime, meaning that if you have multiple methods with the same name, the syntax is not different, only resolution of the appropriate method to be called will be done at runtime:

```groovy
def doSomething(String str) { str.toUpperCase() }    
def doSomething(Integer x) { 2*x }                   
def reference = this.&doSomething                    
assert reference('foo') == 'FOO'                     
assert reference(123)   == 246                       
```

|      | define an overloaded `doSomething` method accepting a `String` as an argument |
| ---- | ------------------------------------------------------------ |
|      | define an overloaded `doSomething` method accepting an `Integer` as an argument |
|      | create a single method pointer on `doSomething`, without specifying argument types |
|      | using the method pointer with a `String` calls the `String` version of `doSomething` |
|      | using the method pointer with an `Integer` calls the `Integer` version of `doSomething` |

To align with Java 8 method reference expectations, in Groovy 3 and above, you can use `new` as the method name to obtain a method pointer to the constructor:

```groovy
def foo  = BigInteger.&new
def fortyTwo = foo('42')
assert fortyTwo == 42G
```

Also in Groovy 3 and above, you can obtain a method pointer to an instance method of a class. This method pointer takes an additional parameter being the receiver instance to invoke the method on:

```groovy
def instanceMethod = String.&toUpperCase
assert instanceMethod('foo') == 'FOO'
```

For backwards compatibility, any static methods that happen to have the correct parameters for the call will be given precedence over instance methods for this case.

##### Method reference operator

The Parrot parser in Groovy 3+ supports the Java 8+ method reference operator. The method reference operator (`::`) can be used to reference a method or constructor in contexts expecting a functional interface. This overlaps somewhat with the functionality provided by Groovy’s method pointer operator. Indeed, for dynamic Groovy, the method reference operator is just an alias for the method pointer operator. For static Groovy, the operator results in bytecode similar to the bytecode that Java would produce for the same context.

Some examples highlighting various supported method reference cases are shown in the following script:

```groovy
import groovy.transform.CompileStatic
import static java.util.stream.Collectors.toList

@CompileStatic
void methodRefs() {
    assert 6G == [1G, 2G, 3G].stream().reduce(0G, BigInteger::add)                           

    assert [4G, 5G, 6G] == [1G, 2G, 3G].stream().map(3G::add).collect(toList())              

    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(BigInteger::valueOf).collect(toList())  

    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(3G::valueOf).collect(toList())          
}

methodRefs()
```

|      | class instance method reference: add(BigInteger val) is an instance method in BigInteger |
| ---- | ------------------------------------------------------------ |
|      | object instance method reference: add(BigInteger val) is an instance method for object 3G |
|      | class static method reference: valueOf(long val) is a static method for class BigInteger |
|      | object static method reference: valueOf(long val) is a static method for object 3G (some consider this bad style in normal circumstances) |

Some examples highlighting various supported constructor reference cases are shown in the following script:

```groovy
@CompileStatic
void constructorRefs() {
    assert [1, 2, 3] == ['1', '2', '3'].stream().map(Integer::new).collect(toList())  

    def result = [1, 2, 3].stream().toArray(Integer[]::new)                           
    assert result instanceof Integer[]
    assert result.toString() == '[1, 2, 3]'
}

constructorRefs()
```

|      | class constructor reference |
| ---- | --------------------------- |
|      | array constructor reference |

#### 1.2.7. Regular expression operators

##### Pattern operator

The pattern operator (`~`) provides a simple way to create a `java.util.regex.Pattern` instance:

```groovy
def p = ~/foo/
assert p instanceof Pattern
```

while in general, you find the pattern operator with an expression in a slashy-string, it can be used with any kind of `String` in Groovy:

```groovy
p = ~'foo'                                                        
p = ~"foo"                                                        
p = ~$/dollar/slashy $ string/$                                   
p = ~"${pattern}"                                                 
```

|      | using single quote strings                                   |
| ---- | ------------------------------------------------------------ |
|      | using double quotes strings                                  |
|      | the dollar-slashy string lets you use slashes and the dollar sign without having to escape them |
|      | you can also use a GString!                                  |

##### Find operator

Alternatively to building a pattern, you can use the find operator `=~` to directly create a `java.util.regex.Matcher` instance:

```groovy
def text = "some text to match"
def m = text =~ /match/                                           
assert m instanceof Matcher                                       
if (!m) {                                                         
    throw new RuntimeException("Oops, text not found!")
}
```

|      | `=~` creates a matcher against the `text` variable, using the pattern on the right hand side |
| ---- | ------------------------------------------------------------ |
|      | the return type of `=~` is a `Matcher`                       |
|      | equivalent to calling `if (!m.find(0))`                      |

Since a `Matcher` coerces to a `boolean` by calling its `find` method, the `=~` operator is consistent with the simple use of Perl’s `=~` operator, when it appears as a predicate (in `if`, `?:`, etc.). When the intent is to iterate over matches of the specified pattern (in `while`, etc.) call `find()` directly on the matcher or use the `iterator` DGM.

##### Match operator

The match operator (`==~`) is a slight variation of the find operator, that does not return a `Matcher` but a boolean and requires a strict match of the input string:

```groovy
m = text ==~ /match/                                              
assert m instanceof Boolean                                       
if (m) {                                                          
    throw new RuntimeException("Should not reach that point!")
}
```

|      | `==~` matches the subject with the regular expression, but match must be strict |
| ---- | ------------------------------------------------------------ |
|      | the return type of `==~` is therefore a `boolean`            |
|      | equivalent to calling `if (text ==~ /match/)`                |

#### 1.2.8. Other operators

##### Spread operator

The Spread-dot Operator (`*.`), often abbreviated to just Spread Operator, is used to invoke an action on all items of an aggregate object. It is equivalent to calling the action on each item and collecting the result into a list:

```groovy
class Car {
    String make
    String model
}
def cars = [
       new Car(make: 'Peugeot', model: '508'),
       new Car(make: 'Renault', model: 'Clio')]       
def makes = cars*.make                                
assert makes == ['Peugeot', 'Renault']                
```

|      | build a list of `Car` items. The list is an aggregate of objects. |
| ---- | ------------------------------------------------------------ |
|      | call the spread operator on the list, accessing the `make` property of each item |
|      | returns a list of strings corresponding to the collection of `make` items |

The expression `cars*.make` is equivalent to `cars.collect{ it.make }`. Groovy’s GPath notation allows a short-cut when the referenced property isn’t a property of the containing list, in that case it is automatically spread. In the previously mentioned case, the expression `cars.make` can be used, though retaining the explicit spread-dot operator is often recommended.

The spread operator is null-safe, meaning that if an element of the collection is null, it will return null instead of throwing a `NullPointerException`:

```groovy
cars = [
   new Car(make: 'Peugeot', model: '508'),
   null,                                              
   new Car(make: 'Renault', model: 'Clio')]
assert cars*.make == ['Peugeot', null, 'Renault']     
assert null*.make == null                             
```

|      | build a list for which of of the elements is `null`          |
| ---- | ------------------------------------------------------------ |
|      | using the spread operator will **not** throw a `NullPointerException` |
|      | the receiver might also be null, in which case the return value is `null` |

The spread operator can be used on any class which implements the `Iterable` interface:

```groovy
class Component {
    Long id
    String name
}
class CompositeObject implements Iterable<Component> {
    def components = [
        new Component(id: 1, name: 'Foo'),
        new Component(id: 2, name: 'Bar')]

    @Override
    Iterator<Component> iterator() {
        components.iterator()
    }
}
def composite = new CompositeObject()
assert composite*.id == [1,2]
assert composite*.name == ['Foo','Bar']
```

Use multiple invocations of the spread-dot operator (here `cars*.models*.name`) when working with aggregates of data structures which themselves contain aggregates:

```groovy
class Make {
    String name
    List<Model> models
}

@Canonical
class Model {
    String name
}

def cars = [
    new Make(name: 'Peugeot',
             models: [new Model('408'), new Model('508')]),
    new Make(name: 'Renault',
             models: [new Model('Clio'), new Model('Captur')])
]

def makes = cars*.name
assert makes == ['Peugeot', 'Renault']

def models = cars*.models*.name
assert models == [['408', '508'], ['Clio', 'Captur']]
assert models.sum() == ['408', '508', 'Clio', 'Captur'] // flatten one level
assert models.flatten() == ['408', '508', 'Clio', 'Captur'] // flatten all levels (one in this case)
```

Consider using the `collectNested` DGM method instead of the spread-dot operator for collections of collections:

```groovy
class Car {
    String make
    String model
}
def cars = [
   [
       new Car(make: 'Peugeot', model: '408'),
       new Car(make: 'Peugeot', model: '508')
   ], [
       new Car(make: 'Renault', model: 'Clio'),
       new Car(make: 'Renault', model: 'Captur')
   ]
]
def models = cars.collectNested{ it.model }
assert models == [['408', '508'], ['Clio', 'Captur']]
```

###### Spreading method arguments

There may be situations when the arguments of a method call can be found in a list that you need to adapt to the method arguments. In such situations, you can use the spread operator to call the method. For example, imagine you have the following method signature:

```groovy
int function(int x, int y, int z) {
    x*y+z
}
```

then if you have the following list:

```groovy
def args = [4,5,6]
```

you can call the method without having to define intermediate variables:

```groovy
assert function(*args) == 26
```

It is even possible to mix normal arguments with spread ones:

```groovy
args = [4]
assert function(*args,5,6) == 26
```

###### Spread list elements

When used inside a list literal, the spread operator acts as if the spread element contents were inlined into the list:

```groovy
def items = [4,5]                      
def list = [1,2,3,*items,6]            
assert list == [1,2,3,4,5,6]           
```

|      | `items` is a list                                            |
| ---- | ------------------------------------------------------------ |
|      | we want to insert the contents of the `items` list directly into `list` without having to call `addAll` |
|      | the contents of `items` has been inlined into `list`         |

###### Spread map elements

The spread map operator works in a similar manner as the spread list operator, but for maps. It allows you to inline the contents of a map into another map literal, like in the following example:

```groovy
def m1 = [c:3, d:4]                   
def map = [a:1, b:2, *:m1]            
assert map == [a:1, b:2, c:3, d:4]    
```

|      | `m1` is the map that we want to inline                       |
| ---- | ------------------------------------------------------------ |
|      | we use the `*:m1` notation to spread the contents of `m1` into `map` |
|      | `map` contains all the elements of `m1`                      |

The position of the spread map operator is relevant, like illustrated in the following example:

```groovy
def m1 = [c:3, d:4]                   
def map = [a:1, b:2, *:m1, d: 8]      
assert map == [a:1, b:2, c:3, d:8]    
```

|      | `m1` is the map that we want to inline                       |
| ---- | ------------------------------------------------------------ |
|      | we use the `*:m1` notation to spread the contents of `m1` into `map`, but redefine the key `d` **after** spreading |
|      | `map` contains all the expected keys, but `d` was redefined  |

##### Range operator

Groovy supports the concept of ranges and provides a notation (`..`) to create ranges of objects:

```groovy
def range = 0..5                                    
assert (0..5).collect() == [0, 1, 2, 3, 4, 5]       
assert (0..<5).collect() == [0, 1, 2, 3, 4]         
assert (0..5) instanceof List                       
assert (0..5).size() == 6                           
```

|      | a simple range of integers, stored into a local variable |
| ---- | -------------------------------------------------------- |
|      | an `IntRange`, with inclusive bounds                     |
|      | an `IntRange`, with exclusive upper bound                |
|      | a `groovy.lang.Range` implements the `List` interface    |
|      | meaning that you can call the `size` method on it        |

Ranges implementation is lightweight, meaning that only the lower and upper bounds are stored. You can create a range from any `Comparable` object that has `next()` and `previous()` methods to determine the next / previous item in the range. For example, you can create a range of characters this way:

```groovy
assert ('a'..'d').collect() == ['a','b','c','d']
```

##### Spaceship operator

The spaceship operator (`<=>`) delegates to the `compareTo` method:

```groovy
assert (1 <=> 1) == 0
assert (1 <=> 2) == -1
assert (2 <=> 1) == 1
assert ('a' <=> 'z') == -1
```

##### Subscript operator

The subscript operator is a short hand notation for `getAt` or `putAt`, depending on whether you find it on the left hand side or the right hand side of an assignment:

```groovy
def list = [0,1,2,3,4]
assert list[2] == 2                         
list[2] = 4                                 
assert list[0..2] == [0,1,4]                
list[0..2] = [6,6,6]                        
assert list == [6,6,6,3,4]                  
```

|      | `[2]` can be used instead of `getAt(2)`                  |
| ---- | -------------------------------------------------------- |
|      | if on left hand side of an assignment, will call `putAt` |
|      | `getAt` also supports ranges                             |
|      | so does `putAt`                                          |
|      | the list is mutated                                      |

The subscript operator, in combination with a custom implementation of `getAt`/`putAt` is a convenient way for destructuring objects:

```groovy
class User {
    Long id
    String name
    def getAt(int i) {                                             
        switch (i) {
            case 0: return id
            case 1: return name
        }
        throw new IllegalArgumentException("No such element $i")
    }
    void putAt(int i, def value) {                                 
        switch (i) {
            case 0: id = value; return
            case 1: name = value; return
        }
        throw new IllegalArgumentException("No such element $i")
    }
}
def user = new User(id: 1, name: 'Alex')                           
assert user[0] == 1                                                
assert user[1] == 'Alex'                                           
user[1] = 'Bob'                                                    
assert user.name == 'Bob'                                          
```

|      | the `User` class defines a custom `getAt` implementation     |
| ---- | ------------------------------------------------------------ |
|      | the `User` class defines a custom `putAt` implementation     |
|      | create a sample user                                         |
|      | using the subscript operator with index 0 allows retrieving the user id |
|      | using the subscript operator with index 1 allows retrieving the user name |
|      | we can use the subscript operator to write to a property thanks to the delegation to `putAt` |
|      | and check that it’s really the property `name` which was changed |

##### Safe index operator

Groovy 3.0.0 introduces safe indexing operator, i.e. `?[]`, which is similar to `?.`. For example:

```groovy
String[] array = ['a', 'b']
assert 'b' == array?[1]      // get using normal array index
array?[1] = 'c'              // set using normal array index
assert 'c' == array?[1]

array = null
assert null == array?[1]     // return null for all index values
array?[1] = 'c'              // quietly ignore attempt to set value
assert null == array?[1]

def personInfo = [name: 'Daniel.Sun', location: 'Shanghai']
assert 'Daniel.Sun' == personInfo?['name']      // get using normal map index
personInfo?['name'] = 'sunlan'                  // set using normal map index
assert 'sunlan' == personInfo?['name']

personInfo = null
assert null == personInfo?['name']              // return null for all map values
personInfo?['name'] = 'sunlan'                  // quietly ignore attempt to set value
assert null == personInfo?['name']
```

##### Membership operator

The membership operator (`in`) is equivalent to calling the `isCase` method. In the context of a `List`, it is equivalent to calling `contains`, like in the following example:

```groovy
def list = ['Grace','Rob','Emmy']
assert ('Emmy' in list)                     
```

|      | equivalent to calling `list.contains('Emmy')` or `list.isCase('Emmy')` |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Identity operator

In Groovy, using `==` to test equality is different from using the same operator in Java. In Groovy, it is calling `equals`. If you want to compare reference equality, you should use `is` like in the following example:

```groovy
def list1 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        
def list2 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        
assert list1 == list2                                       
assert !list1.is(list2)                                     
```

|      | Create a list of strings                                    |
| ---- | ----------------------------------------------------------- |
|      | Create another list of strings containing the same elements |
|      | using `==`, we test object equality                         |
|      | but using `is`, we can check that references are distinct   |

##### Coercion operator

The coercion operator (`as`) is a variant of casting. Coercion converts object from one type to another **without** them being compatible for assignment. Let’s take an example:

```groovy
Integer x = 123
String s = (String) x                                   
```

|      | `Integer` is not assignable to a `String`, so it will produce a `ClassCastException` at runtime |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

This can be fixed by using *coercion* instead:

```groovy
Integer x = 123
String s = x as String                                  
```

|      | `Integer` is not assignable to a `String`, but use of `as` will *coerce* it to a `String` |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

When an object is coerced into another, unless the target type is the same as the source type, coercion will return a **new** object. The rules of coercion differ depending on the source and target types, and coercion may fail if no conversion rules are found. Custom conversion rules may be implemented thanks to the `asType` method:

```groovy
class Identifiable {
    String name
}
class User {
    Long id
    String name
    def asType(Class target) {                                              
        if (target == Identifiable) {
            return new Identifiable(name: name)
        }
        throw new ClassCastException("User cannot be coerced into $target")
    }
}
def u = new User(name: 'Xavier')                                            
def p = u as Identifiable                                                   
assert p instanceof Identifiable                                            
assert !(p instanceof User)                                                 
```

|      | the `User` class defines a custom conversion rule from `User` to `Identifiable` |
| ---- | ------------------------------------------------------------ |
|      | we create an instance of `User`                              |
|      | we coerce the `User` instance into an `Identifiable`         |
|      | the target is an instance of `Identifiable`                  |
|      | the target is not an instance of `User` anymore              |

##### Diamond operator

The diamond operator (`<>`) is a syntactic sugar only operator added to support compatibility with the operator of the same name in Java 7. It is used to indicate that generic types should be inferred from the declaration:

```groovy
List<String> strings = new LinkedList<>()
```

In dynamic Groovy, this is totally unused. In statically type checked Groovy, it is also optional since the Groovy type checker performs type inference whether this operator is present or not.

##### Call operator

The call operator `()` is used to call a method named `call` implicitly. For any object which defines a `call` method, you can omit the `.call` part and use the call operator instead:

```groovy
class MyCallable {
    int call(int x) {           
        2*x
    }
}

def mc = new MyCallable()
assert mc.call(2) == 4          
assert mc(2) == 4               
```

|      | `MyCallable` defines a method named `call`. Note that it doesn’t need to implement `java.util.concurrent.Callable` |
| ---- | ------------------------------------------------------------ |
|      | we can call the method using the classic method call syntax  |
|      | or we can omit `.call` thanks to the call operator           |

#### 1.2.9. Operator precedence

The table below lists all groovy operators in order of precedence.

| Level | Operator(s)                                                  | Name(s)                                                      |
| :---- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 1     | `new`  `()`                                                  | object creation, explicit parentheses                        |
|       | `()`  `{}`  `[]`                                             | method call, closure, literal list/map                       |
|       | `.`  `.&`  `.@`                                              | member access, method closure, field/attribute access        |
|       | `?.`  `*`  `*.`  `*:`                                        | safe dereferencing, spread, spread-dot, spread-map           |
|       | `~`  `!`  `(type)`                                           | bitwise negate/pattern, not, typecast                        |
|       | `[]`  `?[]`  `++`  `--`                                      | list/map/array (safe) index, post inc/decrement              |
| 2     | `**`                                                         | power                                                        |
| 3     | `++`  `--`  `+`  `-`                                         | pre inc/decrement, unary plus, unary minus                   |
| 4     | `*`  `/`  `%`                                                | multiply, div, remainder                                     |
| 5     | `+`  `-`                                                     | addition, subtraction                                        |
| 6     | `<<`  `>>`  `>>>`  `..`  `..<`                               | left/right (unsigned) shift, inclusive/exclusive range       |
| 7     | `<`  `<=`  `>`  `>=`  `in`  `!in`  `instanceof`  `!instanceof`  `as` | less/greater than/or equal, in, not in, instanceof, not instanceof, type coercion |
| 8     | `==`  `!=`  `<=>`  `===`  `!==`                              | equals, not equals, compare to, identical to, not identical to |
|       | `=~`  `==~`                                                  | regex find, regex match                                      |
| 9     | `&`                                                          | binary/bitwise and                                           |
| 10    | `^`                                                          | binary/bitwise xor                                           |
| 11    | `|`                                                          | binary/bitwise or                                            |
| 12    | `&&`                                                         | logical and                                                  |
| 13    | `||`                                                         | logical or                                                   |
| 14    | `? :`                                                        | ternary conditional                                          |
|       | `?:`                                                         | elvis operator                                               |
| 15    | `=`  `**=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `>>>=`  `&=`  `^=`  `|=`   `?=` | various assignments                                          |

#### 1.2.10. Operator overloading

Groovy allows you to overload the various operators so that they can be used with your own classes. Consider this simple class:

```groovy
class Bucket {
    int size

    Bucket(int size) { this.size = size }

    Bucket plus(Bucket other) {                     
        return new Bucket(this.size + other.size)
    }
}
```

|      | `Bucket` implements a special method called `plus()` |
| ---- | ---------------------------------------------------- |
|      |                                                      |

Just by implementing the `plus()` method, the `Bucket` class can now be used with the `+` operator like so:

```groovy
def b1 = new Bucket(4)
def b2 = new Bucket(11)
assert (b1 + b2).size == 15                         
```

|      | The two `Bucket` objects can be added together with the `+` operator |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

All (non-comparator) Groovy operators have a corresponding method that you can implement in your own classes. The only requirements are that your method is public, has the correct name, and has the correct number of arguments. The argument types depend on what types you want to support on the right hand side of the operator. For example, you could support the statement

```groovy
assert (b1 + 11).size == 15
```

by implementing the `plus()` method with this signature:

```groovy
Bucket plus(int capacity) {
    return new Bucket(this.size + capacity)
}
```

Here is a complete list of the operators and their corresponding methods:

| Operator | Method        | Operator   | Method                  |
| :------- | :------------ | :--------- | :---------------------- |
| `+`      | a.plus(b)     | `a[b]`     | a.getAt(b)              |
| `-`      | a.minus(b)    | `a[b] = c` | a.putAt(b, c)           |
| `*`      | a.multiply(b) | `a in b`   | b.isCase(a)             |
| `/`      | a.div(b)      | `<<`       | a.leftShift(b)          |
| `%`      | a.mod(b)      | `>>`       | a.rightShift(b)         |
| `**`     | a.power(b)    | `>>>`      | a.rightShiftUnsigned(b) |
| `|`      | a.or(b)       | `++`       | a.next()                |
| `&`      | a.and(b)      | `--`       | a.previous()            |
| `^`      | a.xor(b)      | `+a`       | a.positive()            |
| `as`     | a.asType(b)   | `-a`       | a.negative()            |
| `a()`    | a.call()      | `~a`       | a.bitwiseNegate()       |

### 1.3. Program structure

This chapter covers the program structure of the Groovy programming language.

#### 1.3.1. Package names

Package names play exactly the same role as in Java. They allows us to separate the code base without any conflicts. Groovy classes must specify their package before the class definition, else the default package is assumed.

Defining a package is very similar to Java:

```groovy
// defining a package named com.yoursite
package com.yoursite
```

To refer to some class `Foo` in the `com.yoursite.com` package you will need to use the fully qualified name `com.yoursite.com.Foo`, or else you can use an `import` statement as we’ll see below.

#### 1.3.2. Imports

In order to refer to any class you need a qualified reference to its package. Groovy follows Java’s notion of allowing `import` statement to resolve class references.

For example, Groovy provides several builder classes, such as `MarkupBuilder`. `MarkupBuilder` is inside the package `groovy.xml` so in order to use this class, you need to `import` it as shown:

```groovy
// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null
```

##### Default imports

Default imports are the imports that Groovy language provides by default. For example look at the following code:

```groovy
new Date()
```

The same code in Java needs an import statement to `Date` class like this: import java.util.Date. Groovy by default imports these classes for you.

The below imports are added by groovy for you:

```groovy
import java.lang.*
import java.util.*
import java.io.*
import java.net.*
import groovy.lang.*
import groovy.util.*
import java.math.BigInteger
import java.math.BigDecimal
```

This is done because the classes from these packages are most commonly used. By importing these boilerplate code is reduced.

##### Simple import

A simple import is an import statement where you fully define the class name along with the package. For example the import statement import groovy.xml.MarkupBuilder in the code below is a simple import which directly refers to a class inside a package.

```groovy
// importing the class MarkupBuilder
import groovy.xml.MarkupBuilder

// using the imported class to create an object
def xml = new MarkupBuilder()

assert xml != null
```

##### Star import

Groovy, like Java, provides a special way to import all classes from a package using `*`, the so called star import. `MarkupBuilder` is a class which is in package `groovy.xml`, alongside another class called `StreamingMarkupBuilder`. In case you need to use both classes, you can do:

```groovy
import groovy.xml.MarkupBuilder
import groovy.xml.StreamingMarkupBuilder

def markupBuilder = new MarkupBuilder()

assert markupBuilder != null

assert new StreamingMarkupBuilder() != null
```

That’s perfectly valid code. But with a `*` import, we can achieve the same effect with just one line. The star imports all the classes under package `groovy.xml`:

```groovy
import groovy.xml.*

def markupBuilder = new MarkupBuilder()

assert markupBuilder != null

assert new StreamingMarkupBuilder() != null
```

One problem with `*` imports is that they can clutter your local namespace. But with the kinds of aliasing provided by Groovy, this can be solved easily.

##### Static import

Groovy’s static import capability allows you to reference imported classes as if they were static methods in your own class:

```groovy
import static Boolean.FALSE

assert !FALSE //use directly, without Boolean prefix!
```

This is similar to Java’s static import capability but is a more dynamic than Java in that it allows you to define methods with the same name as an imported method as long as you have different types:

```groovy
import static java.lang.String.format 

class SomeClass {

    String format(Integer i) { 
        i.toString()
    }

    static void main(String[] args) {
        assert format('String') == 'String' 
        assert new SomeClass().format(Integer.valueOf(1)) == '1'
    }
}
```

|      | static import of method                                      |
| ---- | ------------------------------------------------------------ |
|      | declaration of method with same name as method statically imported above, but with a different parameter type |
|      | compile error in java, but is valid groovy code              |

If you have the same types, the imported class takes precedence.

##### Static import aliasing

Static imports with the `as` keyword provide an elegant solution to namespace problems. Suppose you want to get a `Calendar` instance, using its `getInstance()` method. It’s a static method, so we can use a static import. But instead of calling `getInstance()` every time, which can be misleading when separated from its class name, we can import it with an alias, to increase code readability:

```groovy
import static Calendar.getInstance as now

assert now().class == Calendar.getInstance().class
```

Now, that’s clean!

##### Static star import

A static star import is very similar to the regular star import. It will import all the static methods from the given class.

For example, lets say we need to calculate sines and cosines for our application. The class `java.lang.Math` has static methods named `sin` and `cos` which fit our need. With the help of a static star import, we can do:

```groovy
import static java.lang.Math.*

assert sin(0) == 0.0
assert cos(0) == 1.0
```

As you can see, we were able to access the methods `sin` and `cos` directly, without the `Math.` prefix.

##### Import aliasing

With type aliasing, we can refer to a fully qualified class name using a name of our choice. This can be done with the `as` keyword, as before.

For example we can import `java.sql.Date` as `SQLDate` and use it in the same file as `java.util.Date` without having to use the fully qualified name of either class:

```groovy
import java.util.Date
import java.sql.Date as SQLDate

Date utilDate = new Date(1000L)
SQLDate sqlDate = new SQLDate(1000L)

assert utilDate instanceof java.util.Date
assert sqlDate instanceof java.sql.Date
```

#### 1.3.3. Scripts versus classes

##### public static void main vs script

Groovy supports both scripts and classes. Take the following code for example:

Main.groovy

```groovy
class Main {                                    
    static void main(String... args) {          
        println 'Groovy world!'                 
    }
}
```

|      | define a `Main` class, the name is arbitrary                 |
| ---- | ------------------------------------------------------------ |
|      | the `public static void main(String[])` method is usable as the main method of the class |
|      | the main body of the method                                  |

This is typical code that you would find coming from Java, where code **has** to be embedded into a class to be executable. Groovy makes it easier, the following code is equivalent:

Main.groovy

```groovy
println 'Groovy world!'
```

A script can be considered as a class without needing to declare it, with some differences.

##### Script class

A [script](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/Script.html) is always compiled into a class. The Groovy compiler will compile the class for you, with the body of the script copied into a `run` method. The previous example is therefore compiled as if it was the following:

Main.groovy

```groovy
import org.codehaus.groovy.runtime.InvokerHelper
class Main extends Script {                     
    def run() {                                 
        println 'Groovy world!'                 
    }
    static void main(String[] args) {           
        InvokerHelper.runScript(Main, args)     
    }
}
```

|      | The `Main` class extends the `groovy.lang.Script` class      |
| ---- | ------------------------------------------------------------ |
|      | `groovy.lang.Script` requires a `run` method returning a value |
|      | the script body goes into the `run` method                   |
|      | the `main` method is automatically generated                 |
|      | and delegates the execution of the script on the `run` method |

If the script is in a file, then the base name of the file is used to determine the name of the generated script class. In this example, if the name of the file is `Main.groovy`, then the script class is going to be `Main`.

##### Methods

It is possible to define methods into a script, as illustrated here:

```groovy
int fib(int n) {
    n < 2 ? 1 : fib(n-1) + fib(n-2)
}
assert fib(10)==89
```

You can also mix methods and code. The generated script class will carry all methods into the script class, and assemble all script bodies into the `run` method:

```groovy
println 'Hello'                                 

int power(int n) { 2**n }                       

println "2^6==${power(6)}"                      
```

|      | script begins                              |
| ---- | ------------------------------------------ |
|      | a method is defined within the script body |
|      | and script continues                       |

This code is internally converted into:

```groovy
import org.codehaus.groovy.runtime.InvokerHelper
class Main extends Script {
    int power(int n) { 2** n}                   
    def run() {
        println 'Hello'                         
        println "2^6==${power(6)}"              
    }
    static void main(String[] args) {
        InvokerHelper.runScript(Main, args)
    }
}
```

|      | the `power` method is copied as is into the generated script class |
| ---- | ------------------------------------------------------------ |
|      | first statement is copied into the `run` method              |
|      | second statement is copied into the `run` method             |

|      | Even if Groovy creates a class from your script, it is totally transparent for the user. In particular, scripts are compiled to bytecode, and line numbers are preserved. This implies that if an exception is thrown in a script, the stack trace will show line numbers corresponding to the original script, not the generated code that we have shown. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Variables

Variables in a script do not require a type definition. This means that this script:

```groovy
int x = 1
int y = 2
assert x+y == 3
```

will behave the same as:

```groovy
x = 1
y = 2
assert x+y == 3
```

However there is a semantic difference between the two:

- if the variable is declared as in the first example, it is a *local variable*. It will be declared in the `run` method that the compiler will generate and will **not** be visible outside of the script main body. In particular, such a variable will **not** be visible in other methods of the script
- if the variable is undeclared, it goes into the [script binding](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/Script.html#getBinding()). The binding is visible from the methods, and is especially important if you use a script to interact with an application and need to share data between the script and the application. Readers might refer to the [integration guide](https://docs.groovy-lang.org/latest/html/documentation/#_integrating_groovy_in_a_java_application) for more information.

|      | If you want a variable to become a field of the class without going into the `Binding`, you can use the [@Field annotation](https://docs.groovy-lang.org/latest/html/documentation/#xform-Field). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

### 1.4. Object orientation

This chapter covers the object orientation of the Groovy programming language.

#### 1.4.1. Types

##### Primitive types

Groovy supports the same primitive types as those defined by the [Java Language Specification](http://docs.oracle.com/javase/specs/jls/se8/html/):

- integral types: `byte` (8 bit), `short` (16 bit), `int` (32 bit) and `long` (64 bit)
- floating-point types: `float` (32 bit) and `double` (64 bit)
- `boolean` type (exactly `true` or `false`)
- `char` type (16 bit, usable as a numeric type, representing an UTF-16 code)

While Groovy declares and stores primitive fields and variables as primitives, because it uses Objects for everything, it autowraps references to primitives. Just like Java, the wrappers it uses are

| Primitive type | Wrapper class |
| :------------- | :------------ |
| boolean        | Boolean       |
| char           | Character     |
| short          | Short         |
| int            | Integer       |
| long           | Long          |
| float          | Float         |
| double         | Double        |

Here’s an example using `int`

```groovy
class Foo {
  static int i
}

assert Foo.class.getDeclaredField('i').type == int.class
assert Foo.i.class != int.class && Foo.i.class == Integer.class
```

Now you may be concerned that this means every time you use a mathematical operator on a reference to a primitive that you’ll incur the cost of unboxing and reboxing the primitive. But this is not the case, as Groovy will compile your operators into their [method equivalents](https://docs.groovy-lang.org/latest/html/documentation/core-operators.html#_operator-overloading) and uses those instead. Additionally, Groovy will automatically unbox to a primitive when calling a Java method that takes a primitive parameter and automatically box primitive method return values from Java. However, be aware there are some [differences](https://docs.groovy-lang.org/latest/html/documentation/core-differences-java.html#_primitives_and_wrappers) from Java’s method resolution.

##### Class

Groovy classes are very similar to Java classes, and are compatible with Java ones at JVM level. They may have methods, fields and properties (think JavaBean properties but with less boilerplate). Classes and class members can have the same modifiers (public, protected, private, static, etc) as in Java with some minor differences at the source level which are explained shortly.

The key differences between Groovy classes and their Java counterparts are:

- Classes or methods with no visibility modifier are automatically public (a special annotation can be used to achieve package private visibility).
- Fields with no visibility modifier are turned into properties automatically, which results in less verbose code, since explicit getter and setter methods aren’t needed. More on this aspect will be covered in the [fields and properties section](https://docs.groovy-lang.org/latest/html/documentation/#fields).
- Classes do not need to have the same base name as their source file definitions but it is highly recommended in most scenarios (see also the next point about scripts).
- One source file may contain one or more classes (but if a file contains any code not in a class, it is considered a script). Scripts are just classes with some special conventions and will have the same name as their source file (so don’t include a class definition within a script having the same name as the script source file).

The following code presents an example class.

```groovy
class Person {                       

    String name                      
    Integer age

    def increaseAge(Integer years) { 
        this.age += years
    }
}
```

|      | class beginning, with the name `Person` |
| ---- | --------------------------------------- |
|      | string field and property named `name`  |
|      | method definition                       |

###### Normal class

Normal classes refer to classes which are top level and concrete. This means they can be instantiated without restrictions from any other classes or scripts. This way, they can only be public (even though the `public` keyword may be suppressed). Classes are instantiated by calling their constructors, using the `new` keyword, as in the following snippet.

```groovy
def p = new Person()
```

###### Inner class

Inner classes are defined within another classes. The enclosing class can use the inner class as usual. On the other side, a inner class can access members of its enclosing class, even if they are private. Classes other than the enclosing class are not allowed to access inner classes. Here is an example:

```groovy
class Outer {
    private String privateStr

    def callInnerMethod() {
        new Inner().methodA()       
    }

    class Inner {                   
        def methodA() {
            println "${privateStr}." 
        }
    }
}
```

|      | the inner class is instantiated and its method gets called   |
| ---- | ------------------------------------------------------------ |
|      | inner class definition, inside its enclosing class           |
|      | even being private, a field of the enclosing class is accessed by the inner class |

There are some reasons for using inner classes:

- They increase encapsulation by hiding the inner class from other classes, which do not need to know about it. This also leads to cleaner packages and workspaces.
- They provide a good organization, by grouping classes that are used by only one class.
- They lead to more maintainable codes, since inner classes are near the classes that use them.

In several cases, inner classes are implementation of interfaces whose methods are needed by the outer class. The code below illustrates this with the usage of threads, which are very common.

```groovy
class Outer2 {
    private String privateStr = 'some string'

    def startThread() {
       new Thread(new Inner2()).start()
    }

    class Inner2 implements Runnable {
        void run() {
            println "${privateStr}."
        }
    }
}
```

Note that the class `Inner2` is defined only to provide an implementation of the method `run` to class `Outer2`. Anonymous inner classes help to eliminate verbosity in this case.

Since Groovy 3.0.0, Java syntax for non-static inner class instantiation is now supported, for example:

```groovy
class Computer {
    class Cpu {
        int coreNumber

        Cpu(int coreNumber) {
            this.coreNumber = coreNumber
        }
    }
}

assert 4 == new Computer().new Cpu(4).coreNumber
```

Anonymous inner class

The last example of inner class can be simplified with an anonymous inner class. The same functionality can be achieved with the following code.

```groovy
class Outer3 {
    private String privateStr = 'some string'

    def startThread() {
        new Thread(new Runnable() {      
            void run() {
                println "${privateStr}."
            }
        }).start()                       
    }
}
```

|      | comparing with the last example of previous section, the `new Inner2()` was replaced by `new Runnable()` along with all its implementation |
| ---- | ------------------------------------------------------------ |
|      | the method `start` is invoked normally                       |

Thus, there was no need to define a new class to be used just once.

###### Abstract class

Abstract classes represent generic concepts, thus, they cannot be instantiated, being created to be subclassed. Their members include fields/properties and abstract or concrete methods. Abstract methods do not have implementation, and must be implemented by concrete subclasses.

```groovy
abstract class Abstract {         
    String name

    abstract def abstractMethod() 

    def concreteMethod() {
        println 'concrete'
    }
}
```

|      | abstract classes must be declared with `abstract` keyword    |
| ---- | ------------------------------------------------------------ |
|      | abstract methods must also be declared with `abstract` keyword |

Abstract classes are commonly compared to interfaces. But there are at least two important differences of choosing one or another. First, while abstract classes may contain fields/properties and concrete methods, interfaces may contain only abstract methods (method signatures). Moreover, one class can implement several interfaces, whereas it can extend just one class, abstract or not.

##### Interface

An interface defines a contract that a class needs to conform to. An interface only defines a list of methods that need to be implemented, but does not define the methods implementation.

```groovy
interface Greeter {                                         
    void greet(String name)                                 
}
```

|      | an interface needs to be declared using the `interface` keyword |
| ---- | ------------------------------------------------------------ |
|      | an interface only defines method signatures                  |

Methods of an interface are always **public**. It is an error to use `protected` or `private` methods in interfaces:

```groovy
interface Greeter {
    protected void greet(String name)           
}
```

|      | Using `protected` is a compile-time error |
| ---- | ----------------------------------------- |
|      |                                           |

A class *implements* an interface if it defines the interface in its `implements` list or if any of its superclasses does:

```groovy
class SystemGreeter implements Greeter {                    
    void greet(String name) {                               
        println "Hello $name"
    }
}

def greeter = new SystemGreeter()
assert greeter instanceof Greeter                           
```

|      | The `SystemGreeter` declares the `Greeter` interface using the `implements` keyword |
| ---- | ------------------------------------------------------------ |
|      | Then implements the required `greet` method                  |
|      | Any instance of `SystemGreeter` is also an instance of the `Greeter` interface |

An interface can extend another interface:

```groovy
interface ExtendedGreeter extends Greeter {                 
    void sayBye(String name)
}
```

|      | the `ExtendedGreeter` interface extends the `Greeter` interface using the `extends` keyword |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

It is worth noting that for a class to be an instance of an interface, it has to be explicit. For example, the following class defines the `greet` method as it is declared in the `Greeter` interface, but does not declare `Greeter` in its interfaces:

```groovy
class DefaultGreeter {
    void greet(String name) { println "Hello" }
}

greeter = new DefaultGreeter()
assert !(greeter instanceof Greeter)
```

In other words, Groovy does not define structural typing. It is however possible to make an instance of an object implement an interface at runtime, using the `as` coercion operator:

```groovy
greeter = new DefaultGreeter()                              
coerced = greeter as Greeter                                
assert coerced instanceof Greeter                           
```

|      | create an instance of `DefaultGreeter` that does not implement the interface |
| ---- | ------------------------------------------------------------ |
|      | coerce the instance into a `Greeter` at runtime              |
|      | the coerced instance implements the `Greeter` interface      |

You can see that there are two distinct objects: one is the source object, a `DefaultGreeter` instance, which does not implement the interface. The other is an instance of `Greeter` that delegates to the coerced object.

|      | Groovy interfaces do not support default implementation like Java 8 interfaces. If you are looking for something similar (but not equal), [traits](https://docs.groovy-lang.org/latest/html/documentation/#_traits) are close to interfaces, but allow default implementation as well as other important features described in this manual. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Constructors

Constructors are special methods used to initialize an object with a specific state. As with normal methods, it is possible for a class to declare more than one constructor, so long as each constructor has a unique type signature. If an object doesn’t require any parameters during construction, it may use a *no-arg* constructor. If no constructors are supplied, an empty no-arg constructor will be provided by the Groovy compiler.

Groovy supports two invocation styles:

- *positional parameters* are used in a similar to how you would use Java constructors
- *named parameters* allow you to specify parameter names when invoking the constructor.

###### Positional parameters

To create an object by using positional parameters, the respective class needs to declare one or more constructors. In the case of multiple constructors, each must have a unique type signature. The constructors can also added to the class using the [groovy.transform.TupleConstructor](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/TupleConstructor.html) annotation.

Typically, once at least one constructor is declared, the class can only be instantiated by having one of its constructors called. It is worth noting that, in this case, you can’t normally create the class with named parameters. Groovy does support named parameters so long as the class contains a no-arg constructor or provides a constructor which takes a `Map` argument as the first (and potentially only) argument - see the next section for details.

There are three forms of using a declared constructor. The first one is the normal Java way, with the `new` keyword. The others rely on coercion of lists into the desired types. In this case, it is possible to coerce with the `as` keyword and by statically typing the variable.

```groovy
class PersonConstructor {
    String name
    Integer age

    PersonConstructor(name, age) {          
        this.name = name
        this.age = age
    }
}

def person1 = new PersonConstructor('Marie', 1)  
def person2 = ['Marie', 2] as PersonConstructor  
PersonConstructor person3 = ['Marie', 3]         
```

|      | Constructor declaration                             |
| ---- | --------------------------------------------------- |
|      | Constructor invocation, classic Java way            |
|      | Constructor usage, using coercion with `as` keyword |
|      | Constructor usage, using coercion in assignment     |

###### Named parameters

If no (or a no-arg) constructor is declared, it is possible to create objects by passing parameters in the form of a map (property/value pairs). This can be in handy in cases where one wants to allow several combinations of parameters. Otherwise, by using traditional positional parameters it would be necessary to declare all possible constructors. Having a constructor where the first (and perhaps only) argument is a `Map` argument is also supported - such a constructor may also be added using the [groovy.transform.MapConstructor](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/MapConstructor.html) annotation.

```groovy
class PersonWOConstructor {                                  
    String name
    Integer age
}

def person4 = new PersonWOConstructor()                      
def person5 = new PersonWOConstructor(name: 'Marie')         
def person6 = new PersonWOConstructor(age: 1)                
def person7 = new PersonWOConstructor(name: 'Marie', age: 2) 
```

|      | No constructor declared                                |
| ---- | ------------------------------------------------------ |
|      | No parameters given in the instantiation               |
|      | `name` parameter given in the instantiation            |
|      | `age` parameter given in the instantiation             |
|      | `name` and `age` parameters given in the instantiation |

It is important to highlight, however, that this approach gives more power to the constructor caller, while imposing an increased responsibility on the caller to get the names and value types correct. Thus, if greater control is desired, declaring constructors using positional parameters might be preferred.

Notes:

- While the example above supplied no constructor, you can also supply a no-arg constructor or a constructor where the first argument is a `Map`, most typically it’s the only argument.
- When no (or a no-arg) constructor is declared, Groovy replaces the named constructor call by a call to the no-arg constructor followed by calls to the setter for each supplied named property.
- When the first argument is a Map, Groovy combines all named parameters into a Map (regardless of ordering) and supplies the map as the first parameter. This can be a good approach if your properties are declared as `final` (since they will be set in the constructor rather than after the fact with setters).
- You can support both named and positional construction by supply both positional constructors as well as a no-arg or Map constructor.
- You can support hybrid construction by having a constructor where the first argument is a Map but there are also additional positional parameters. Use this style with caution.

##### Methods

Groovy methods are quite similar to other languages. Some peculiarities will be shown in the next subsections.

###### Method definition

A method is defined with a return type or with the `def` keyword, to make the return type untyped. A method can also receive any number of arguments, which may not have their types explicitly declared. Java modifiers can be used normally, and if no visibility modifier is provided, the method is public.

Methods in Groovy always return some value. If no `return` statement is provided, the value evaluated in the last line executed will be returned. For instance, note that none of the following methods uses the `return` keyword.

```groovy
def someMethod() { 'method called' }                           
String anotherMethod() { 'another method called' }             
def thirdMethod(param1) { "$param1 passed" }                   
static String fourthMethod(String param1) { "$param1 passed" } 
```

|      | Method with no return type declared and no parameter |
| ---- | ---------------------------------------------------- |
|      | Method with explicit return type and no parameter    |
|      | Method with a parameter with no type defined         |
|      | Static method with a String parameter                |

###### Named parameters

Like constructors, normal methods can also be called with named parameters. To support this notation, a convention is used where the first argument to the method is a `Map`. In the method body, the parameter values can be accessed as in normal maps (`map.key`). If the method has just a single Map argument, all supplied parameters must be named.

```groovy
def foo(Map args) { "${args.name}: ${args.age}" }
foo(name: 'Marie', age: 1)
```

Mixing named and positional parameters

Named parameters can be mixed with positional parameters. The same convention applies, in this case, in addition to the `Map` argument as the first argument, the method in question will have additional positional arguments as needed. Supplied positional parameters when calling the method must be in order. The named parameters can be in any position. They are grouped into the map and supplied as the first parameter automatically.

```groovy
def foo(Map args, Integer number) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(name: 'Marie', age: 1, 23)  
foo(23, name: 'Marie', age: 1)  
```

|      | Method call with additional `number` argument of `Integer` type |
| ---- | ------------------------------------------------------------ |
|      | Method call with changed order of arguments                  |

If we don’t have the Map as the first argument, then a Map must be supplied for that argument instead of named parameters. Failure to do so will lead to `groovy.lang.MissingMethodException`:

```groovy
def foo(Integer number, Map args) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(name: 'Marie', age: 1, 23)  
```

|      | Method call throws `groovy.lang.MissingMethodException: No signature of method: foo() is applicable for argument types: (LinkedHashMap, Integer) values: [[name:Marie, age:1], 23]`, because the named argument `Map` parameter is not defined as the first argument |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Above exception can be avoided if we replace named arguments with an explicit `Map` argument:

```groovy
def foo(Integer number, Map args) { "${args.name}: ${args.age}, and the number is ${number}" }
foo(23, [name: 'Marie', age: 1])  
```

|      | Explicit `Map` argument in place of named arguments makes invocation valid |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

|      | Although Groovy allows you to mix named and positional parameters, it can lead to unnecessary confusion. Mix named and positional arguments with caution. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Default arguments

Default arguments make parameters optional. If the argument is not supplied, the method assumes a default value.

```groovy
def foo(String par1, Integer par2 = 1) { [name: par1, age: par2] }
assert foo('Marie').age == 1
```

Note that no mandatory parameter can be defined after a default parameter is present, only other default parameters.

###### Varargs

Groovy supports methods with a variable number of arguments. They are defined like this: `def foo(p1, …, pn, T… args)`. Here `foo` supports `n` arguments by default, but also an unspecified number of further arguments exceeding `n`.

```groovy
def foo(Object... args) { args.length }
assert foo() == 0
assert foo(1) == 1
assert foo(1, 2) == 2
```

This example defines a method `foo`, that can take any number of arguments, including no arguments at all. `args.length` will return the number of arguments given. Groovy allows `T[]` as a alternative notation to `T…`. That means any method with an array as last parameter is seen by Groovy as a method that can take a variable number of arguments.

```groovy
def foo(Object[] args) { args.length }
assert foo() == 0
assert foo(1) == 1
assert foo(1, 2) == 2
```

If a method with varargs is called with `null` as the vararg parameter, then the argument will be `null` and not an array of length one with `null` as the only element.

```groovy
def foo(Object... args) { args }
assert foo(null) == null
```

If a varargs method is called with an array as an argument, then the argument will be that array instead of an array of length one containing the given array as the only element.

```groovy
def foo(Object... args) { args }
Integer[] ints = [1, 2]
assert foo(ints) == [1, 2]
```

Another important point are varargs in combination with method overloading. In case of method overloading Groovy will select the most specific method. For example if a method `foo` takes a varargs argument of type `T` and another method `foo` also takes one argument of type `T`, the second method is preferred.

```groovy
def foo(Object... args) { 1 }
def foo(Object x) { 2 }
assert foo() == 1
assert foo(1) == 2
assert foo(1, 2) == 1
```

###### Method selection algorithm

(TBD)

###### Exception declaration

Groovy automatically allows you to treat checked exceptions like unchecked exceptions. This means that you don’t need to declare any checked exceptions that a method may throw as shown in the following example which can throw a `FileNotFoundException` if the file isn’t found:

```groovy
def badRead() {
    new File('doesNotExist.txt').text
}

shouldFail(FileNotFoundException) {
    badRead()
}
```

Nor will you be required to surround the call to the `badRead` method in the previous example within a try/catch block - though you are free to do so if you wish.

If you wish to declare any exceptions that your code might throw (checked or otherwise) you are free to do so. Adding exceptions won’t change how the code is used from any other Groovy code but can be seen as documentation for the human reader of your code. The exceptions will become part of the method declaration in the bytecode, so if your code might be called from Java, it might be useful to include them. Using an explicit checked exception declaration is illustrated in the following example:

```groovy
def badRead() throws FileNotFoundException {
    new File('doesNotExist.txt').text
}

shouldFail(FileNotFoundException) {
    badRead()
}
```

##### Fields and properties

###### Fields

A field is a member of a class or a trait which has:

- a mandatory *access modifier* (`public`, `protected`, or `private`)
- one or more optional *modifiers* (`static`, `final`, `synchronized`)
- an optional *type*
- a mandatory *name*

```groovy
class Data {
    private int id                                  
    protected String description                    
    public static final boolean DEBUG = false       
}
```

|      | a `private` field named `id`, of type `int`                  |
| ---- | ------------------------------------------------------------ |
|      | a `protected` field named `description`, of type `String`    |
|      | a `public static final` field named *DEBUG* of type `boolean` |

A field may be initialized directly at declaration:

```groovy
class Data {
    private String id = IDGenerator.next() 
    // ...
}
```

|      | the private field `id` is initialized with `IDGenerator.next()` |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

It is possible to omit the type declaration of a field. This is however considered a bad practice and in general it is a good idea to use strong typing for fields:

```groovy
class BadPractice {
    private mapping                         
}
class GoodPractice {
    private Map<String,String> mapping      
}
```

|      | the field `mapping` doesn’t declare a type |
| ---- | ------------------------------------------ |
|      | the field `mapping` has a strong type      |

The difference between the two is important if you want to use optional type checking later. It is also important for documentation. However in some cases like scripting or if you want to rely on duck typing it may be interesting to omit the type.

###### Properties

A property is an externally visible feature of a class. Rather than just using a public field to represent such features (which provides a more limited abstraction and would restrict refactoring possibilities), the typical convention in Java is to follow JavaBean conventions, i.e. represent the property using a combination of a private backing field and getters/setters. Groovy follows these same conventions but provides a simpler approach to defining the property. You can define a property with:

- an **absent** access modifier (no `public`, `protected` or `private`)
- one or more optional *modifiers* (`static`, `final`, `synchronized`)
- an optional *type*
- a mandatory *name*

Groovy will then generate the getters/setters appropriately. For example:

```groovy
class Person {
    String name                             
    int age                                 
}
```

|      | creates a backing `private String name` field, a `getName` and a `setName` method |
| ---- | ------------------------------------------------------------ |
|      | creates a backing `private int age` field, a `getAge` and a `setAge` method |

If a property is declared `final`, no setter is generated:

```groovy
class Person {
    final String name                   
    final int age                       
    Person(String name, int age) {
        this.name = name                
        this.age = age                  
    }
}
```

|      | defines a read-only property of type `String`    |
| ---- | ------------------------------------------------ |
|      | defines a read-only property of type `int`       |
|      | assigns the `name` parameter to the `name` field |
|      | assigns the `age` parameter to the `age` field   |

Properties are accessed by name and will call the getter or setter transparently, unless the code is in the class which defines the property:

```groovy
class Person {
    String name
    void name(String name) {
        this.name = "Wonder$name"       
    }
    String wonder() {
        this.name                       
    }
}
def p = new Person()
p.name = 'Marge'                        
assert p.name == 'Marge'                
p.name('Marge')                         
assert p.wonder() == 'WonderMarge'      
```

|      | `this.name` will directly access the field because the property is accessed from within the class that defines it |
| ---- | ------------------------------------------------------------ |
|      | similarily a read access is done directly on the `name` field |
|      | write access to the property is done outside of the `Person` class so it will implicitly call `setName` |
|      | read access to the property is done outside of the `Person` class so it will implicitly call `getName` |
|      | this will call the `name` method on `Person` which performs a direct access to the field |
|      | this will call the `wonder` method on `Person` which performs a direct read access to the field |

It is worth noting that this behavior of accessing the backing field directly is done in order to prevent a stack overflow when using the property access syntax within a class that defines the property.

It is possible to list the properties of a class thanks to the meta `properties` field of an instance:

```groovy
class Person {
    String name
    int age
}
def p = new Person()
assert p.properties.keySet().containsAll(['name','age'])
```

By convention, Groovy will recognize properties even if there is no backing field provided there are getters or setters that follow the Java Beans specification. For example:

```groovy
class PseudoProperties {
    // a pseudo property "name"
    void setName(String name) {}
    String getName() {}

    // a pseudo read-only property "age"
    int getAge() { 42 }

    // a pseudo write-only property "groovy"
    void setGroovy(boolean groovy) {  }
}
def p = new PseudoProperties()
p.name = 'Foo'                      
assert p.age == 42                  
p.groovy = true                     
```

|      | writing `p.name` is allowed because there is a pseudo-property `name` |
| ---- | ------------------------------------------------------------ |
|      | reading `p.age` is allowed because there is a pseudo-readonly property `age` |
|      | writing `p.groovy` is allowed because there is a pseudo-writeonly property `groovy` |

This syntactic sugar is at the core of many DSLs written in Groovy.

##### Annotation

###### Annotation definition

An annotation is a kind of special interface dedicated at annotating elements of the code. An annotation is a type which superinterface is the [Annotation](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Annotation.html) interface. Annotations are declared in a very similar way to interfaces, using the `@interface` keyword:

```groovy
@interface SomeAnnotation {}
```

An annotation may define members in the form of methods without bodies and an optional default value. The possible member types are limited to:

- primitive types
- [Strings](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/String.html)
- [Classes](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Class.html)
- an [enumeration](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Enum.html)
- another [annotation type](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Annotation.html)
- or any array of the above

For example:

```groovy
@interface SomeAnnotation {
    String value()                          
}
@interface SomeAnnotation {
    String value() default 'something'      
}
@interface SomeAnnotation {
    int step()                              
}
@interface SomeAnnotation {
    Class appliesTo()                       
}
@interface SomeAnnotation {}
@interface SomeAnnotations {
    SomeAnnotation[] value()                
}
enum DayOfWeek { mon, tue, wed, thu, fri, sat, sun }
@interface Scheduled {
    DayOfWeek dayOfWeek()                   
}
```

|      | an annotation defining a `value` member of type `String`     |
| ---- | ------------------------------------------------------------ |
|      | an annotation defining a `value` member of type `String` with a default value of `something` |
|      | an annotation defining a `step` member of type the primitive type `int` |
|      | an annotation defining a `appliesTo` member of type `Class`  |
|      | an annotation defining a `value` member which type is an array of another annotation type |
|      | an annotation defining a `dayOfWeek` member which type is the enumeration type `DayOfWeek` |

Unlike in the Java language, in Groovy, an annotation can be used to alter the semantics of the language. It is especially true of AST transformations which will generate code based on annotations.

###### Annotation placement

An annotation can be applied on various elements of the code:

```groovy
@SomeAnnotation                 
void someMethod() {
    // ...
}

@SomeAnnotation                 
class SomeClass {}

@SomeAnnotation String var      
```

|      | `@SomeAnnotation` applies to the `someMethod` method |
| ---- | ---------------------------------------------------- |
|      | `@SomeAnnotation` applies to the `SomeClass` class   |
|      | `@SomeAnnotation` applies to the `var` variable      |

In order to limit the scope where an annotation can be applied, it is necessary to declare it on the annotation definition, using the [Target](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Target.html) annotation. For example, here is how you would declare that an annotation can be applied to a class or a method:

```groovy
import java.lang.annotation.ElementType
import java.lang.annotation.Target

@Target([ElementType.METHOD, ElementType.TYPE])     
@interface SomeAnnotation {}                        
```

|      | the `@Target` annotation is meant to annotate an annotation with a scope. |
| ---- | ------------------------------------------------------------ |
|      | `@SomeAnnotation` will therefore only be allowed on `TYPE` or `METHOD` |

The list of possible targets is available in the [ElementType enumeration](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html).

|      | Groovy does not support the [TYPE_PARAMETER](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html#TYPE_PARAMETER) and [TYPE_USE](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/ElementType.html#TYPE_PARAMETER) element types which were introduced in Java 8. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Annotation member values

When an annotation is used, it is required to set at least all members that do not have a default value. For example:

```groovy
@interface Page {
    int statusCode()
}

@Page(statusCode=404)
void notFound() {
    // ...
}
```

However it is possible to omit `value=` in the declaration of the value of an annotation if the member `value` is the only one being set:

```groovy
@interface Page {
    String value()
    int statusCode() default 200
}

@Page(value='/home')                    
void home() {
    // ...
}

@Page('/users')                         
void userList() {
    // ...
}

@Page(value='error',statusCode=404)     
void notFound() {
    // ...
}
```

|      | we can omit the `statusCode` because it has a default value, but `value` needs to be set |
| ---- | ------------------------------------------------------------ |
|      | since `value` is the only mandatory member without a default, we can omit `value=` |
|      | if both `value` and `statusCode` need to be set, it is required to use `value=` for the default `value` member |

###### Retention policy

The visibility of an annotation depends on its retention policy. The retention policy of an annotation is set using the [Retention](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/Retention.html) annotation:

```groovy
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy

@Retention(RetentionPolicy.SOURCE)                   
@interface SomeAnnotation {}                         
```

|      | the `@Retention` annotation annotates the `@SomeAnnotation` annotation |
| ---- | ------------------------------------------------------------ |
|      | so `@SomeAnnotation` will have a `SOURCE` retention          |

The list of possible retention targets and description is available in the [RetentionPolicy](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/RetentionPolicy.html) enumeration. The choice usually depends on whether you want an annotation to be visible at compile time or runtime.

###### Closure annotation parameters

An interesting feature of annotations in Groovy is that you can use a closure as an annotation value. Therefore annotations may be used with a wide variety of expressions and still have IDE support. For example, imagine a framework where you want to execute some methods based on environmental constraints like the JDK version or the OS. One could write the following code:

```groovy
class Tasks {
    Set result = []
    void alwaysExecuted() {
        result << 1
    }
    @OnlyIf({ jdk>=6 })
    void supportedOnlyInJDK6() {
        result << 'JDK 6'
    }
    @OnlyIf({ jdk>=7 && windows })
    void requiresJDK7AndWindows() {
        result << 'JDK 7 Windows'
    }
}
```

For the `@OnlyIf` annotation to accept a `Closure` as an argument, you only have to declare the `value` as a `Class`:

```groovy
@Retention(RetentionPolicy.RUNTIME)
@interface OnlyIf {
    Class value()                    
}
```

To complete the example, let’s write a sample runner that would use that information:

```groovy
class Runner {
    static <T> T run(Class<T> taskClass) {
        def tasks = taskClass.newInstance()                                         
        def params = [jdk:6, windows: false]                                        
        tasks.class.declaredMethods.each { m ->                                     
            if (Modifier.isPublic(m.modifiers) && m.parameterTypes.length == 0) {   
                def onlyIf = m.getAnnotation(OnlyIf)                                
                if (onlyIf) {
                    Closure cl = onlyIf.value().newInstance(tasks,tasks)            
                    cl.delegate = params                                            
                    if (cl()) {                                                     
                        m.invoke(tasks)                                             
                    }
                } else {
                    m.invoke(tasks)                                                 
                }
            }
        }
        tasks                                                                       
    }
}
```

|      | create a new instance of the class passed as an argument (the task class) |
| ---- | ------------------------------------------------------------ |
|      | emulate an environment which is JDK 6 and not Windows        |
|      | iterate on all declared methods of the task class            |
|      | if the method is public and takes no-argument                |
|      | try to find the `@OnlyIf` annotation                         |
|      | if it is found get the `value` and create a new `Closure` out of it |
|      | set the `delegate` of the closure to our environment variable |
|      | call the closure, which is the annotation closure. It will return a `boolean` |
|      | if it is `true`, call the method                             |
|      | if the method is not annotated with `@OnlyIf`, execute the method anyway |
|      | after that, return the task object                           |

Then the runner can be used this way:

```groovy
def tasks = Runner.run(Tasks)
assert tasks.result == [1, 'JDK 6'] as Set
```

###### Meta-annotations

Declaring meta-annotations

Meta-annotations, also known as annotation aliases are annotations that are replaced at compile time by other annotations (one meta-annotation is an alias for one or more annotations). Meta-annotations can be used to reduce the size of code involving multiple annotations.

Let’s start with a simple example. Imagine you have the `@Service` and `@Transactional` annotations and that you want to annotate a class with both:

```groovy
@Service
@Transactional
class MyTransactionalService {}
```

Given the multiplication of annotations that you could add to the same class, a meta-annotation could help by reducing the two annotations with a single one having the very same semantics. For example, we might want to write this instead:

```groovy
@TransactionalService                           
class MyTransactionalService {}
```

|      | `@TransactionalService` is a meta-annotation |
| ---- | -------------------------------------------- |
|      |                                              |

A meta-annotation is declared as a regular annotation but annotated with `@AnnotationCollector` and the list of annotations it is collecting. In our case, the `@TransactionalService` annotation can be written:

```groovy
import groovy.transform.AnnotationCollector

@Service                                        
@Transactional                                  
@AnnotationCollector                            
@interface TransactionalService {
}
```

|      | annotate the meta-annotation with `@Service`             |
| ---- | -------------------------------------------------------- |
|      | annotate the meta-annotation with `@Transactional`       |
|      | annotate the meta-annotation with `@AnnotationCollector` |

Behavior of meta-annotations

Groovy supports both *precompiled* and *source form* meta-annotations. This means that your meta-annotation *may* be precompiled, or you can have it in the same source tree as the one you are currently compiling.

INFO: Meta-annotations are a Groovy-only feature. There is no chance for you to annotate a Java class with a meta-annotation and hope it will do the same as in Groovy. Likewise, you cannot write a meta-annotation in Java: both the meta-annotation definition **and** usage have to be Groovy code. But you can happily collect Java annotations and Groovy annotations within your meta-annotation.

When the Groovy compiler encounters a class annotated with a meta-annotation, it **replaces** it with the collected annotations. So, in our previous example, it will replace `@TransactionalService` with `@Transactional` and `@Service`:

```groovy
def annotations = MyTransactionalService.annotations*.annotationType()
assert (Service in annotations)
assert (Transactional in annotations)
```

The conversion from a meta-annotation to the collected annotations is performed during the *semantic analysis* compilation phase. 

In addition to replacing the alias with the collected annotations, a meta-annotation is capable of processing them, including arguments.

Meta-annotation parameters

Meta-annotations can collect annotations which have parameters. To illustrate this, we will imagine two annotations, each of them accepting one argument:

```groovy
@Timeout(after=3600)
@Dangerous(type='explosive')
```

And suppose that you want create a meta-annotation named `@Explosive`:

```groovy
@Timeout(after=3600)
@Dangerous(type='explosive')
@AnnotationCollector
public @interface Explosive {}
```

By default, when the annotations are replaced, they will get the annotation parameter values **as they were defined in the alias**. More interesting, the meta-annotation supports overriding specific values:

```groovy
@Explosive(after=0)                 
class Bomb {}
```

|      | the `after` value provided as a parameter to `@Explosive` overrides the one defined in the `@Timeout` annotation |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

If two annotations define the same parameter name, the default processor will copy the annotation value to all annotations that accept this parameter:

```groovy
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
   String value()                                   
}
@Retention(RetentionPolicy.RUNTIME)
public @interface Bar {
    String value()                                  
}

@Foo
@Bar
@AnnotationCollector
public @interface FooBar {}                         

@Foo('a')
@Bar('b')
class Bob {}                                        

assert Bob.getAnnotation(Foo).value() == 'a'        
println Bob.getAnnotation(Bar).value() == 'b'       

@FooBar('a')
class Joe {}                                        
assert Joe.getAnnotation(Foo).value() == 'a'        
println Joe.getAnnotation(Bar).value() == 'a'       
```

|      | the `@Foo` annotation defines the `value` member of type `String` |
| ---- | ------------------------------------------------------------ |
|      | the `@Bar` annotation also defines the `value` member of type `String` |
|      | the `@FooBar` meta-annotation aggregates `@Foo` and `@Bar`   |
|      | class `Bob` is annotated with `@Foo` and `@Bar`              |
|      | the value of the `@Foo` annotation on `Bob` is `a`           |
|      | while the value of the `@Bar` annotation on `Bob` is `b`     |
|      | class `Joe` is annotated with `@FooBar`                      |
|      | then the value of the `@Foo` annotation on `Joe` is `a`      |
|      | and the value of the `@Bar` annotation on `Joe` is also `a`  |

In the second case, the meta-annotation value was copied in both `@Foo` and `@Bar` annotations.

|      | It is a compile time error if the collected annotations define the same members with incompatible types. For example if on the previous example `@Foo` defined a value of type `String` but `@Bar` defined a value of type `int`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

It is however possible to customize the behavior of meta-annotations and describe how collected annotations are expanded. We’ll look at how to do that shortly but first there is an advanced processing option to cover.

Handling duplicate annotations

The `@AnnotationCollector` annotation supports a `mode` parameter which can be used to alter how the default processor handles annotation replacement in the presence of duplicate annotations.

INFO: Custom processors (discussed next) may or may not support this parameter.

As an example, suppose you create a meta-annotation containing the `@ToString` annotation and then place your meta-annotation on a class that already has an explicit `@ToString` annotation. Should this be an error? Should both annotations be applied? Does one take priority over the other? There is no correct answer. In some scenarios it might be quite appropriate for any of these answers to be correct. So, rather than trying to preempt one correct way to handle the duplicate annotation issue, Groovy let’s you write your own custom meta-annotation processors (covered next) and let’s you write whatever checking logic you like within AST transforms - which are a frequent target for aggregating. Having said that, by simply setting the `mode`, a number of commonly expected scenarios are handled automatically for you within any extra coding. The behavior of the `mode` parameter is determined by the `AnnotationCollectorMode` enum value chosen and is summarized in the following table.

| Mode                    | Description                                                  |
| ----------------------- | ------------------------------------------------------------ |
| DUPLICATE               | Annotations from the annotation collection will always be inserted. After all transforms have been run, it will be an error if multiple annotations (excluding those with SOURCE retention) exist. |
| PREFER_COLLECTOR        | Annotations from the collector will be added and any existing annotations with the same name will be removed. |
| PREFER_COLLECTOR_MERGED | Annotations from the collector will be added and any existing annotations with the same name will be removed but any new parameters found within existing annotations will be merged into the added annotation. |
| PREFER_EXPLICIT         | Annotations from the collector will be ignored if any existing annotations with the same name are found. |
| PREFER_EXPLICIT_MERGED  | Annotations from the collector will be ignored if any existing annotations with the same name are found but any new parameters on the collector annotation will be added to existing annotations. |

Custom annotation processors

A custom annotation processor will let you choose how to expand a meta-annotation into collected annotations. The behaviour of the meta-annotation is, in this case, totally up to you. To do this, you must:

- create a meta-annotation processor, extending [AnnotationCollectorTransform](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/AnnotationCollectorTransform.html)
- declare the processor to be used in the meta-annotation declaration

To illustrate this, we are going to explore how the meta-annotation `@CompileDynamic` is implemented.

`@CompileDynamic` is a meta-annotation that expands itself to `@CompileStatic(TypeCheckingMode.SKIP)`. The problem is that the default meta annotation processor doesn’t support enums and the annotation value `TypeCheckingMode.SKIP` is one.

The naive implementation here would not work:

```groovy
@CompileStatic(TypeCheckingMode.SKIP)
@AnnotationCollector
public @interface CompileDynamic {}
```

Instead, we will define it like this:

```groovy
@AnnotationCollector(processor = "org.codehaus.groovy.transform.CompileDynamicProcessor")
public @interface CompileDynamic {
}
```

The first thing you may notice is that our interface is no longer annotated with `@CompileStatic`. The reason for this is that we rely on the `processor` parameter instead, that references a class which will **generate** the annotation.

Here is how the custom processor is implemented:

CompileDynamicProcessor.groovy

```groovy
@CompileStatic                                                                  
class CompileDynamicProcessor extends AnnotationCollectorTransform {            
    private static final ClassNode CS_NODE = ClassHelper.make(CompileStatic)    
    private static final ClassNode TC_NODE = ClassHelper.make(TypeCheckingMode) 

    List<AnnotationNode> visit(AnnotationNode collector,                        
                               AnnotationNode aliasAnnotationUsage,             
                               AnnotatedNode aliasAnnotated,                    
                               SourceUnit source) {                             
        def node = new AnnotationNode(CS_NODE)                                  
        def enumRef = new PropertyExpression(
            new ClassExpression(TC_NODE), "SKIP")                               
        node.addMember("value", enumRef)                                        
        Collections.singletonList(node)                                         
    }
}
```

|      | our custom processor is written in Groovy, and for better compilation performance, we use static compilation |
| ---- | ------------------------------------------------------------ |
|      | the custom processor has to extend [AnnotationCollectorTransform](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/AnnotationCollectorTransform.html) |
|      | create a class node representing the `@CompileStatic` annotation type |
|      | create a class node representing the `TypeCheckingMode` enum type |
|      | `collector` is the `@AnnotationCollector` node found in the meta-annotation. Usually unused. |
|      | `aliasAnnotationUsage` is the meta-annotation being expanded, here it is `@CompileDynamic` |
|      | `aliasAnnotated` is the node being annotated with the meta-annotation |
|      | `sourceUnit` is the `SourceUnit` being compiled              |
|      | we create a new annotation node for `@CompileStatic`         |
|      | we create an expression equivalent to `TypeCheckingMode.SKIP` |
|      | we add that expression to the annotation node, which is now `@CompileStatic(TypeCheckingMode.SKIP)` |
|      | return the generated annotation                              |

In the example, the `visit` method is the only method which has to be overridden. It is meant to return a list of annotation nodes that will be added to the node annotated with the meta-annotation. In this example, we return a single one corresponding to `@CompileStatic(TypeCheckingMode.SKIP)`.

##### Inheritance

(TBD)

##### Generics

(TBD)

#### 1.4.2. Traits

Traits are a structural construct of the language which allows:

- composition of behaviors
- runtime implementation of interfaces
- behavior overriding
- compatibility with static type checking/compilation

They can be seen as **interfaces** carrying both **default implementations** and **state**. A trait is defined using the `trait` keyword:

```groovy
trait FlyingAbility {                           
        String fly() { "I'm flying!" }          
}
```

|      | declaration of a trait                 |
| ---- | -------------------------------------- |
|      | declaration of a method inside a trait |

Then it can be used like a normal interface using the `implements` keyword:

```groovy
class Bird implements FlyingAbility {}          
def b = new Bird()                              
assert b.fly() == "I'm flying!"                 
```

|      | Adds the trait `FlyingAbility` to the `Bird` class capabilities |
| ---- | ------------------------------------------------------------ |
|      | instantiate a new `Bird`                                     |
|      | the `Bird` class automatically gets the behavior of the `FlyingAbility` trait |

Traits allow a wide range of capabilities, from simple composition to testing, which are described thoroughly in this section.

##### Methods

###### Public methods

Declaring a method in a trait can be done like any regular method in a class:

```groovy
trait FlyingAbility {                           
        String fly() { "I'm flying!" }          
}
```

|      | declaration of a trait                 |
| ---- | -------------------------------------- |
|      | declaration of a method inside a trait |

###### Abstract methods

In addition, traits may declare *abstract* methods too, which therefore need to be implemented in the class implementing the trait:

```groovy
trait Greetable {
    abstract String name()                              
    String greeting() { "Hello, ${name()}!" }           
}
```

|      | implementing class will have to declare the `name` method |
| ---- | --------------------------------------------------------- |
|      | can be mixed with a concrete method                       |

Then the trait can be used like this:

```groovy
class Person implements Greetable {                     
    String name() { 'Bob' }                             
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    
```

|      | implement the trait `Greetable`                           |
| ---- | --------------------------------------------------------- |
|      | since `name` was abstract, it is required to implement it |
|      | then `greeting` can be called                             |

###### Private methods

Traits may also define private methods. Those methods will not appear in the trait contract interface:

```groovy
trait Greeter {
    private String greetingMessage() {                      
        'Hello from a private method!'
    }
    String greet() {
        def m = greetingMessage()                           
        println m
        m
    }
}
class GreetingMachine implements Greeter {}                 
def g = new GreetingMachine()
assert g.greet() == "Hello from a private method!"          
try {
    assert g.greetingMessage()                              
} catch (MissingMethodException e) {
    println "greetingMessage is private in trait"
}
```

|      | define a private method `greetingMessage` in the trait       |
| ---- | ------------------------------------------------------------ |
|      | the public `greet` message calls `greetingMessage` by default |
|      | create a class implementing the trait                        |
|      | `greet` can be called                                        |
|      | but not `greetingMessage`                                    |

|      | Traits only support `public` and `private` methods. Neither `protected` nor `package private` scopes are supported. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Final methods

If we have a class implementing a trait, conceptually implementations from the trait methods are "inherited" into the class. But, in reality, there is no base class containing such implementations. Rather, they are woven directly into the class. A final modifier on a method just indicates what the modifier will be for the woven method. While it would likely be considered bad style to inherit and override or multiply inherit methods with the same signature but a mix of final and non-final variants, Groovy doesn’t prohibit this scenario. Normal method selection applies and the modifier used will be determined from the resulting method. You might consider creating a base class which implements the desired trait(s) if you want trait implementation methods that can’t be overridden.

##### The meaning of this

`this` represents the implementing instance. Think of a trait as a superclass. This means that when you write:

```groovy
trait Introspector {
    def whoAmI() { this }
}
class Foo implements Introspector {}
def foo = new Foo()
```

then calling:

```groovy
foo.whoAmI()
```

will return the same instance:

```groovy
assert foo.whoAmI().is(foo)
```

##### Interfaces

Traits may implement interfaces, in which case the interfaces are declared using the `implements` keyword:

```groovy
interface Named {                                       
    String name()
}
trait Greetable implements Named {                      
    String greeting() { "Hello, ${name()}!" }
}
class Person implements Greetable {                     
    String name() { 'Bob' }                             
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    
assert p instanceof Named                               
assert p instanceof Greetable                           
```

|      | declaration of a normal interface                     |
| ---- | ----------------------------------------------------- |
|      | add `Named` to the list of implemented interfaces     |
|      | declare a class that implements the `Greetable` trait |
|      | implement the missing `name` method                   |
|      | the `greeting` implementation comes from the trait    |
|      | make sure `Person` implements the `Named` interface   |
|      | make sure `Person` implements the `Greetable` trait   |

##### Properties

A trait may define properties, like in the following example:

```groovy
trait Named {
    String name                             
}
class Person implements Named {}            
def p = new Person(name: 'Bob')             
assert p.name == 'Bob'                      
assert p.getName() == 'Bob'                 
```

|      | declare a property `name` inside a trait               |
| ---- | ------------------------------------------------------ |
|      | declare a class which implements the trait             |
|      | the property is automatically made visible             |
|      | it can be accessed using the regular property accessor |
|      | or using the regular getter syntax                     |

##### Fields

###### Private fields

Since traits allow the use of private methods, it can also be interesting to use private fields to store state. Traits will let you do that:

```groovy
trait Counter {
    private int count = 0                   
    int count() { count += 1; count }       
}
class Foo implements Counter {}             
def f = new Foo()
assert f.count() == 1                       
assert f.count() == 2
```

|      | declare a private field `count` inside a trait               |
| ---- | ------------------------------------------------------------ |
|      | declare a public method `count` that increments the counter and returns it |
|      | declare a class that implements the `Counter` trait          |
|      | the `count` method can use the private field to keep state   |

|      | This is a major difference with [Java 8 virtual extension methods](http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html). While virtual extension methods do not carry state, traits can. Moreover, traits in Groovy are supported starting with Java 6, because their implementation does not rely on virtual extension methods. This means that even if a trait can be seen from a Java class as a regular interface, that interface will **not** have default methods, only abstract ones. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Public fields

Public fields work the same way as private fields, but in order to avoid the [diamond problem](http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem), field names are remapped in the implementing class:

```groovy
trait Named {
    public String name                      
}
class Person implements Named {}            
def p = new Person()                        
p.Named__name = 'Bob'                       
```

|      | declare a public **field** inside the trait |
| ---- | ------------------------------------------- |
|      | declare a class implementing the trait      |
|      | create an instance of that class            |
|      | the public field is available, but renamed  |

The name of the field depends on the fully qualified name of the trait. All dots (`.`) in package are replaced with an underscore (`_`), and the final name includes a double underscore. So if the type of the field is `String`, the name of the package is `my.package`, the name of the trait is `Foo` and the name of the field is `bar`, in the implementing class, the public field will appear as:

```groovy
String my_package_Foo__bar
```

|      | While traits support public fields, it is not recommended to use them and considered as a bad practice. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Composition of behaviors

Traits can be used to implement multiple inheritance in a controlled way. For example, we can have the following traits:

```groovy
trait FlyingAbility {                           
        String fly() { "I'm flying!" }          
}
trait SpeakingAbility {
    String speak() { "I'm speaking!" }
}
```

And a class implementing both traits:

```groovy
class Duck implements FlyingAbility, SpeakingAbility {} 

def d = new Duck()                                      
assert d.fly() == "I'm flying!"                         
assert d.speak() == "I'm speaking!"                     
```

|      | the `Duck` class implements both `FlyingAbility` and `SpeakingAbility` |
| ---- | ------------------------------------------------------------ |
|      | creates a new instance of `Duck`                             |
|      | we can call the method `fly` from `FlyingAbility`            |
|      | but also the method `speak` from `SpeakingAbility`           |

Traits encourage the reuse of capabilities among objects, and the creation of new classes by the composition of existing behavior.

##### Overriding default methods

Traits provide default implementations for methods, but it is possible to override them in the implementing class. For example, we can slightly change the example above, by having a duck which quacks:

```groovy
class Duck implements FlyingAbility, SpeakingAbility {
    String quack() { "Quack!" }                         
    String speak() { quack() }                          
}

def d = new Duck()
assert d.fly() == "I'm flying!"                         
assert d.quack() == "Quack!"                            
assert d.speak() == "Quack!"                            
```

|      | define a method specific to `Duck`, named `quack`            |
| ---- | ------------------------------------------------------------ |
|      | override the default implementation of `speak` so that we use `quack` instead |
|      | the duck is still flying, from the default implementation    |
|      | `quack` comes from the `Duck` class                          |
|      | `speak` no longer uses the default implementation from `SpeakingAbility` |

##### Extending traits

###### Simple inheritance

Traits may extend another trait, in which case you must use the `extends` keyword:

```groovy
trait Named {
    String name                                     
}
trait Polite extends Named {                        
    String introduce() { "Hello, I am $name" }      
}
class Person implements Polite {}
def p = new Person(name: 'Alice')                   
assert p.introduce() == 'Hello, I am Alice'         
```

|      | the `Named` trait defines a single `name` property           |
| ---- | ------------------------------------------------------------ |
|      | the `Polite` trait **extends** the `Named` trait             |
|      | `Polite` adds a new method which has access to the `name` property of the super-trait |
|      | the `name` property is visible from the `Person` class implementing `Polite` |
|      | as is the `introduce` method                                 |

###### Multiple inheritance

Alternatively, a trait may extend multiple traits. In that case, all super traits must be declared in the `implements` clause:

```groovy
trait WithId {                                      
    Long id
}
trait WithName {                                    
    String name
}
trait Identified implements WithId, WithName {}     
```

|      | `WithId` trait defines the `id` property                     |
| ---- | ------------------------------------------------------------ |
|      | `WithName` trait defines the `name` property                 |
|      | `Identified` is a trait which inherits both `WithId` and `WithName` |

##### Duck typing and traits

###### Dynamic code

Traits can call any dynamic code, like a normal Groovy class. This means that you can, in the body of a method, call methods which are supposed to exist in an implementing class, without having to explicitly declare them in an interface. This means that traits are fully compatible with duck typing:

```groovy
trait SpeakingDuck {
    String speak() { quack() }                      
}
class Duck implements SpeakingDuck {
    String methodMissing(String name, args) {
        "${name.capitalize()}!"                     
    }
}
def d = new Duck()
assert d.speak() == 'Quack!'                        
```

|      | the `SpeakingDuck` expects the `quack` method to be defined  |
| ---- | ------------------------------------------------------------ |
|      | the `Duck` class does implement the method using *methodMissing* |
|      | calling the `speak` method triggers a call to `quack` which is handled by `methodMissing` |

###### Dynamic methods in a trait

It is also possible for a trait to implement MOP methods like `methodMissing` or `propertyMissing`, in which case implementing classes will inherit the behavior from the trait, like in this example:

```groovy
trait DynamicObject {                               
    private Map props = [:]
    def methodMissing(String name, args) {
        name.toUpperCase()
    }
    def propertyMissing(String prop) {
        props[prop]
    }
    void setProperty(String prop, Object value) {
        props[prop] = value
    }
}

class Dynamic implements DynamicObject {
    String existingProperty = 'ok'                  
    String existingMethod() { 'ok' }                
}
def d = new Dynamic()
assert d.existingProperty == 'ok'                   
assert d.foo == null                                
d.foo = 'bar'                                       
assert d.foo == 'bar'                               
assert d.existingMethod() == 'ok'                   
assert d.someMethod() == 'SOMEMETHOD'               
```

|      | create a trait implementing several MOP methods              |
| ---- | ------------------------------------------------------------ |
|      | the `Dynamic` class defines a property                       |
|      | the `Dynamic` class defines a method                         |
|      | calling an existing property will call the method from `Dynamic` |
|      | calling an non-existing property will call the method from the trait |
|      | will call `setProperty` defined on the trait                 |
|      | will call `getProperty` defined on the trait                 |
|      | calling an existing method on `Dynamic`                      |
|      | but calling a non existing method thanks to the trait `methodMissing` |

##### Multiple inheritance conflicts

###### Default conflict resolution

It is possible for a class to implement multiple traits. If some trait defines a method with the same signature as a method in another trait, we have a conflict:

```groovy
trait A {
    String exec() { 'A' }               
}
trait B {
    String exec() { 'B' }               
}
class C implements A,B {}               
```

|      | trait `A` defines a method named `exec` returning a `String` |
| ---- | ------------------------------------------------------------ |
|      | trait `B` defines the very same method                       |
|      | class `C` implements both traits                             |

In this case, the default behavior is that the method from the **last declared trait** in the `implements` clause wins. Here, `B` is declared after `A` so the method from `B` will be picked up:

```groovy
def c = new C()
assert c.exec() == 'B'
```

###### User conflict resolution

In case this behavior is not the one you want, you can explicitly choose which method to call using the `Trait.super.foo` syntax. In the example above, we can ensure the method from trait A is invoked by writing this:

```groovy
class C implements A,B {
    String exec() { A.super.exec() }    
}
def c = new C()
assert c.exec() == 'A'                  
```

|      | explicit call of `exec` from the trait `A`                   |
| ---- | ------------------------------------------------------------ |
|      | calls the version from `A` instead of using the default resolution, which would be the one from `B` |

##### Runtime implementation of traits

###### Implementing a trait at runtime

Groovy also supports implementing traits dynamically at runtime. It allows you to "decorate" an existing object using a trait. As an example, let’s start with this trait and the following class:

```groovy
trait Extra {
    String extra() { "I'm an extra method" }            
}
class Something {                                       
    String doSomething() { 'Something' }                
}
```

|      | the `Extra` trait defines an `extra` method                  |
| ---- | ------------------------------------------------------------ |
|      | the `Something` class does **not** implement the `Extra` trait |
|      | `Something` only defines a method `doSomething`              |

Then if we do:

```groovy
def s = new Something()
s.extra()
```

the call to extra would fail because `Something` is not implementing `Extra`. It is possible to do it at runtime with the following syntax:

```groovy
def s = new Something() as Extra                        
s.extra()                                               
s.doSomething()                                         
```

|      | use of the **as** keyword to coerce an object to a trait **at runtime** |
| ---- | ------------------------------------------------------------ |
|      | then `extra` can be called on the object                     |
|      | and `doSomething` is still callable                          |

|      | When coercing an object to a trait, the result of the operation is not the same instance. It is guaranteed that the coerced object will implement both the trait **and** the interfaces that the original object implements, but the result will **not** be an instance of the original class. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Implementing multiple traits at once

Should you need to implement several traits at once, you can use the `withTraits` method instead of the `as` keyword:

```groovy
trait A { void methodFromA() {} }
trait B { void methodFromB() {} }

class C {}

def c = new C()
c.methodFromA()                     
c.methodFromB()                     
def d = c.withTraits A, B           
d.methodFromA()                     
d.methodFromB()                     
```

|      | call to `methodFromA` will fail because `C` doesn’t implement `A` |
| ---- | ------------------------------------------------------------ |
|      | call to `methodFromB` will fail because `C` doesn’t implement `B` |
|      | `withTrait` will wrap `c` into something which implements `A` and `B` |
|      | `methodFromA` will now pass because `d` implements `A`       |
|      | `methodFromB` will now pass because `d` also implements `B`  |

|      | When coercing an object to multiple traits, the result of the operation is not the same instance. It is guaranteed that the coerced object will implement both the traits **and** the interfaces that the original object implements, but the result will **not** be an instance of the original class. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Chaining behavior

Groovy supports the concept of *stackable traits*. The idea is to delegate from one trait to the other if the current trait is not capable of handling a message. To illustrate this, let’s imagine a message handler interface like this:

```groovy
interface MessageHandler {
    void on(String message, Map payload)
}
```

Then you can compose a message handler by applying small behaviors. For example, let’s define a default handler in the form of a trait:

```groovy
trait DefaultHandler implements MessageHandler {
    void on(String message, Map payload) {
        println "Received $message with payload $payload"
    }
}
```

Then any class can inherit the behavior of the default handler by implementing the trait:

```groovy
class SimpleHandler implements DefaultHandler {}
```

Now what if you want to log all messages, in addition to the default handler? One option is to write this:

```groovy
class SimpleHandlerWithLogging implements DefaultHandler {
    void on(String message, Map payload) {                                  
        println "Seeing $message with payload $payload"                     
        DefaultHandler.super.on(message, payload)                           
    }
}
```

|      | explicitly implement the `on` method                 |
| ---- | ---------------------------------------------------- |
|      | perform logging                                      |
|      | continue by delegating to the `DefaultHandler` trait |

This works but this approach has drawbacks:

1. the logging logic is bound to a "concrete" handler
2. we have an explicit reference to `DefaultHandler` in the `on` method, meaning that if we happen to change the trait that our class implements, code will be broken

As an alternative, we can write another trait which responsibility is limited to logging:

```groovy
trait LoggingHandler implements MessageHandler {                            
    void on(String message, Map payload) {
        println "Seeing $message with payload $payload"                     
        super.on(message, payload)                                          
    }
}
```

|      | the logging handler is itself a handler                      |
| ---- | ------------------------------------------------------------ |
|      | prints the message it receives                               |
|      | then `super` makes it delegate the call to the next trait in the chain |

Then our class can be rewritten as this:

```groovy
class HandlerWithLogger implements DefaultHandler, LoggingHandler {}
def loggingHandler = new HandlerWithLogger()
loggingHandler.on('test logging', [:])
```

which will print:

```
Seeing test logging with payload [:]
Received test logging with payload [:]
```

As the priority rules imply that `LoggerHandler` wins because it is declared last, then a call to `on` will use the implementation from `LoggingHandler`. But the latter has a call to `super`, which means the next trait in the chain. Here, the next trait is `DefaultHandler` so **both** will be called:

The interest of this approach becomes more evident if we add a third handler, which is responsible for handling messages that start with `say`:

```groovy
trait SayHandler implements MessageHandler {
    void on(String message, Map payload) {
        if (message.startsWith("say")) {                                    
            println "I say ${message - 'say'}!"
        } else {
            super.on(message, payload)                                      
        }
    }
}
```

|      | a handler specific precondition                              |
| ---- | ------------------------------------------------------------ |
|      | if the precondition is not met, pass the message to the next handler in the chain |

Then our final handler looks like this:

```groovy
class Handler implements DefaultHandler, SayHandler, LoggingHandler {}
def h = new Handler()
h.on('foo', [:])
h.on('sayHello', [:])
```

Which means:

- messages will first go through the logging handler
- the logging handler calls `super` which will delegate to the next handler, which is the `SayHandler`
- if the message starts with `say`, then the handler consumes the message
- if not, the `say` handler delegates to the next handler in the chain

This approach is very powerful because it allows you to write handlers that do not know each other and yet let you combine them in the order you want. For example, if we execute the code, it will print:

```
Seeing foo with payload [:]
Received foo with payload [:]
Seeing sayHello with payload [:]
I say Hello!
```

but if we move the logging handler to be the second one in the chain, the output is different:

```groovy
class AlternateHandler implements DefaultHandler, LoggingHandler, SayHandler {}
h = new AlternateHandler()
h.on('foo', [:])
h.on('sayHello', [:])
```

prints:

```
Seeing foo with payload [:]
Received foo with payload [:]
I say Hello!
```

The reason is that now, since the `SayHandler` consumes the message without calling `super`, the logging handler is not called anymore.

###### Semantics of super inside a trait

If a class implements multiple traits and a call to an unqualified `super` is found, then:

1. if the class implements another trait, the call delegates to the next trait in the chain
2. if there isn’t any trait left in the chain, `super` refers to the super class of the implementing class (*this*)

For example, it is possible to decorate final classes thanks to this behavior:

```groovy
trait Filtering {                                       
    StringBuilder append(String str) {                  
        def subst = str.replace('o','')                 
        super.append(subst)                             
    }
    String toString() { super.toString() }              
}
def sb = new StringBuilder().withTraits Filtering       
sb.append('Groovy')
assert sb.toString() == 'Grvy'                          
```

|      | define a trait named `Filtering`, supposed to be applied on a `StringBuilder` at runtime |
| ---- | ------------------------------------------------------------ |
|      | redefine the `append` method                                 |
|      | remove all 'o’s from the string                              |
|      | then delegate to `super`                                     |
|      | in case `toString` is called, delegate to `super.toString`   |
|      | runtime implementation of the `Filtering` trait on a `StringBuilder` instance |
|      | the string which has been appended no longer contains the letter `o` |

In this example, when `super.append` is encountered, there is no other trait implemented by the target object, so the method which is called is the original `append` method, that is to say the one from `StringBuilder`. The same trick is used for `toString`, so that the string representation of the proxy object which is generated delegates to the `toString` of the `StringBuilder` instance.

##### Advanced features

###### SAM type coercion

If a trait defines a single abstract method, it is candidate for SAM (Single Abstract Method) type coercion. For example, imagine the following trait:

```groovy
trait Greeter {
    String greet() { "Hello $name" }        
    abstract String getName()               
}
```

|      | the `greet` method is not abstract and calls the abstract method `getName` |
| ---- | ------------------------------------------------------------ |
|      | `getName` is an abstract method                              |

Since `getName` is the *single abstract method* in the `Greeter` trait, you can write:

```groovy
Greeter greeter = { 'Alice' }               
```

|      | the closure "becomes" the implementation of the `getName` single abstract method |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

or even:

```groovy
void greet(Greeter g) { println g.greet() } 
greet { 'Alice' }                           
```

|      | the greet method accepts the SAM type Greeter as parameter |
| ---- | ---------------------------------------------------------- |
|      | we can call it directly with a closure                     |

###### Differences with Java 8 default methods

In Java 8, interfaces can have default implementations of methods. If a class implements an interface and does not provide an implementation for a default method, then the implementation from the interface is chosen. Traits behave the same but with a major difference: the implementation from the trait is **always** used if the class declares the trait in its interface list **and** that it doesn’t provide an implementation **even** if a super class does.

This feature can be used to compose behaviors in an very precise way, in case you want to override the behavior of an already implemented method.

To illustrate the concept, let’s start with this simple example:

```groovy
import groovy.test.GroovyTestCase
import groovy.transform.CompileStatic
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import org.codehaus.groovy.control.customizers.ImportCustomizer

class SomeTest extends GroovyTestCase {
    def config
    def shell

    void setup() {
        config = new CompilerConfiguration()
        shell = new GroovyShell(config)
    }
    void testSomething() {
        assert shell.evaluate('1+1') == 2
    }
    void otherTest() { /* ... */ }
}
```

In this example, we create a simple test case which uses two properties (*config* and *shell*) and uses those in multiple test methods. Now imagine that you want to test the same, but with another distinct compiler configuration. One option is to create a subclass of `SomeTest`:

```groovy
class AnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}
```

It works, but what if you have actually multiple test classes, and that you want to test the new configuration for all those test classes? Then you would have to create a distinct subclass for each test class:

```groovy
class YetAnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}
```

Then what you see is that the `setup` method of both tests is the same. The idea, then, is to create a trait:

```groovy
trait MyTestSupport {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( new ASTTransformationCustomizer(CompileStatic) )
        shell = new GroovyShell(config)
    }
}
```

Then use it in the subclasses:

```groovy
class AnotherTest extends SomeTest implements MyTestSupport {}
class YetAnotherTest extends SomeTest2 implements MyTestSupport {}
...
```

It would allow us to dramatically reduce the boilerplate code, and reduces the risk of forgetting to change the setup code in case we decide to change it. Even if `setup` is already implemented in the super class, since the test class declares the trait in its interface list, the behavior will be borrowed from the trait implementation!

This feature is in particular useful when you don’t have access to the super class source code. It can be used to mock methods or force a particular implementation of a method in a subclass. It lets you refactor your code to keep the overridden logic in a single trait and inherit a new behavior just by implementing it. The alternative, of course, is to override the method in **every** place you would have used the new code.

|      | It’s worth noting that if you use runtime traits, the methods from the trait are **always** preferred to those of the proxied object: |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```groovy
class Person {
    String name                                         
}
trait Bob {
    String getName() { 'Bob' }                          
}

def p = new Person(name: 'Alice')
assert p.name == 'Alice'                                
def p2 = p as Bob                                       
assert p2.name == 'Bob'                                 
```

|      | the `Person` class defines a `name` property which results in a `getName` method |
| ---- | ------------------------------------------------------------ |
|      | `Bob` is a trait which defines `getName` as returning `Bob`  |
|      | the default object will return *Alice*                       |
|      | `p2` coerces `p` into `Bob` at runtime                       |
|      | `getName` returns *Bob* because `getName` is taken from the **trait** |

|      | Again, don’t forget that dynamic trait coercion returns a distinct object which only implements the original interfaces, as well as the traits. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Differences with mixins

There are several conceptual differences with mixins, as they are available in Groovy. Note that we are talking about runtime mixins, not the @Mixin annotation which is deprecated in favour of traits.

First of all, methods defined in a trait are visible in bytecode:

- internally, the trait is represented as an interface (without default or static methods) and several helper classes
- this means that an object implementing a trait effectively implements an *interface*
- those methods are visible from Java
- they are compatible with type checking and static compilation

Methods added through a mixin are, on the contrary, only visible at runtime:

```groovy
class A { String methodFromA() { 'A' } }        
class B { String methodFromB() { 'B' } }        
A.metaClass.mixin B                             
def o = new A()
assert o.methodFromA() == 'A'                   
assert o.methodFromB() == 'B'                   
assert o instanceof A                           
assert !(o instanceof B)                        
```

|      | class `A` defines `methodFromA`    |
| ---- | ---------------------------------- |
|      | class `B` defines `methodFromB`    |
|      | mixin B into A                     |
|      | we can call `methodFromA`          |
|      | we can also call `methodFromB`     |
|      | the object is an instance of `A`   |
|      | but it’s **not** an instanceof `B` |

The last point is actually a very important and illustrates a place where mixins have an advantage over traits: the instances are **not** modified, so if you mixin some class into another, there isn’t a third class generated, and methods which respond to A will continue responding to A even if mixed in.

##### Static methods, properties and fields

|      | The following instructions are subject to caution. Static member support is work in progress and still experimental. The information below is valid for 3.0.3 only. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

It is possible to define static methods in a trait, but it comes with numerous limitations:

- Traits with static methods cannot be compiled statically or type checked. All static methods, properties and field are accessed dynamically (it’s a limitation from the JVM).
- Static methods do not appear within the generated interfaces for each trait.
- The trait is interpreted as a *template* for the implementing class, which means that each implementing class will get its own static methods, properties and fields. So a static member declared on a trait doesn’t belong to the `Trait`, but to it’s implementing class.
- You should typically not mix static and instance methods of the same signature. The normal rules for applying traits apply (including multiple inheritance conflict resolution). If the method chosen is static but some implemented trait has an instance variant, a compilation error will occur. If the method chosen is the instance variant, the static variant will be ignored (the behavior is similar to static methods in Java interfaces for this case).

Let’s start with a simple example:

```groovy
trait TestHelper {
    public static boolean CALLED = false        
    static void init() {                        
        CALLED = true                           
    }
}
class Foo implements TestHelper {}
Foo.init()                                      
assert Foo.TestHelper__CALLED                   
```

|      | the static field is declared in the trait                    |
| ---- | ------------------------------------------------------------ |
|      | a static method is also declared in the trait                |
|      | the static field is updated *within* the trait               |
|      | a static method *init* is made available to the implementing class |
|      | the static field is *remapped* to avoid the diamond issue    |

As usual, it is not recommended to use public fields. Anyway, should you want this, you must understand that the following code would fail:

```groovy
Foo.CALLED = true
```

because there is *no* static field *CALLED* defined on the trait itself. Likewise, if you have two distinct implementing classes, each one gets a distinct static field:

```groovy
class Bar implements TestHelper {}              
class Baz implements TestHelper {}              
Bar.init()                                      
assert Bar.TestHelper__CALLED                   
assert !Baz.TestHelper__CALLED                  
```

|      | class `Bar` implements the trait                             |
| ---- | ------------------------------------------------------------ |
|      | class `Baz` also implements the trait                        |
|      | `init` is only called on `Bar`                               |
|      | the static field `CALLED` on `Bar` is updated                |
|      | but the static field `CALLED` on `Baz` is not, because it is **distinct** |

##### Inheritance of state gotchas

We have seen that traits are stateful. It is possible for a trait to define fields or properties, but when a class implements a trait, it gets those fields/properties on a per-trait basis. So consider the following example:

```groovy
trait IntCouple {
    int x = 1
    int y = 2
    int sum() { x+y }
}
```

The trait defines two properties, `x` and `y`, as well as a `sum` method. Now let’s create a class which implements the trait:

```groovy
class BaseElem implements IntCouple {
    int f() { sum() }
}
def base = new BaseElem()
assert base.f() == 3
```

The result of calling `f` is `3`, because `f` delegates to `sum` in the trait, which has state. But what if we write this instead?

```groovy
class Elem implements IntCouple {
    int x = 3                                       
    int y = 4                                       
    int f() { sum() }                               
}
def elem = new Elem()
```

|      | Override property `x` |
| ---- | --------------------- |
|      | Override property `y` |
|      | Call `sum` from trait |

If you call `elem.f()`, what is the expected output? Actually it is:

```groovy
assert elem.f() == 3
```

The reason is that the `sum` method accesses the *fields* of the trait. So it is using the `x` and `y` values defined in the trait. If you want to use the values from the implementing class, then you need to dereference fields by using getters and setters, like in this last example:

```groovy
trait IntCouple {
    int x = 1
    int y = 2
    int sum() { getX()+getY() }
}

class Elem implements IntCouple {
    int x = 3
    int y = 4
    int f() { sum() }
}
def elem = new Elem()
assert elem.f() == 7
```

##### Self types

###### Type constraints on traits

Sometimes you will want to write a trait that can only be applied to some type. For example, you may want to apply a trait on a class that extends another class which is beyond your control, and still be able to call those methods. To illustrate this, let’s start with this example:

```groovy
class CommunicationService {
    static void sendMessage(String from, String to, String message) {       
        println "$from sent [$message] to $to"
    }
}

class Device { String id }                                                  

trait Communicating {
    void sendMessage(Device to, String message) {
        CommunicationService.sendMessage(id, to.id, message)                
    }
}

class MyDevice extends Device implements Communicating {}                   

def bob = new MyDevice(id:'Bob')
def alice = new MyDevice(id:'Alice')
bob.sendMessage(alice,'secret')                                             
```

|      | A `Service` class, beyond your control (in a library, …) defines a `sendMessage` method |
| ---- | ------------------------------------------------------------ |
|      | A `Device` class, beyond your control (in a library, …)      |
|      | Defines a communicating trait for devices that can call the service |
|      | Defines `MyDevice` as a communicating device                 |
|      | The method from the trait is called, and `id` is resolved    |

It is clear, here, that the `Communicating` trait can only apply to `Device`. However, there’s no explicit contract to indicate that, because traits cannot extend classes. However, the code compiles and runs perfectly fine, because `id` in the trait method will be resolved dynamically. The problem is that there is nothing that prevents the trait from being applied to any class which is **not** a `Device`. Any class which has an `id` would work, while any class that does not have an `id` property would cause a runtime error.

The problem is even more complex if you want to enable type checking or apply `@CompileStatic` on the trait: because the trait knows nothing about itself being a `Device`, the type checker will complain saying that it does not find the `id` property.

One possibility is to explicitly add a `getId` method in the trait, but it would not solve all issues. What if a method requires `this` as a parameter, and actually requires it to be a `Device`?

```groovy
class SecurityService {
    static void check(Device d) { if (d.id==null) throw new SecurityException() }
}
```

If you want to be able to call `this` in the trait, then you will explicitly need to cast `this` into a `Device`. This can quickly become unreadable with explicit casts to `this` everywhere.

###### The @SelfType annotation

In order to make this contract explicit, and to make the type checker aware of the *type of itself*, Groovy provides a `@SelfType` annotation that will:

- let you declare the types that a class that implements this trait must inherit or implement
- throw a compile time error if those type constraints are not satisfied

So in our previous example, we can fix the trait using the `@groovy.transform.SelfType` annotation:

```groovy
@SelfType(Device)
@CompileStatic
trait Communicating {
    void sendMessage(Device to, String message) {
        SecurityService.check(this)
        CommunicationService.sendMessage(id, to.id, message)
    }
}
```

Now if you try to implement this trait on a class that is **not** a device, a compile-time error will occur:

```groovy
class MyDevice implements Communicating {} // forgot to extend Device
```

The error will be:

```
class 'MyDevice' implements trait 'Communicating' but does not extend self type class 'Device'
```

In conclusion, self types are a powerful way of declaring constraints on traits without having to declare the contract directly in the trait or having to use casts everywhere, maintaining separation of concerns as tight as it should be.

##### Limitations

###### Compatibility with AST transformations

|      | Traits are not officially compatible with AST transformations. Some of them, like `@CompileStatic` will be applied on the trait itself (not on implementing classes), while others will apply on both the implementing class and the trait. There is absolutely no guarantee that an AST transformation will run on a trait as it does on a regular class, so use it at your own risk! |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Prefix and postfix operations

Within traits, prefix and postfix operations are not allowed if they update a field of the trait:

```groovy
trait Counting {
    int x
    void inc() {
        x++                             
    }
    void dec() {
        --x                             
    }
}
class Counter implements Counting {}
def c = new Counter()
c.inc()
```

|      | `x` is defined within the trait, postfix increment is not allowed |
| ---- | ------------------------------------------------------------ |
|      | `x` is defined within the trait, prefix decrement is not allowed |

A workaround is to use the `+=` operator instead.

### 1.5. Closures

This chapter covers Groovy Closures. A closure in Groovy is an open, anonymous, block of code that can take arguments, return a value and be assigned to a variable. A closure may reference variables declared in its surrounding scope. In opposition to the formal definition of a closure, `Closure` in the Groovy language can also contain free variables which are defined outside of its surrounding scope. While breaking the formal concept of a closure, it offers a variety of advantages which are described in this chapter.

#### 1.5.1. Syntax

##### Defining a closure

A closure definition follows this syntax:

```groovy
{ [closureParameters -> ] statements }
```

Where `[closureParameters->]` is an optional comma-delimited list of parameters, and statements are 0 or more Groovy statements. The parameters look similar to a method parameter list, and these parameters may be typed or untyped.

When a parameter list is specified, the `->` character is required and serves to separate the arguments from the closure body. The *statements* portion consists of 0, 1, or many Groovy statements.

Some examples of valid closure definitions:

```groovy
{ item++ }                                          

{ -> item++ }                                       

{ println it }                                      

{ it -> println it }                                

{ name -> println name }                            

{ String x, int y ->                                
    println "hey ${x} the value is ${y}"
}

{ reader ->                                         
    def line = reader.readLine()
    line.trim()
}
```

|      | A closure referencing a variable named `item`                |
| ---- | ------------------------------------------------------------ |
|      | It is possible to explicitly separate closure parameters from code by adding an arrow (`->`) |
|      | A closure using an implicit parameter (`it`)                 |
|      | An alternative version where `it` is an explicit parameter   |
|      | In that case it is often better to use an explicit name for the parameter |
|      | A closure accepting two typed parameters                     |
|      | A closure can contain multiple statements                    |

##### Closures as an object

A closure is an instance of the `groovy.lang.Closure` class, making it assignable to a variable or a field as any other variable, despite being a block of code:

```groovy
def listener = { e -> println "Clicked on $e.source" }      
assert listener instanceof Closure
Closure callback = { println 'Done!' }                      
Closure<Boolean> isTextFile = {
    File it -> it.name.endsWith('.txt')                     
}
```

|      | You can assign a closure to a variable, and it is an instance of `groovy.lang.Closure` |
| ---- | ------------------------------------------------------------ |
|      | If not using `def` or `var`, use `groovy.lang.Closure` as the type |
|      | Optionally, you can specify the return type of the closure by using the generic type of `groovy.lang.Closure` |

##### Calling a closure

A closure, as an anonymous block of code, can be called like any other method. If you define a closure which takes no argument like this:

```groovy
def code = { 123 }
```

Then the code inside the closure will only be executed when you *call* the closure, which can be done by using the variable as if it was a regular method:

```groovy
assert code() == 123
```

Alternatively, you can be explicit and use the `call` method:

```groovy
assert code.call() == 123
```

The principle is the same if the closure accepts arguments:

```groovy
def isOdd = { int i -> i%2 != 0 }                           
assert isOdd(3) == true                                     
assert isOdd.call(2) == false                               

def isEven = { it%2 == 0 }                                  
assert isEven(3) == false                                   
assert isEven.call(2) == true                               
```

|      | define a closure which accepts an `int` as a parameter   |
| ---- | -------------------------------------------------------- |
|      | it can be called directly                                |
|      | or using the `call` method                               |
|      | same goes for a closure with an implicit argument (`it`) |
|      | which can be called directly using `(arg)`               |
|      | or using `call`                                          |

Unlike a method, a closure **always** returns a value when called. The next section discusses how to declare closure arguments, when to use them and what is the [implicit "it" parameter](https://docs.groovy-lang.org/latest/html/documentation/#implicit-it).

#### 1.5.2. Parameters

##### Normal parameters

Parameters of closures follow the same principle as parameters of regular methods:

- an optional type
- a name
- an optional default value

Parameters are separated with commas:

```groovy
def closureWithOneArg = { str -> str.toUpperCase() }
assert closureWithOneArg('groovy') == 'GROOVY'

def closureWithOneArgAndExplicitType = { String str -> str.toUpperCase() }
assert closureWithOneArgAndExplicitType('groovy') == 'GROOVY'

def closureWithTwoArgs = { a,b -> a+b }
assert closureWithTwoArgs(1,2) == 3

def closureWithTwoArgsAndExplicitTypes = { int a, int b -> a+b }
assert closureWithTwoArgsAndExplicitTypes(1,2) == 3

def closureWithTwoArgsAndOptionalTypes = { a, int b -> a+b }
assert closureWithTwoArgsAndOptionalTypes(1,2) == 3

def closureWithTwoArgAndDefaultValue = { int a, int b=2 -> a+b }
assert closureWithTwoArgAndDefaultValue(1) == 3
```

##### Implicit parameter

When a closure does not explicitly define a parameter list (using `->`), a closure **always** defines an implicit parameter, named `it`. This means that this code:

```groovy
def greeting = { "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'
```

is stricly equivalent to this one:

```groovy
def greeting = { it -> "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'
```

If you want to declare a closure which accepts no argument and must be restricted to calls without arguments, then you **must** declare it with an explicit empty argument list:

```groovy
def magicNumber = { -> 42 }

// this call will fail because the closure doesn't accept any argument
magicNumber(11)
```

##### Varargs

It is possible for a closure to declare variable arguments like any other method. *Vargs* methods are methods that can accept a variable number of arguments if the last parameter is of variable length (or an array) like in the next examples:

```groovy
def concat1 = { String... args -> args.join('') }           
assert concat1('abc','def') == 'abcdef'                     
def concat2 = { String[] args -> args.join('') }            
assert concat2('abc', 'def') == 'abcdef'

def multiConcat = { int n, String... args ->                
    args.join('')*n
}
assert multiConcat(2, 'abc','def') == 'abcdefabcdef'
```

|      | A closure accepting a variable number of strings as first parameter |
| ---- | ------------------------------------------------------------ |
|      | It may be called using any number of arguments **without** having to explicitly wrap them into an array |
|      | The same behavior is directly available if the *args* parameter is declared as an array |
|      | As long as the **last** parameter is an array or an explicit vargs type |

#### 1.5.3. Delegation strategy

##### Groovy closures vs lambda expressions

Groovy defines closures as [instances of the Closure class](https://docs.groovy-lang.org/latest/html/documentation/#closure-as-object). It makes it very different from [lambda expressions in Java 8](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html). Delegation is a key concept in Groovy closures which has no equivalent in lambdas. The ability to *change the delegate* or *change the delegation strategy* of closures make it possible to design beautiful domain specific languages (DSLs) in Groovy.

##### Owner, delegate and this

To understand the concept of delegate, we must first explain the meaning of `this` inside a closure. A closure actually defines 3 distinct things:

- `this` corresponds to the *enclosing class* where the closure is defined
- `owner` corresponds to the *enclosing object* where the closure is defined, which may be either a class or a closure
- `delegate` corresponds to a third party object where methods calls or properties are resolved whenever the receiver of the message is not defined

###### The meaning of this

In a closure, calling `getThisObject` will return the enclosing class where the closure is defined. It is equivalent to using an explicit `this`:

```groovy
class Enclosing {
    void run() {
        def whatIsThisObject = { getThisObject() }          
        assert whatIsThisObject() == this                   
        def whatIsThis = { this }                           
        assert whatIsThis() == this                         
    }
}
class EnclosedInInnerClass {
    class Inner {
        Closure cl = { this }                               
    }
    void run() {
        def inner = new Inner()
        assert inner.cl() == inner                          
    }
}
class NestedClosures {
    void run() {
        def nestedClosures = {
            def cl = { this }                               
            cl()
        }
        assert nestedClosures() == this                     
    }
}
```

|      | a closure is defined inside the `Enclosing` class, and returns `getThisObject` |
| ---- | ------------------------------------------------------------ |
|      | calling the closure will return the instance of `Enclosing` where the closure is defined |
|      | in general, you will just want to use the shortcut `this` notation |
|      | and it returns **exactly** the same object                   |
|      | if the closure is defined in a inner class                   |
|      | `this` in the closure **will** return the inner class, not the top-level one |
|      | in case of nested closures, like here `cl` being defined inside the scope of `nestedClosures` |
|      | then `this` corresponds to the closest outer class, not the enclosing closure! |

It is of course possible to call methods from the enclosing class this way:

```groovy
class Person {
    String name
    int age
    String toString() { "$name is $age years old" }

    String dump() {
        def cl = {
            String msg = this.toString()               
            println msg
            msg
        }
        cl()
    }
}
def p = new Person(name:'Janice', age:74)
assert p.dump() == 'Janice is 74 years old'
```

|      | the closure calls `toString` on `this`, which will actually call the `toString` method on the enclosing object, that is to say the `Person` instance |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Owner of a closure

The owner of a closure is very similar to the definition of [this in a closure](https://docs.groovy-lang.org/latest/html/documentation/#closure-this) with a subtle difference: it will return the direct enclosing object, be it a closure or a class:

```groovy
class Enclosing {
    void run() {
        def whatIsOwnerMethod = { getOwner() }               
        assert whatIsOwnerMethod() == this                   
        def whatIsOwner = { owner }                          
        assert whatIsOwner() == this                         
    }
}
class EnclosedInInnerClass {
    class Inner {
        Closure cl = { owner }                               
    }
    void run() {
        def inner = new Inner()
        assert inner.cl() == inner                           
    }
}
class NestedClosures {
    void run() {
        def nestedClosures = {
            def cl = { owner }                               
            cl()
        }
        assert nestedClosures() == nestedClosures            
    }
}
```

|      | a closure is defined inside the `Enclosing` class, and returns `getOwner` |
| ---- | ------------------------------------------------------------ |
|      | calling the closure will return the instance of `Enclosing` where the closure is defined |
|      | in general, you will just want to use the shortcut `owner` notation |
|      | and it returns **exactly** the same object                   |
|      | if the closure is defined in a inner class                   |
|      | `owner` in the closure **will** return the inner class, not the top-level one |
|      | but in case of nested closures, like here `cl` being defined inside the scope of `nestedClosures` |
|      | then `owner` corresponds to the enclosing closure, hence a different object from `this`! |

###### Delegate of a closure

The delegate of a closure can be accessed by using the `delegate` property or calling the `getDelegate` method. It is a powerful concept for building domain specific languages in Groovy. While [closure-this](https://docs.groovy-lang.org/latest/html/documentation/#this) and [closure-owner](https://docs.groovy-lang.org/latest/html/documentation/#owner) refer to the lexical scope of a closure, the delegate is a user defined object that a closure will use. By default, the delegate is set to `owner`:

```groovy
class Enclosing {
    void run() {
        def cl = { getDelegate() }                          
        def cl2 = { delegate }                              
        assert cl() == cl2()                                
        assert cl() == this                                 
        def enclosed = {
            { -> delegate }.call()                          
        }
        assert enclosed() == enclosed                       
    }
}
```

|      | you can get the delegate of a closure calling the `getDelegate` method |
| ---- | ------------------------------------------------------------ |
|      | or using the `delegate` property                             |
|      | both return the same object                                  |
|      | which is the enclosing class or closure                      |
|      | in particular in case of nested closures                     |
|      | `delegate` will correspond to the `owner`                    |

The delegate of a closure can be changed to **any object**. Let’s illustrate this by creating two classes which are not subclasses of each other but both define a property called `name`:

```groovy
class Person {
    String name
}
class Thing {
    String name
}

def p = new Person(name: 'Norman')
def t = new Thing(name: 'Teapot')
```

Then let’s define a closure which fetches the `name` property on the delegate:

```groovy
def upperCasedName = { delegate.name.toUpperCase() }
```

Then by changing the delegate of the closure, you can see that the target object will change:

```groovy
upperCasedName.delegate = p
assert upperCasedName() == 'NORMAN'
upperCasedName.delegate = t
assert upperCasedName() == 'TEAPOT'
```

At this point, the behavior is not different from having a `target` variable defined in the lexical scope of the closure:

```groovy
def target = p
def upperCasedNameUsingVar = { target.name.toUpperCase() }
assert upperCasedNameUsingVar() == 'NORMAN'
```

However, there are major differences:

- in the last example, *target* is a local variable referenced from within the closure
- the delegate can be used transparently, that is to say without prefixing method calls with `delegate.` as explained in the next paragraph.

###### Delegation strategy

Whenever, in a closure, a property is accessed without explicitly setting a receiver object, then a delegation strategy is involved:

```groovy
class Person {
    String name
}
def p = new Person(name:'Igor')
def cl = { name.toUpperCase() }                 
cl.delegate = p                                 
assert cl() == 'IGOR'                           
```

|      | `name` is not referencing a variable in the lexical scope of the closure |
| ---- | ------------------------------------------------------------ |
|      | we can change the delegate of the closure to be an instance of `Person` |
|      | and the method call will succeed                             |

The reason this code works is that the `name` property will be resolved transparently on the `delegate` object! This is a very powerful way to resolve properties or method calls inside closures. There’s no need to set an explicit `delegate.` receiver: the call will be made because the default delegation strategy of the closure makes it so. A closure actually defines multiple resolution strategies that you can choose:

- `Closure.OWNER_FIRST` is the **default strategy**. If a property/method exists on the **owner**, then it will be called on the owner. If not, then the **delegate** is used.
- `Closure.DELEGATE_FIRST` reverses the logic: the **delegate** is used first, then the **owner**
- `Closure.OWNER_ONLY` will only resolve the property/method lookup on the owner: the delegate will be ignored.
- `Closure.DELEGATE_ONLY` will only resolve the property/method lookup on the delegate: the owner will be ignored.
- `Closure.TO_SELF` can be used by developers who need advanced meta-programming techniques and wish to implement a custom resolution strategy: the resolution will not be made on the owner or the delegate but only on the closure class itself. It makes only sense to use this if you implement your own subclass of `Closure`.

Let’s illustrate the default "owner first" strategy with this code:

```groovy
class Person {
    String name
    def pretty = { "My name is $name" }             
    String toString() {
        pretty()
    }
}
class Thing {
    String name                                     
}

def p = new Person(name: 'Sarah')
def t = new Thing(name: 'Teapot')

assert p.toString() == 'My name is Sarah'           
p.pretty.delegate = t                               
assert p.toString() == 'My name is Sarah'           
```

|      | for the illustration, we define a closure member which references "name" |
| ---- | ------------------------------------------------------------ |
|      | both the `Person` and the `Thing` class define a `name` property |
|      | Using the default strategy, the `name` property is resolved on the owner first |
|      | so if we change the `delegate` to `t` which is an instance of `Thing` |
|      | there is no change in the result: `name` is first resolved on the `owner` of the closure |

However, it is possible to change the resolution strategy of the closure:

```groovy
p.pretty.resolveStrategy = Closure.DELEGATE_FIRST
assert p.toString() == 'My name is Teapot'
```

By changing the `resolveStrategy`, we are modifying the way Groovy will resolve the "implicit this" references: in this case, `name` will first be looked in the delegate, then if not found, on the owner. Since `name` is defined in the delegate, an instance of `Thing`, then this value is used.

The difference between "delegate first" and "delegate only" or "owner first" and "owner only" can be illustrated if one of the delegate (resp. owner) does **not** have such a method or property:

```groovy
class Person {
    String name
    int age
    def fetchAge = { age }
}
class Thing {
    String name
}

def p = new Person(name:'Jessica', age:42)
def t = new Thing(name:'Printer')
def cl = p.fetchAge
cl.delegate = p
assert cl() == 42
cl.delegate = t
assert cl() == 42
cl.resolveStrategy = Closure.DELEGATE_ONLY
cl.delegate = p
assert cl() == 42
cl.delegate = t
try {
    cl()
    assert false
} catch (MissingPropertyException ex) {
    // "age" is not defined on the delegate
}
```

In this example, we define two classes which both have a `name` property but only the `Person` class declares an `age`. The `Person` class also declares a closure which references `age`. We can change the default resolution strategy from "owner first" to "delegate only". Since the owner of the closure is the `Person` class, then we can check that if the delegate is an instance of `Person`, calling the closure is successful, but if we call it with a delegate being an instance of `Thing`, it fails with a `groovy.lang.MissingPropertyException`. Despite the closure being defined inside the `Person` class, the owner is not used.

|      | A comprehensive explanation about how to use this feature to develop DSLs can be found in a [dedicated section of the manual](https://docs.groovy-lang.org/latest/html/documentation/core-domain-specific-languages.html). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 1.5.4. Closures in GStrings

Take the following code:

```groovy
def x = 1
def gs = "x = ${x}"
assert gs == 'x = 1'
```

The code behaves as you would expect, but what happens if you add:

```groovy
x = 2
assert gs == 'x = 2'
```

You will see that the assert fails! There are two reasons for this:

- a GString only evaluates lazily the `toString` representation of values
- the syntax `${x}` in a GString does **not** represent a closure but an **expression** to `$x`, evaluated when the GString is created.

In our example, the `GString` is created with an expression referencing `x`. When the `GString` is created, the **value** of `x` is 1, so the `GString` is created with a value of 1. When the assert is triggered, the `GString` is evaluated and 1 is converted to a `String` using `toString`. When we change `x` to 2, we did change the value of `x`, but it is a different object, and the `GString` still references the old one.

|      | A `GString` will only change its `toString` representation if the values it references are mutating. If the references change, nothing will happen. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

If you need a real closure in a GString and for example enforce lazy evaluation of variables, you need to use the alternate syntax `${→ x}` like in the fixed example:

```groovy
def x = 1
def gs = "x = ${-> x}"
assert gs == 'x = 1'

x = 2
assert gs == 'x = 2'
```

And let’s illustrate how it differs from mutation with this code:

```groovy
class Person {
    String name
    String toString() { name }          
}
def sam = new Person(name:'Sam')        
def lucy = new Person(name:'Lucy')      
def p = sam                             
def gs = "Name: ${p}"                   
assert gs == 'Name: Sam'                
p = lucy                                
assert gs == 'Name: Sam'                
sam.name = 'Lucy'                       
assert gs == 'Name: Lucy'               
```

|      | the `Person` class has a `toString` method returning the `name` property |
| ---- | ------------------------------------------------------------ |
|      | we create a first `Person` named *Sam*                       |
|      | we create another `Person` named *Lucy*                      |
|      | the `p` variable is set to `Sam`                             |
|      | and a closure is created, referencing the value of `p`, that is to say *Sam* |
|      | so when we evaluate the string, it returns *Sam*             |
|      | if we change `p` to *Lucy*                                   |
|      | the string still evaluates to *Sam* because it was the **value** of `p` when the `GString` was created |
|      | so if we mutate *Sam* to change his name to *Lucy*           |
|      | this time the `GString` is correctly mutated                 |

So if you don’t want to rely on mutating objects or wrapping objects, you **must** use closures in `GString` by explicitly declaring an empty argument list:

```groovy
class Person {
    String name
    String toString() { name }
}
def sam = new Person(name:'Sam')
def lucy = new Person(name:'Lucy')
def p = sam
// Create a GString with lazy evaluation of "p"
def gs = "Name: ${-> p}"
assert gs == 'Name: Sam'
p = lucy
assert gs == 'Name: Lucy'
```

#### 1.5.5. Closure coercion

Closures can be converted into interfaces or single-abstract method types. Please refer to [this section of the manual](https://docs.groovy-lang.org/latest/html/documentation/core-semantics.html#closure-coercion) for a complete description.

#### 1.5.6. Functional programming

Closures, like [lambda expressions in Java 8](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) are at the core of the functional programming paradigm in Groovy. Some functional programming operations on functions are available directly on the `Closure` class, like illustrated in this section.

##### Currying

In Groovy, currying refers to the concept of partial application. It does **not** correspond to the real concept of currying in functional programming because of the different scoping rules that Groovy applies on closures. Currying in Groovy will let you set the value of one parameter of a closure, and it will return a new closure accepting one less argument.

###### Left currying

Left currying is the fact of setting the left-most parameter of a closure, like in this example:

```groovy
def nCopies = { int n, String str -> str*n }    
def twice = nCopies.curry(2)                    
assert twice('bla') == 'blabla'                 
assert twice('bla') == nCopies(2, 'bla')        
```

|      | the `nCopies` closure defines two parameters                 |
| ---- | ------------------------------------------------------------ |
|      | `curry` will set the first parameter to `2`, creating a new closure (function) which accepts a single `String` |
|      | so the new function call be called with only a `String`      |
|      | and it is equivalent to calling `nCopies` with two parameters |

###### Right currying

Similarily to left currying, it is possible to set the right-most parameter of a closure:

```groovy
def nCopies = { int n, String str -> str*n }    
def blah = nCopies.rcurry('bla')                
assert blah(2) == 'blabla'                      
assert blah(2) == nCopies(2, 'bla')             
```

|      | the `nCopies` closure defines two parameters                 |
| ---- | ------------------------------------------------------------ |
|      | `rcurry` will set the last parameter to `bla`, creating a new closure (function) which accepts a single `int` |
|      | so the new function call be called with only an `int`        |
|      | and it is equivalent to calling `nCopies` with two parameters |

###### Index based currying

In case a closure accepts more than 2 parameters, it is possible to set an arbitrary parameter using `ncurry`:

```groovy
def volume = { double l, double w, double h -> l*w*h }      
def fixedWidthVolume = volume.ncurry(1, 2d)                 
assert volume(3d, 2d, 4d) == fixedWidthVolume(3d, 4d)       
def fixedWidthAndHeight = volume.ncurry(1, 2d, 4d)          
assert volume(3d, 2d, 4d) == fixedWidthAndHeight(3d)        
```

|      | the `volume` function defines 3 parameters                   |
| ---- | ------------------------------------------------------------ |
|      | `ncurry` will set the second parameter (index = 1) to `2d`, creating a new volume function which accepts length and height |
|      | that function is equivalent to calling `volume` omitting the width |
|      | it is also possible to set multiple parameters, starting from the specified index |
|      | the resulting function accepts as many parameters as the initial one minus the number of parameters set by `ncurry` |

##### Memoization

Memoization allows the result of the call of a closure to be cached. It is interesting if the computation done by a function (closure) is slow, but you know that this function is going to be called often with the same arguments. A typical example is the Fibonacci suite. A naive implementation may look like this:

```groovy
def fib
fib = { long n -> n<2?n:fib(n-1)+fib(n-2) }
assert fib(15) == 610 // slow!
```

It is a naive implementation because 'fib' is often called recursively with the same arguments, leading to an exponential algorithm:

- computing `fib(15)` requires the result of `fib(14)` and `fib(13)`
- computing `fib(14)` requires the result of `fib(13)` and `fib(12)`

Since calls are recursive, you can already see that we will compute the same values again and again, although they could be cached. This naive implementation can be "fixed" by caching the result of calls using `memoize`:

```groovy
fib = { long n -> n<2?n:fib(n-1)+fib(n-2) }.memoize()
assert fib(25) == 75025 // fast!
```

|      | The cache works **using the actual values of the arguments**. This means that you should be very careful if you use memoization with something else than primitive or boxed primitive types. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The behavior of the cache can be tweaked using alternate methods:

- `memoizeAtMost` will generate a new closure which caches **at most** *n* values
- `memoizeAtLeast` will generate a new closure which caches **at least** *n* values
- `memoizeBetween` will generate a new closure which caches **at least** *n* values and **at most** *n* values

The cache used in all memoize variants is a LRU cache.

##### Composition

Closure composition corresponds to the concept of function composition, that is to say creating a new function by composing two or more functions (chaining calls), as illustrated in this example:

```groovy
def plus2  = { it + 2 }
def times3 = { it * 3 }

def times3plus2 = plus2 << times3
assert times3plus2(3) == 11
assert times3plus2(4) == plus2(times3(4))

def plus2times3 = times3 << plus2
assert plus2times3(3) == 15
assert plus2times3(5) == times3(plus2(5))

// reverse composition
assert times3plus2(3) == (times3 >> plus2)(3)
```

##### Trampoline

Recursive algorithms are often restricted by a physical limit: the maximum stack height. For example, if you call a method that recursively calls itself too deep, you will eventually receive a `StackOverflowException`.

An approach that helps in those situations is by using `Closure` and its trampoline capability.

Closures are wrapped in a `TrampolineClosure`. Upon calling, a trampolined `Closure` will call the original `Closure` waiting for its result. If the outcome of the call is another instance of a `TrampolineClosure`, created perhaps as a result to a call to the `trampoline()` method, the `Closure` will again be invoked. This repetitive invocation of returned trampolined Closures instances will continue until a value other than a trampolined `Closure` is returned. That value will become the final result of the trampoline. That way, calls are made serially, rather than filling the stack.

Here’s an example of the use of `trampoline()` to implement the factorial function:

```groovy
def factorial
factorial = { int n, def accu = 1G ->
    if (n < 2) return accu
    factorial.trampoline(n - 1, n * accu)
}
factorial = factorial.trampoline()

assert factorial(1)    == 1
assert factorial(3)    == 1 * 2 * 3
assert factorial(1000) // == 402387260.. plus another 2560 digits
```

##### Method pointers

It is often practical to be able to use a regular method as a closure. For example, you might want to use the currying abilities of a closure, but those are not available to normal methods. In Groovy, you can obtain a closure from any method with the [method pointer operator](https://docs.groovy-lang.org/latest/html/documentation/core-operators.html#method-pointer-operator).

### 1.6. Semantics

This chapter covers the semantics of the Groovy programming language.

#### 1.6.1. Statements

##### Variable definition

Variables can be defined using either their type (like `String`) or by using the keyword `def` (or `var`) followed by a variable name:

```groovy
String x
def y
var z
```

`def` and `var` act as a type placeholder, i.e. a replacement for the type name, when you do not want to give an explicit type. It could be that you don’t care about the type at compile time or are relying on type inference (with Groovy’s static nature). It is mandatory for variable definitions to have a type or placeholder. If left out, the type name will be deemed to refer to an existing variable (presumably declared earlier). For scripts, undeclared variables are assumed to come from the Script binding. In other cases, you will get a missing property (dynamic Groovy) or compile time error (static Groovy). If you think of `def` and `var` as an alias of `Object`, you will understand in an instant.

Variable definitions can provide an initial value, in which case it’s like having a declaration and assignment (which we cover next) all in one.

|      | Variable definition types can be refined by using generics, like in `List names`. To learn more about the generics support, please read the [generics section](https://docs.groovy-lang.org/latest/html/documentation/#generics). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Variable assignment

You can assign values to variables for later use. Try the following:

```groovy
x = 1
println x

x = new java.util.Date()
println x

x = -3.1499392
println x

x = false
println x

x = "Hi"
println x
```

###### Multiple assignment

Groovy supports multiple assignment, i.e. where multiple variables can be assigned at once, e.g.:

```groovy
def (a, b, c) = [10, 20, 'foo']
assert a == 10 && b == 20 && c == 'foo'
```

You can provide types as part of the declaration if you wish:

```groovy
def (int i, String j) = [10, 'foo']
assert i == 10 && j == 'foo'
```

As well as used when declaring variables it also applies to existing variables:

```groovy
def nums = [1, 3, 5]
def a, b, c
(a, b, c) = nums
assert a == 1 && b == 3 && c == 5
```

The syntax works for arrays as well as lists, as well as methods that return either of these:

```groovy
def (_, month, year) = "18th June 2009".split()
assert "In $month of $year" == 'In June of 2009'
```

###### Overflow and Underflow

If the left hand side has too many variables, excess ones are filled with null’s:

```groovy
def (a, b, c) = [1, 2]
assert a == 1 && b == 2 && c == null
```

If the right hand side has too many variables, the extra ones are ignored:

```groovy
def (a, b) = [1, 2, 3]
assert a == 1 && b == 2
```

###### Object destructuring with multiple assignment

In the section describing the various [Groovy operators](https://docs.groovy-lang.org/latest/html/documentation/#groovy-operators), the case of the [subscript operator](https://docs.groovy-lang.org/latest/html/documentation/#subscript-operator) has been covered, explaining how you can override the `getAt()`/`putAt()` method.

With this technique, we can combine multiple assignments and the subscript operator methods to implement *object destructuring*.

Consider the following immutable `Coordinates` class, containing a pair of longitude and latitude doubles, and notice our implementation of the `getAt()` method:

```groovy
@Immutable
class Coordinates {
    double latitude
    double longitude

    double getAt(int idx) {
        if (idx == 0) latitude
        else if (idx == 1) longitude
        else throw new Exception("Wrong coordinate index, use 0 or 1")
    }
}
```

Now let’s instantiate this class and destructure its longitude and latitude:

```groovy
def coordinates = new Coordinates(latitude: 43.23, longitude: 3.67) 

def (la, lo) = coordinates                                          

assert la == 43.23                                                  
assert lo == 3.67
```

|      | we create an instance of the `Coordinates` class             |
| ---- | ------------------------------------------------------------ |
|      | then, we use a multiple assignment to get the individual longitude and latitude values |
|      | and we can finally assert their values.                      |

##### Control structures

###### Conditional structures

if / else

Groovy supports the usual if - else syntax from Java

```groovy
def x = false
def y = false

if ( !x ) {
    x = true
}

assert x == true

if ( x ) {
    x = false
} else {
    y = true
}

assert x == y
```

Groovy also supports the normal Java "nested" if then else if syntax:

```groovy
if ( ... ) {
    ...
} else if (...) {
    ...
} else {
    ...
}
```

switch / case

The switch statement in Groovy is backwards compatible with Java code; so you can fall through cases sharing the same code for multiple matches.

One difference though is that the Groovy switch statement can handle any kind of switch value and different kinds of matching can be performed.

```groovy
def x = 1.23
def result = ""

switch ( x ) {
    case "foo":
        result = "found foo"
        // lets fall through

    case "bar":
        result += "bar"

    case [4, 5, 6, 'inList']:
        result = "list"
        break

    case 12..30:
        result = "range"
        break

    case Integer:
        result = "integer"
        break

    case Number:
        result = "number"
        break

    case ~/fo*/: // toString() representation of x matches the pattern?
        result = "foo regex"
        break

    case { it < 0 }: // or { x < 0 }
        result = "negative"
        break

    default:
        result = "default"
}

assert result == "number"
```

Switch supports the following kinds of comparisons:

- Class case values match if the switch value is an instance of the class
- Regular expression case values match if the `toString()` representation of the switch value matches the regex
- Collection case values match if the switch value is contained in the collection. This also includes ranges (since they are Lists)
- Closure case values match if the calling the closure returns a result which is true according to the [Groovy truth](https://docs.groovy-lang.org/latest/html/documentation/#Groovy-Truth)
- If none of the above are used then the case value matches if the case value equals the switch value

|      | When using a closure case value, the default `it` parameter is actually the switch value (in our example, variable `x`). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Looping structures

Classic for loop

Groovy supports the standard Java / C for loop:

```groovy
String message = ''
for (int i = 0; i < 5; i++) {
    message += 'Hi '
}
assert message == 'Hi Hi Hi Hi Hi '
```

Enhanced classic Java-style for loop

The more elaborate form of Java’s classic for loop with comma-separate expressions is now supported. Example:

```groovy
def facts = []
def count = 5
for (int fact = 1, i = 1; i <= count; i++, fact *= i) {
    facts << fact
}
assert facts == [1, 2, 6, 24, 120]
```

Multi-assignment in combination with for loop

Groovy has supported multi-assignment statements since Groovy 1.6:

```groovy
// multi-assignment with types
def (String x, int y) = ['foo', 42]
assert "$x $y" == 'foo 42'
```

These can now appear in for loops:

```groovy
// multi-assignment goes loopy
def baNums = []
for (def (String u, int v) = ['bar', 42]; v < 45; u++, v++) {
    baNums << "$u $v"
}
assert baNums == ['bar 42', 'bas 43', 'bat 44']
```

for in loop

The for loop in Groovy is much simpler and works with any kind of array, collection, Map, etc.

```groovy
// iterate over a range
def x = 0
for ( i in 0..9 ) {
    x += i
}
assert x == 45

// iterate over a list
x = 0
for ( i in [0, 1, 2, 3, 4] ) {
    x += i
}
assert x == 10

// iterate over an array
def array = (0..4).toArray()
x = 0
for ( i in array ) {
    x += i
}
assert x == 10

// iterate over a map
def map = ['abc':1, 'def':2, 'xyz':3]
x = 0
for ( e in map ) {
    x += e.value
}
assert x == 6

// iterate over values in a map
x = 0
for ( v in map.values() ) {
    x += v
}
assert x == 6

// iterate over the characters in a string
def text = "abc"
def list = []
for (c in text) {
    list.add(c)
}
assert list == ["a", "b", "c"]
```

|      | Groovy also supports the Java colon variation with colons: `for (char c : text) {}` |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

while loop

Groovy supports the usual while {…} loops like Java:

```groovy
def x = 0
def y = 5

while ( y-- > 0 ) {
    x++
}

assert x == 5
```

do/while loop

Java’s class do/while loop is now supported. Example:

```groovy
// classic Java-style do..while loop
def count = 5
def fact = 1
do {
    fact *= count--
} while(count > 1)
assert fact == 120
```

###### Exception handling

Exception handling is the same as Java.

###### try / catch / finally

You can specify a complete `try-catch-finally`, a `try-catch`, or a `try-finally` set of blocks.

|      | Braces are required around each block’s body. |
| ---- | --------------------------------------------- |
|      |                                               |

```groovy
try {
    'moo'.toLong()   // this will generate an exception
    assert false     // asserting that this point should never be reached
} catch ( e ) {
    assert e in NumberFormatException
}
```

We can put code within a 'finally' clause following a matching 'try' clause, so that regardless of whether the code in the 'try' clause throws an exception, the code in the finally clause will always execute:

```groovy
def z
try {
    def i = 7, j = 0
    try {
        def k = i / j
        assert false        //never reached due to Exception in previous line
    } finally {
        z = 'reached here'  //always executed even if Exception thrown
    }
} catch ( e ) {
    assert e in ArithmeticException
    assert z == 'reached here'
}
```

###### Multi-catch

With the multi catch block (since Groovy 2.0), we’re able to define several exceptions to be catch and treated by the same catch block:

```groovy
try {
    /* ... */
} catch ( IOException | NullPointerException e ) {
    /* one block to handle 2 exceptions */
}
```

###### ARM Try with resources

Groovy often provides better alternatives to Java 7’s `try`-with-resources statement for Automatic Resource Management (ARM). That syntax is now supported for Java programmers migrating to Groovy and still wanting to use the old style:

```groovy
class FromResource extends ByteArrayInputStream {
    @Override
    void close() throws IOException {
        super.close()
        println "FromResource closing"
    }

    FromResource(String input) {
        super(input.toLowerCase().bytes)
    }
}

class ToResource extends ByteArrayOutputStream {
    @Override
    void close() throws IOException {
        super.close()
        println "ToResource closing"
    }
}

def wrestle(s) {
    try (
            FromResource from = new FromResource(s)
            ToResource to = new ToResource()
    ) {
        to << from
        return to.toString()
    }
}

def wrestle2(s) {
    FromResource from = new FromResource(s)
    try (from; ToResource to = new ToResource()) { // Enhanced try-with-resources in Java 9+
        to << from
        return to.toString()
    }
}

assert wrestle("ARM was here!").contains('arm')
assert wrestle2("ARM was here!").contains('arm')
```

Which yields the following output:

```
ToResource closing
FromResource closing
ToResource closing
FromResource closing
```

##### Power assertion

Unlike Java with which Groovy shares the `assert` keyword, the latter in Groovy behaves very differently. First of all, an assertion in Groovy is always executed, independently of the `-ea` flag of the JVM. It makes this a first class choice for unit tests. The notion of "power asserts" is directly related to how the Groovy `assert` behaves.

A power assertion is decomposed into 3 parts:

```
assert [left expression] == [right expression] : (optional message)
```

The result of the assertion is very different from what you would get in Java. If the assertion is true, then nothing happens. If the assertion is false, then it provides a visual representation of the value of each sub-expressions of the expression being asserted. For example:

```groovy
assert 1+1 == 3
```

Will yield:

```
Caught: Assertion failed:

assert 1+1 == 3
        |  |
        2  false
```

Power asserts become very interesting when the expressions are more complex, like in the next example:

```groovy
def x = 2
def y = 7
def z = 5
def calc = { a,b -> a*b+1 }
assert calc(x,y) == [x,z].sum()
```

Which will print the value for each sub-expression:

```groovy
assert calc(x,y) == [x,z].sum()
       |    | |  |   | |  |
       15   2 7  |   2 5  7
                 false
```

In case you don’t want a pretty printed error message like above, you can fallback to a custom error message by changing the optional message part of the assertion, like in this example:

```groovy
def x = 2
def y = 7
def z = 5
def calc = { a,b -> a*b+1 }
assert calc(x,y) == z*z : 'Incorrect computation result'
```

Which will print the following error message:

```groovy
Incorrect computation result. Expression: (calc.call(x, y) == (z * z)). Values: z = 5, z = 5
```

##### Labeled statements

Any statement can be associated with a label. Labels do not impact the semantics of the code and can be used to make the code easier to read like in the following example:

```groovy
given:
    def x = 1
    def y = 2
when:
    def z = x+y
then:
    assert z == 3
```

Despite not changing the semantics of the labelled statement, it is possible to use labels in the `break` instruction as a target for jump, as in the next example. However, even if this is allowed, this coding style is in general considered a bad practice:

```groovy
for (int i=0;i<10;i++) {
    for (int j=0;j<i;j++) {
        println "j=$j"
        if (j == 5) {
            break exit
        }
    }
    exit: println "i=$i"
}
```

It is important to understand that by default labels have no impact on the semantics of the code, however they belong to the abstract syntax tree (AST) so it is possible for an AST transformation to use that information to perform transformations over the code, hence leading to different semantics. This is in particular what the [Spock Framework](http://spockframework.github.io/spock/docs/current/index.html) does to make testing easier.

#### 1.6.2. Expressions

(TBD)

##### GPath expressions

`GPath` is a path expression language integrated into Groovy which allows parts of nested structured data to be identified. In this sense, it has similar aims and scope as XPath does for XML. GPath is often used in the context of processing XML, but it really applies to any object graph. Where XPath uses a filesystem-like path notation, a tree hierarchy with parts separated by a slash `/`, GPath **use a dot-object notation** to perform object navigation.

As an example, you can specify a path to an object or element of interest:

- `a.b.c` → for XML, yields all the `c` elements inside `b` inside `a`
- `a.b.c` → for POJOs, yields the `c` properties for all the `b` properties of `a` (sort of like `a.getB().getC()` in JavaBeans)

In both cases, the GPath expression can be viewed as a query on an object graph. For POJOs, the object graph is most often built by the program being written through object instantiation and composition; for XML processing, the object graph is the result of `parsing` the XML text, most often with classes like XmlParser or XmlSlurper. See [Processing XML](https://docs.groovy-lang.org/latest/html/documentation/xml-userguide.html#Processing XML) for more in-depth details on consuming XML in Groovy.

|      | When querying the object graph generated from XmlParser or XmlSlurper, a GPath expression can refer to attributes defined on elements with the `@` notation:`a["@href"]` → map-like notation : the href attribute of all the a elements`a.'@href'` → property notation : an alternative way of expressing this`a.@href` → direct notation : yet another alternative way of expressing this |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Object navigation

Let’s see an example of a GPath expression on a simple *object graph*, the one obtained using java reflection. Suppose you are in a non-static method of a class having another method named `aMethodFoo`

```groovy
void aMethodFoo() { println "This is aMethodFoo." } 
```

the following GPath expression will get the name of that method:

```groovy
assert ['aMethodFoo'] == this.class.methods.name.grep(~/.*Foo/)
```

*More precisely*, the above GPath expression produces a list of String, each being the name of an existing method on `this` where that name ends with `Foo`.

Now, given the following methods also defined in that class:

```groovy
void aMethodBar() { println "This is aMethodBar." } 
void anotherFooMethod() { println "This is anotherFooMethod." } 
void aSecondMethodBar() { println "This is aSecondMethodBar." } 
```

then the following GPath expression will get the names of **(1)** and **(3)**, but not **(2)** or **(0)**:

```groovy
assert ['aMethodBar', 'aSecondMethodBar'] as Set == this.class.methods.name.grep(~/.*Bar/) as Set
```

###### Expression Deconstruction

We can decompose the expression `this.class.methods.name.grep(~/.*Bar/)` to get an idea of how a GPath is evaluated:

- `this.class`

  property accessor, equivalent to `this.getClass()` in Java, yields a `Class` object.

- `this.class.methods`

  property accessor, equivalent to `this.getClass().getMethods()`, yields an array of `Method` objects.

- `this.class.methods.name`

  apply a property accessor on each element of an array and produce a list of the results.

- `this.class.methods.name.grep(…)`

  call method `grep` on each element of the list yielded by `this.class.methods.name` and produce a list of the results.

|      | A sub-expression like `this.class.methods` yields an array because this is what calling `this.getClass().getMethods()` in Java would produce. `GPath` expressions do not have a convention where a `s` means a list or anything like that. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

One powerful feature of GPath expression is that property access on a collection is converted to a *property access on each element of the collection* with the results collected into a collection. Therefore, the expression `this.class.methods.name` could be expressed as follows in Java:

```java
List<String> methodNames = new ArrayList<String>();
for (Method method : this.getClass().getMethods()) {
   methodNames.add(method.getName());
}
return methodNames;
```

Array access notation can also be used in a GPath expression where a collection is present :

```groovy
assert 'aSecondMethodBar' == this.class.methods.name.grep(~/.*Bar/).sort()[1]
```

|      | array access are zero-based in GPath expressions |
| ---- | ------------------------------------------------ |
|      |                                                  |

###### GPath for XML navigation

Here is an example with a XML document and various form of GPath expressions:

```groovy
def xmlText = """
              | <root>
              |   <level>
              |      <sublevel id='1'>
              |        <keyVal>
              |          <key>mykey</key>
              |          <value>value 123</value>
              |        </keyVal>
              |      </sublevel>
              |      <sublevel id='2'>
              |        <keyVal>
              |          <key>anotherKey</key>
              |          <value>42</value>
              |        </keyVal>
              |        <keyVal>
              |          <key>mykey</key>
              |          <value>fizzbuzz</value>
              |        </keyVal>
              |      </sublevel>
              |   </level>
              | </root>
              """
def root = new XmlSlurper().parseText(xmlText.stripMargin())
assert root.level.size() == 1 
assert root.level.sublevel.size() == 2 
assert root.level.sublevel.findAll { it.@id == 1 }.size() == 1 
assert root.level.sublevel[1].keyVal[0].key.text() == 'anotherKey' 
```

|      | There is one `level` node under `root`                       |
| ---- | ------------------------------------------------------------ |
|      | There are two `sublevel` nodes under `root/level`            |
|      | There is one element `sublevel` having an attribute `id` with value `1` |
|      | Text value of `key` element of first `keyVal` element of second `sublevel` element under `root/level` is 'anotherKey' |

#### 1.6.3. Promotion and coercion

##### Number promotion

The rules of number promotion are specified in the section on [math operations](https://docs.groovy-lang.org/latest/html/documentation/#_math_operations).

##### Closure to type coercion

###### Assigning a closure to a SAM type

A SAM type is a type which defines a single abstract method. This includes:

Functional interfaces

```groovy
interface Predicate<T> {
    boolean accept(T obj)
}
```

Abstract classes with single abstract method

```groovy
abstract class Greeter {
    abstract String getName()
    void greet() {
        println "Hello, $name"
    }
}
```

Any closure can be converted into a SAM type using the `as` operator:

```groovy
Predicate filter = { it.contains 'G' } as Predicate
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' } as Greeter
greeter.greet()
```

However, the `as Type` expression is optional since Groovy 2.2.0. You can omit it and simply write:

```groovy
Predicate filter = { it.contains 'G' }
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' }
greeter.greet()
```

which means you are also allowed to use method pointers, as shown in the following example:

```groovy
boolean doFilter(String s) { s.contains('G') }

Predicate filter = this.&doFilter
assert filter.accept('Groovy') == true

Greeter greeter = GroovySystem.&getVersion
greeter.greet()
```

###### Calling a method accepting a SAM type with a closure

The second and probably more important use case for closure to SAM type coercion is calling a method which accepts a SAM type. Imagine the following method:

```groovy
public <T> List<T> filter(List<T> source, Predicate<T> predicate) {
    source.findAll { predicate.accept(it) }
}
```

Then you can call it with a closure, without having to create an explicit implementation of the interface:

```groovy
assert filter(['Java','Groovy'], { it.contains 'G'} as Predicate) == ['Groovy']
```

But since Groovy 2.2.0, you are also able to omit the explicit coercion and call the method as if it used a closure:

```groovy
assert filter(['Java','Groovy']) { it.contains 'G'} == ['Groovy']
```

As you can see, this has the advantage of letting you use the closure syntax for method calls, that is to say put the closure outside of the parenthesis, improving the readability of your code.

###### Closure to arbitrary type coercion

In addition to SAM types, a closure can be coerced to any type and in particular interfaces. Let’s define the following interface:

```groovy
interface FooBar {
    int foo()
    void bar()
}
```

You can coerce a closure into the interface using the `as` keyword:

```groovy
def impl = { println 'ok'; 123 } as FooBar
```

This produces a class for which all methods are implemented using the closure:

```groovy
assert impl.foo() == 123
impl.bar()
```

But it is also possible to coerce a closure to any class. For example, we can replace the `interface` that we defined with `class` without changing the assertions:

```groovy
class FooBar {
    int foo() { 1 }
    void bar() { println 'bar' }
}

def impl = { println 'ok'; 123 } as FooBar

assert impl.foo() == 123
impl.bar()
```

##### Map to type coercion

Usually using a single closure to implement an interface or a class with multiple methods is not the way to go. As an alternative, Groovy allows you to coerce a map into an interface or a class. In that case, keys of the map are interpreted as method names, while the values are the method implementation. The following example illustrates the coercion of a map into an `Iterator`:

```groovy
def map
map = [
  i: 10,
  hasNext: { map.i > 0 },
  next: { map.i-- },
]
def iter = map as Iterator
```

Of course this is a rather contrived example, but illustrates the concept. You only need to implement those methods that are actually called, but if a method is called that doesn’t exist in the map a `MissingMethodException` or an `UnsupportedOperationException` is thrown, depending on the arguments passed to the call, as in the following example:

```groovy
interface X {
    void f()
    void g(int n)
    void h(String s, int n)
}

x = [ f: {println "f called"} ] as X
x.f() // method exists
x.g() // MissingMethodException here
x.g(5) // UnsupportedOperationException here
```

The type of the exception depends on the call itself:

- `MissingMethodException` if the arguments of the call do not match those from the interface/class
- `UnsupportedOperationException` if the arguments of the call match one of the overloaded methods of the interface/class

##### String to enum coercion

Groovy allows transparent `String` (or `GString`) to enum values coercion. Imagine you define the following enum:

```groovy
enum State {
    up,
    down
}
```

then you can assign a string to the enum without having to use an explicit `as` coercion:

```groovy
State st = 'up'
assert st == State.up
```

It is also possible to use a `GString` as the value:

```groovy
def val = "up"
State st = "${val}"
assert st == State.up
```

However, this would throw a runtime error (`IllegalArgumentException`):

```groovy
State st = 'not an enum value'
```

Note that it is also possible to use implicit coercion in switch statements:

```groovy
State switchState(State st) {
    switch (st) {
        case 'up':
            return State.down // explicit constant
        case 'down':
            return 'up' // implicit coercion for return types
    }
}
```

in particular, see how the `case` use string constants. But if you call a method that uses an enum with a `String` argument, you still have to use an explicit `as` coercion:

```groovy
assert switchState('up' as State) == State.down
assert switchState(State.down) == State.up
```

##### Custom type coercion

It is possible for a class to define custom coercion strategies by implementing the `asType` method. Custom coercion is invoked using the `as` operator and is never implicit. As an example, imagine you defined two classes, `Polar` and `Cartesian`, like in the following example:

```groovy
class Polar {
    double r
    double phi
}
class Cartesian {
   double x
   double y
}
```

And that you want to convert from polar coordinates to cartesian coordinates. One way of doing this is to define the `asType` method in the `Polar` class:

```groovy
def asType(Class target) {
    if (Cartesian==target) {
        return new Cartesian(x: r*cos(phi), y: r*sin(phi))
    }
}
```

which allows you to use the `as` coercion operator:

```groovy
def sigma = 1E-16
def polar = new Polar(r:1.0,phi:PI/2)
def cartesian = polar as Cartesian
assert abs(cartesian.x-sigma) < sigma
```

Putting it all together, the `Polar` class looks like this:

```groovy
class Polar {
    double r
    double phi
    def asType(Class target) {
        if (Cartesian==target) {
            return new Cartesian(x: r*cos(phi), y: r*sin(phi))
        }
    }
}
```

but it is also possible to define `asType` outside of the `Polar` class, which can be practical if you want to define custom coercion strategies for "closed" classes or classes for which you don’t own the source code, for example using a metaclass:

```groovy
Polar.metaClass.asType = { Class target ->
    if (Cartesian==target) {
        return new Cartesian(x: r*cos(phi), y: r*sin(phi))
    }
}
```

##### Class literals vs variables and the as operator

Using the `as` keyword is only possible if you have a static reference to a class, like in the following code:

```groovy
interface Greeter {
    void greet()
}
def greeter = { println 'Hello, Groovy!' } as Greeter // Greeter is known statically
greeter.greet()
```

But what if you get the class by reflection, for example by calling `Class.forName`?

```groovy
Class clazz = Class.forName('Greeter')
```

Trying to use the reference to the class with the `as` keyword would fail:

```groovy
greeter = { println 'Hello, Groovy!' } as clazz
// throws:
// unable to resolve class clazz
// @ line 9, column 40.
//   greeter = { println 'Hello, Groovy!' } as clazz
```

It is failing because the `as` keyword only works with class literals. Instead, you need to call the `asType` method:

```groovy
greeter = { println 'Hello, Groovy!' }.asType(clazz)
greeter.greet()
```

#### 1.6.4. Optionality

##### Optional parentheses

Method calls can omit the parentheses if there is at least one parameter and there is no ambiguity:

```groovy
println 'Hello World'
def maximum = Math.max 5, 10
```

Parentheses are required for method calls without parameters or ambiguous method calls:

```groovy
println()
println(Math.max(5, 10))
```

##### Optional semicolons

In Groovy semicolons at the end of the line can be omitted, if the line contains only a single statement.

This means that:

```groovy
assert true;
```

can be more idiomatically written as:

```groovy
assert true
```

Multiple statements in a line require semicolons to separate them:

```groovy
boolean a = true; assert a
```

##### Optional return keyword

In Groovy, the last expression evaluated in the body of a method or a closure is returned. This means that the `return` keyword is optional.

```groovy
int add(int a, int b) {
    return a+b
}
assert add(1, 2) == 3
```

Can be shortened to:

```groovy
int add(int a, int b) {
    a+b
}
assert add(1, 2) == 3
```

##### Optional public keyword

By default, Groovy classes and methods are `public`. Therefore this class:

```groovy
public class Server {
    public String toString() { "a server" }
}
```

is identical to this class:

```groovy
class Server {
    String toString() { "a server" }
}
```

#### 1.6.5. The Groovy Truth

Groovy decides whether a expression is true or false by applying the rules given below.

##### Boolean expressions

True if the corresponding Boolean value is `true`.

```groovy
assert true
assert !false
```

##### Collections and Arrays

Non-empty Collections and arrays are true.

```groovy
assert [1, 2, 3]
assert ![]
```

##### Matchers

True if the Matcher has at least one match.

```groovy
assert ('a' =~ /a/)
assert !('a' =~ /b/)
```

##### Iterators and Enumerations

Iterators and Enumerations with further elements are coerced to true.

```groovy
assert [0].iterator()
assert ![].iterator()
Vector v = [0] as Vector
Enumeration enumeration = v.elements()
assert enumeration
enumeration.nextElement()
assert !enumeration
```

##### Maps

Non-empty Maps are evaluated to true.

```groovy
assert ['one' : 1]
assert ![:]
```

##### Strings

Non-empty Strings, GStrings and CharSequences are coerced to true.

```groovy
assert 'a'
assert !''
def nonEmpty = 'a'
assert "$nonEmpty"
def empty = ''
assert !"$empty"
```

##### Numbers

Non-zero numbers are true.

```groovy
assert 1
assert 3.5
assert !0
```

##### Object References

Non-null object references are coerced to true.

```groovy
assert new Object()
assert !null
```

##### Customizing the truth with asBoolean() methods

In order to customize whether groovy evaluates your object to `true` or `false` implement the `asBoolean()` method:

```groovy
class Color {
    String name

    boolean asBoolean(){
        name == 'green' ? true : false
    }
}
```

Groovy will call this method to coerce your object to a boolean value, e.g.:

```groovy
assert new Color(name: 'green')
assert !new Color(name: 'red')
```

#### 1.6.6. Typing

##### Optional typing

Optional typing is the idea that a program can work even if you don’t put an explicit type on a variable. Being a dynamic language, Groovy naturally implements that feature, for example when you declare a variable:

```groovy
String aString = 'foo'                      
assert aString.toUpperCase()                
```

|      | `foo` is declared using an explicit type, `String` |
| ---- | -------------------------------------------------- |
|      | we can call the `toUpperCase` method on a `String` |

Groovy will let you write this instead:

```groovy
def aString = 'foo'                         
assert aString.toUpperCase()                
```

|      | `foo` is declared using `def`                                |
| ---- | ------------------------------------------------------------ |
|      | we can still call the `toUpperCase` method, because the type of `aString` is resolved at runtime |

So it doesn’t matter that you use an explicit type here. It is in particular interesting when you combine this feature with [static type checking](https://docs.groovy-lang.org/latest/html/documentation/#static-type-checking), because the type checker performs type inference.

Likewise, Groovy doesn’t make it mandatory to declare the types of a parameter in a method:

```groovy
String concat(String a, String b) {
    a+b
}
assert concat('foo','bar') == 'foobar'
```

can be rewritten using `def` as both return type and parameter types, in order to take advantage of duck typing, as illustrated in this example:

```groovy
def concat(def a, def b) {                              
    a+b
}
assert concat('foo','bar') == 'foobar'                  
assert concat(1,2) == 3                                 
```

|      | both the return type and the parameter types use `def` |
| ---- | ------------------------------------------------------ |
|      | it makes it possible to use the method with `String`   |
|      | but also with `int` since the `plus` method is defined |

|      | Using the `def` keyword here is recommended to describe the intent of a method which is supposed to work on any type, but technically, we could use `Object` instead and the result would be the same: `def` is, in Groovy, strictly equivalent to using `Object`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Eventually, the type can be removed altogether from both the return type and the descriptor. But if you want to remove it from the return type, you then need to add an explicit modifier for the method, so that the compiler can make a difference between a method declaration and a method call, like illustrated in this example:

```groovy
private concat(a,b) {                                   
    a+b
}
assert concat('foo','bar') == 'foobar'                  
assert concat(1,2) == 3                                 
```

|      | if we want to omit the return type, an explicit modifier has to be set. |
| ---- | ------------------------------------------------------------ |
|      | it is still possible to use the method with `String`         |
|      | and also with `int`                                          |

|      | Omitting types is in general considered a bad practice in method parameters or method return types for public APIs. While using `def` in a local variable is not really a problem because the visibility of the variable is limited to the method itself, while set on a method parameter, `def` will be converted to `Object` in the method signature, making it difficult for users to know which is the expected type of the arguments. This means that you should limit this to cases where you are explicitly relying on duck typing. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Static type checking

By default, Groovy performs minimal type checking at compile time. Since it is primarily a dynamic language, most checks that a static compiler would normally do aren’t possible at compile time. A method added via runtime metaprogramming might alter a class or object’s runtime behavior. Let’s illustrate why in the following example:

```groovy
class Person {                                                          
    String firstName
    String lastName
}
def p = new Person(firstName: 'Raymond', lastName: 'Devos')             
assert p.formattedName == 'Raymond Devos'                               
```

|      | the `Person` class only defines two properties, `firstName` and `lastName` |
| ---- | ------------------------------------------------------------ |
|      | we can create an instance of Person                          |
|      | and call a method named `formattedName`                      |

It is quite common in dynamic languages for code such as the above example not to throw any error. How can this be? In Java, this would typically fail at compile time. However, in Groovy, it will not fail at compile time, and if coded correctly, will also not fail at runtime. In fact, to make this work at runtime, **one** possibility is to rely on runtime metaprogramming. So just adding this line after the declaration of the `Person` class is enough:

```groovy
Person.metaClass.getFormattedName = { "$delegate.firstName $delegate.lastName" }
```

This means that in general, in Groovy, you can’t make any assumption about the type of an object beyond its declaration type, and even if you know it, you can’t determine at compile time what method will be called, or which property will be retrieved. It has a lot of interest, going from writing DSLs to testing, which is discussed in other sections of this manual.

However, if your program doesn’t rely on dynamic features and that you come from the static world (in particular, from a Java mindset), not catching such "errors" at compile time can be surprising. As we have seen in the previous example, the compiler cannot be sure this is an error. To make it aware that it is, you have to explicitly instruct the compiler that you are switching to a type checked mode. This can be done by annotating a class or a method with `@groovy.transform.TypeChecked`.

When type checking is activated, the compiler performs much more work:

- type inference is activated, meaning that even if you use `def` on a local variable for example, the type checker will be able to infer the type of the variable from the assignments
- method calls are resolved at compile time, meaning that if a method is not declared on a class, the compiler will throw an error
- in general, all the compile time errors that you are used to find in a static language will appear: method not found, property not found, incompatible types for method calls, number precision errors, …

In this section, we will describe the behavior of the type checker in various situations and explain the limits of using `@TypeChecked` on your code.

###### The `@TypeChecked` annotation

Activating type checking at compile time

The `groovy.transform.TypeChecked` annotation enables type checking. It can be placed on a class:

```groovy
@groovy.transform.TypeChecked
class Calculator {
    int sum(int x, int y) { x+y }
}
```

Or on a method:

```groovy
class Calculator {
    @groovy.transform.TypeChecked
    int sum(int x, int y) { x+y }
}
```

In the first case, all methods, properties, fields, inner classes, … of the annotated class will be type checked, whereas in the second case, only the method and potential closures or anonymous inner classes that it contains will be type checked.

Skipping sections

The scope of type checking can be restricted. For example, if a class is type checked, you can instruct the type checker to skip a method by annotating it with `@TypeChecked(TypeCheckingMode.SKIP)`:

```groovy
import groovy.transform.TypeChecked
import groovy.transform.TypeCheckingMode

@TypeChecked                                        
class GreetingService {
    String greeting() {                             
        doGreet()
    }

    @TypeChecked(TypeCheckingMode.SKIP)             
    private String doGreet() {
        def b = new SentenceBuilder()
        b.Hello.my.name.is.John                     
        b
    }
}
def s = new GreetingService()
assert s.greeting() == 'Hello my name is John'
```

|      | the `GreetingService` class is marked as type checked        |
| ---- | ------------------------------------------------------------ |
|      | so the `greeting` method is automatically type checked       |
|      | but `doGreet` is marked with `SKIP`                          |
|      | the type checker doesn’t complain about missing properties here |

In the previous example, `SentenceBuilder` relies on dynamic code. There’s no real `Hello` method or property, so the type checker would normally complain and compilation would fail. Since the method that uses the builder is marked with `TypeCheckingMode.SKIP`, type checking is *skipped* for this method, so the code will compile, even if the rest of the class is type checked.

The following sections describe the semantics of type checking in Groovy.

###### Type checking assignments

An object `o` of type `A` can be assigned to a variable of type `T` if and only if:

- `T` equals `A`

  ```groovy
  Date now = new Date()
  ```

- *or* `T` is one of `String`, `boolean`, `Boolean` or `Class`

  ```groovy
  String s = new Date() // implicit call to toString
  Boolean boxed = 'some string'       // Groovy truth
  boolean prim = 'some string'        // Groovy truth
  Class clazz = 'java.lang.String'    // class coercion
  ```

- *or* `o` is null and `T` is not a primitive type

  ```groovy
  String s = null         // passes
  int i = null            // fails
  ```

- *or* `T` is an array and `A` is an array and the component type of `A` is assignable to the component type of `T`

  ```groovy
  int[] i = new int[4]        // passes
  int[] i = new String[4]     // fails
  ```

- *or* `T` is an array and `A` is a list and the component type of `A` is assignable to the component type of `T`

  ```groovy
  int[] i = [1,2,3]               // passes
  int[] i = [1,2, new Date()]     // fails
  ```

- *or* `T` is a superclass of `A`

  ```groovy
  AbstractList list = new ArrayList()     // passes
  LinkedList list = new ArrayList()       // fails
  ```

- *or* `T` is an interface implemented by `A`

  ```groovy
  List list = new ArrayList()             // passes
  RandomAccess list = new LinkedList()    // fails
  ```

- *or* `T` or `A` are a primitive type and their boxed types are assignable

  ```groovy
  int i = 0
  Integer bi = 1
  int x = new Integer(123)
  double d = new Float(5f)
  ```

- *or* `T` extends `groovy.lang.Closure` and `A` is a SAM-type (single abstract method type)

  ```groovy
  Runnable r = { println 'Hello' }
  interface SAMType {
      int doSomething()
  }
  SAMType sam = { 123 }
  assert sam.doSomething() == 123
  abstract class AbstractSAM {
      int calc() { 2* value() }
      abstract int value()
  }
  AbstractSAM c = { 123 }
  assert c.calc() == 246
  ```

- *or* `T` and `A` derive from `java.lang.Number` and conform to the following table

| T       | A                                                            | Examples                                                     |
| :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Double  | Any but BigDecimal or BigInteger                             | `Double d1 = 4d Double d2 = 4f Double d3 = 4l Double d4 = 4i Double d5 = (short) 4 Double d6 = (byte) 4` |
| Float   | Any type but BigDecimal, BigInteger or Double                | `Float f1 = 4f Float f2 = 4l Float f3 = 4i Float f4 = (short) 4 Float f5 = (byte) 4` |
| Long    | Any type but BigDecimal, BigInteger, Double or Float         | `Long l1 = 4l Long l2 = 4i Long l3 = (short) 4 Long l4 = (byte) 4` |
| Integer | Any type but BigDecimal, BigInteger, Double, Float or Long   | `Integer i1 = 4i Integer i2 = (short) 4 Integer i3 = (byte) 4` |
| Short   | Any type but BigDecimal, BigInteger, Double, Float, Long or Integer | `Short s1 = (short) 4 Short s2 = (byte) 4`                   |
| Byte    | Byte                                                         | `Byte b1 = (byte) 4`                                         |

###### List and map constructors

In addition to the assignment rules above, if an assignment is deemed invalid, in type checked mode, a *list* literal or a *map* literal `A` can be assigned to a variable of type `T` if:

- the assignment is a variable declaration and `A` is a list literal and `T` has a constructor whose parameters match the types of the elements in the list literal
- the assignment is a variable declaration and `A` is a map literal and `T` has a no-arg constructor and a property for each of the map keys

For example, instead of writing:

```groovy
@groovy.transform.TupleConstructor
class Person {
    String firstName
    String lastName
}
Person classic = new Person('Ada','Lovelace')
```

You can use a "list constructor":

```groovy
Person list = ['Ada','Lovelace']
```

or a "map constructor":

```groovy
Person map = [firstName:'Ada', lastName:'Lovelace']
```

If you use a map constructor, additional checks are done on the keys of the map to check if a property of the same name is defined. For example, the following will fail at compile time:

```groovy
@groovy.transform.TupleConstructor
class Person {
    String firstName
    String lastName
}
Person map = [firstName:'Ada', lastName:'Lovelace', age: 24]     
```

|      | The type checker will throw an error `No such property: age for class: Person` at compile time |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Method resolution

In type checked mode, methods are resolved at compile time. Resolution works by name and arguments. The return type is irrelevant to method selection. Types of arguments are matched against the types of the parameters following those rules:

An argument `o` of type `A` can be used for a parameter of type `T` if and only if:

- `T` equals `A`

  ```groovy
  int sum(int x, int y) {
      x+y
  }
  assert sum(3,4) == 7
  ```

- *or* `T` is a `String` and `A` is a `GString`

  ```groovy
  String format(String str) {
      "Result: $str"
  }
  assert format("${3+4}") == "Result: 7"
  ```

- *or* `o` is null and `T` is not a primitive type

  ```groovy
  String format(int value) {
      "Result: $value"
  }
  assert format(7) == "Result: 7"
  format(null)           // fails
  ```

- *or* `T` is an array and `A` is an array and the component type of `A` is assignable to the component type of `T`

  ```groovy
  String format(String[] values) {
      "Result: ${values.join(' ')}"
  }
  assert format(['a','b'] as String[]) == "Result: a b"
  format([1,2] as int[])              // fails
  ```

- *or* `T` is a superclass of `A`

  ```groovy
  String format(AbstractList list) {
      list.join(',')
  }
  format(new ArrayList())              // passes
  String format(LinkedList list) {
      list.join(',')
  }
  format(new ArrayList())              // fails
  ```

- *or* `T` is an interface implemented by `A`

  ```groovy
  String format(List list) {
      list.join(',')
  }
  format(new ArrayList())                  // passes
  String format(RandomAccess list) {
      'foo'
  }
  format(new LinkedList())                 // fails
  ```

- *or* `T` or `A` are a primitive type and their boxed types are assignable

  ```groovy
  int sum(int x, Integer y) {
      x+y
  }
  assert sum(3, new Integer(4)) == 7
  assert sum(new Integer(3), 4) == 7
  assert sum(new Integer(3), new Integer(4)) == 7
  assert sum(new Integer(3), 4) == 7
  ```

- *or* `T` extends `groovy.lang.Closure` and `A` is a SAM-type (single abstract method type)

  ```groovy
  interface SAMType {
      int doSomething()
  }
  int twice(SAMType sam) { 2*sam.doSomething() }
  assert twice { 123 } == 246
  abstract class AbstractSAM {
      int calc() { 2* value() }
      abstract int value()
  }
  int eightTimes(AbstractSAM sam) { 4*sam.calc() }
  assert eightTimes { 123 } == 984
  ```

- *or* `T` and `A` derive from `java.lang.Number` and conform to the same rules as [assignment of numbers](https://docs.groovy-lang.org/latest/html/documentation/#number-assignment)

If a method with the appropriate name and arguments is not found at compile time, an error is thrown. The difference with "normal" Groovy is illustrated in the following example:

```groovy
class MyService {
    void doSomething() {
        printLine 'Do something'            
    }
}
```

|      | `printLine` is an error, but since we’re in a dynamic mode, the error is not caught at compile time |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The example above shows a class that Groovy will be able to compile. However, if you try to create an instance of `MyService` and call the `doSomething` method, then it will fail **at runtime**, because `printLine` doesn’t exist. Of course, we already showed how Groovy could make this a perfectly valid call, for example by catching `MethodMissingException` or implementing a custom meta-class, but if you know you’re not in such a case, `@TypeChecked` comes handy:

```groovy
@groovy.transform.TypeChecked
class MyService {
    void doSomething() {
        printLine 'Do something'            
    }
}
```

|      | `printLine` is this time a compile-time error |
| ---- | --------------------------------------------- |
|      |                                               |

Just adding `@TypeChecked` will trigger compile time method resolution. The type checker will try to find a method `printLine` accepting a `String` on the `MyService` class, but cannot find one. It will fail compilation with the following message:

```
Cannot find matching method MyService#printLine(java.lang.String)
```

|      | It is important to understand the logic behind the type checker: it is a compile-time check, so by definition, the type checker is not aware of any kind of **runtime** metaprogramming that you do. This means that code which is perfectly valid without `@TypeChecked` will **not** compile anymore if you activate type checking. This is in particular true if you think of duck typing: |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```groovy
class Duck {
    void quack() {              
        println 'Quack!'
    }
}
class QuackingBird {
    void quack() {              
        println 'Quack!'
    }
}
@groovy.transform.TypeChecked
void accept(quacker) {
    quacker.quack()             
}
accept(new Duck())              
```

|      | we define a `Duck` class which defines a `quack` method      |
| ---- | ------------------------------------------------------------ |
|      | we define another `QuackingBird` class which also defines a `quack` method |
|      | `quacker` is loosely typed, so since the method is `@TypeChecked`, we will obtain a compile-time error |
|      | even if in non type-checked Groovy, this would have passed   |

There are possible workarounds, like introducing an interface, but basically, by activating type checking, you gain type safety but you loose some features of the language. Hopefully, Groovy introduces some features like flow typing to reduce the gap between type-checked and non type-checked Groovy.

###### Type inference

Principles

When code is annotated with `@TypeChecked`, the compiler performs type inference. It doesn’t simply rely on static types, but also uses various techniques to infer the types of variables, return types, literals, … so that the code remains as clean as possible even if you activate the type checker.

The simplest example is inferring the type of a variable:

```groovy
def message = 'Welcome to Groovy!'              
println message.toUpperCase()                   
println message.upper() // compile time error   
```

|      | a variable is declared using the `def` keyword       |
| ---- | ---------------------------------------------------- |
|      | calling `toUpperCase` is allowed by the type checker |
|      | calling `upper` will fail at compile time            |

The reason the call to `toUpperCase` works is because the type of `message` was *inferred* as being a `String`.

Variables vs fields in type inference

It is worth noting that although the compiler performs type inference on local variables, it does **not** perform any kind of type inference on fields, always falling back to the **declared type** of a field. To illustrate this, let’s take a look at this example:

```groovy
class SomeClass {
    def someUntypedField                                                                
    String someTypedField                                                               

    void someMethod() {
        someUntypedField = '123'                                                        
        someUntypedField = someUntypedField.toUpperCase()  // compile-time error        
    }

    void someSafeMethod() {
        someTypedField = '123'                                                          
        someTypedField = someTypedField.toUpperCase()                                   
    }

    void someMethodUsingLocalVariable() {
        def localVariable = '123'                                                       
        someUntypedField = localVariable.toUpperCase()                                  
    }
}
```

|      | `someUntypedField` uses `def` as a declaration type          |
| ---- | ------------------------------------------------------------ |
|      | `someTypedField` uses `String` as a declaration type         |
|      | we can assign **anything** to `someUntypedField`             |
|      | yet calling `toUpperCase` fails at compile time because the field is not typed properly |
|      | we can assign a `String` to a field of type `String`         |
|      | and this time `toUpperCase` is allowed                       |
|      | if we assign a `String` to a local variable                  |
|      | then calling `toUpperCase` is allowed on the local variable  |

Why such a difference? The reason is *thread safety*. At compile time, we can’t make **any** guarantee about the type of a field. Any thread can access any field at any time and between the moment a field is assigned a variable of some type in a method and the time is is used the line after, another thread may have changed the contents of the field. This is not the case for local variables: we know if they "escape" or not, so we can make sure that the type of a variable is constant (or not) over time. Note that even if a field is final, the JVM makes no guarantee about it, so the type checker doesn’t behave differently if a field is final or not.

|      | This is one of the reasons why we recommend to use **typed** fields. While using `def` for local variables is perfectly fine thanks to type inference, this is not the case for fields, which also belong to the public API of a class, hence the type is important. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Collection literal type inference

Groovy provides a syntax for various type literals. There are three native collection literals in Groovy:

- lists, using the `[]` literal
- maps, using the `[:]` literal
- ranges, using `from..to` (inclusive) and `from.. (exclusive)

The inferred type of a literal depends on the elements of the literal, as illustrated in the following table:

| Literal                                                      | Inferred type                                                |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `def list = []`                                              | `java.util.List`                                             |
| `def list = ['foo','bar']`                                   | `java.util.List`                                             |
| `def list = ["${foo}","${bar}"]`                             | `java.util.List` be careful, a `GString` is **not** a `String`! |
| `def map = [:]`                                              | `java.util.LinkedHashMap`                                    |
| `def map1 = [someKey: 'someValue'] def map2 = ['someKey': 'someValue']` | `java.util.LinkedHashMap`                                    |
| `def map = ["${someKey}": 'someValue']`                      | `java.util.LinkedHashMap` be careful, the key is a `GString`! |
| `def intRange = (0..10)`                                     | `groovy.lang.IntRange`                                       |
| `def charRange = ('a'..'z')`                                 | `groovy.lang.Range` : uses the type of the bounds to infer the component type of the range |

As you can see, with the noticeable exception of the `IntRange`, the inferred type makes use of generics types to describe the contents of a collection. In case the collection contains elements of different types, the type checker still performs type inference of the components, but uses the notion of [least upper bound](https://docs.groovy-lang.org/latest/html/documentation/#section-lub).

Least upper bound

In Groovy, the *least upper bound* of two types `A` and `B` is defined as a type which:

- superclass corresponds to the common super class of `A` and `B`
- interfaces correspond to the interfaces implemented by both `A` and `B`
- if `A` or `B` is a primitive type and that `A` isn’t equal to `B`, the least upper bound of `A` and `B` is the least upper bound of their wrapper types

If `A` and `B` only have one (1) interface in common and that their common superclass is `Object`, then the LUB of both is the common interface.

The least upper bound represents the minimal type to which both `A` and `B` can be assigned. So for example, if `A` and `B` are both `String`, then the LUB (least upper bound) of both is also `String`.

```groovy
class Top {}
class Bottom1 extends Top {}
class Bottom2 extends Top {}

assert leastUpperBound(String, String) == String                    
assert leastUpperBound(ArrayList, LinkedList) == AbstractList       
assert leastUpperBound(ArrayList, List) == List                     
assert leastUpperBound(List, List) == List                          
assert leastUpperBound(Bottom1, Bottom2) == Top                     
assert leastUpperBound(List, Serializable) == Object                
```

|      | the LUB of `String` and `String` is `String`                 |
| ---- | ------------------------------------------------------------ |
|      | the LUB of `ArrayList` and `LinkedList` is their common super type, `AbstractList` |
|      | the LUB of `ArrayList` and `List` is their only common interface, `List` |
|      | the LUB of two identical interfaces is the interface itself  |
|      | the LUB of `Bottom1` and `Bottom2` is their superclass `Top` |
|      | the LUB of two types which have nothing in common is `Object` |

In those examples, the LUB is always representable as a normal, JVM supported, type. But Groovy internally represents the LUB as a type which can be more complex, and that you wouldn’t be able to use to define a variable for example. To illustrate this, let’s continue with this example:

```groovy
interface Foo {}
class Top {}
class Bottom extends Top implements Serializable, Foo {}
class SerializableFooImpl implements Serializable, Foo {}
```

What is the least upper bound of `Bottom` and `SerializableFooImpl`? They don’t have a common super class (apart from `Object`), but they do share 2 interfaces (`Serializable` and `Foo`), so their least upper bound is a type which represents the union of two interfaces (`Serializable` and `Foo`). This type cannot be defined in the source code, yet Groovy knows about it.

In the context of collection type inference (and generic type inference in general), this becomes handy, because the type of the components is inferred as the least upper bound. We can illustrate why this is important in the following example:

```groovy
interface Greeter { void greet() }                  
interface Salute { void salute() }                  

class A implements Greeter, Salute {                
    void greet() { println "Hello, I'm A!" }
    void salute() { println "Bye from A!" }
}
class B implements Greeter, Salute {                
    void greet() { println "Hello, I'm B!" }
    void salute() { println "Bye from B!" }
    void exit() { println 'No way!' }               
}
def list = [new A(), new B()]                       
list.each {
    it.greet()                                      
    it.salute()                                     
    it.exit()                                       
}
```

|      | the `Greeter` interface defines a single method, `greet`     |
| ---- | ------------------------------------------------------------ |
|      | the `Salute` interface defines a single method, `salute`     |
|      | class `A` implements both `Greeter` and `Salute` but there’s no explicit interface extending both |
|      | same for `B`                                                 |
|      | but `B` defines an additional `exit` method                  |
|      | the type of `list` is inferred as "list of the LUB of `A` and `B`" |
|      | so it is possible to call `greet` which is defined on both `A` and `B` through the `Greeter` interface |
|      | and it is possible to call `salute` which is defined on both `A` and `B` through the `Salute` interface |
|      | yet calling `exit` is a compile time error because it doesn’t belong to the LUB of `A` and `B` (only defined in `B`) |

The error message will look like:

```
[Static type checking] - Cannot find matching method Greeter or Salute#exit()
```

which indicates that the `exit` method is neither defines on `Greeter` nor `Salute`, which are the two interfaces defined in the least upper bound of `A` and `B`.

instanceof inference

In normal, non type checked, Groovy, you can write things like:

```groovy
class Greeter {
    String greeting() { 'Hello' }
}

void doSomething(def o) {
    if (o instanceof Greeter) {     
        println o.greeting()        
    }
}

doSomething(new Greeter())
```

|      | guard the method call with an `instanceof` check |
| ---- | ------------------------------------------------ |
|      | make the call                                    |

The method call works because of dynamic dispatch (the method is selected at runtime). The equivalent code in Java would require to cast `o` to a `Greeter` before calling the `greeting` method, because methods are selected at compile time:

```groovy
if (o instanceof Greeter) {
    System.out.println(((Greeter)o).greeting());
}
```

However, in Groovy, even if you add `@TypeChecked` (and thus activate type checking) on the `doSomething` method, the cast is **not** necessary. The compiler embeds *instanceof* inference that makes the cast optional.

Flow typing

Flow typing is an important concept of Groovy in type checked mode and an extension of type inference. The idea is that the compiler is capable of inferring the type of variables in the flow of the code, not just at initialization:

```groovy
@groovy.transform.TypeChecked
void flowTyping() {
    def o = 'foo'                       
    o = o.toUpperCase()                 
    o = 9d                              
    o = Math.sqrt(o)                    
}
```

|      | first, `o` is declared using `def` and assigned a `String`   |
| ---- | ------------------------------------------------------------ |
|      | the compiler inferred that `o` is a `String`, so calling `toUpperCase` is allowed |
|      | `o` is reassigned with a `double`                            |
|      | calling `Math.sqrt` passes compilation because the compiler knows that at this point, `o` is a `double` |

So the type checker is *aware* of the fact that the concrete type of a variable is different over time. In particular, if you replace the last assignment with:

```groovy
o = 9d
o = o.toUpperCase()
```

The type checker will now fail at compile time, because it knows that `o` is a `double` when `toUpperCase` is called, so it’s a type error.

It is important to understand that it is not the fact of declaring a variable with `def` that triggers type inference. Flow typing works for **any** variable of any type. Declaring a variable with an explicit type only constrains what you can assign to the variable:

```groovy
@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List list = ['a','b','c']           
    list = list*.toUpperCase()          
    list = 'foo'                        
}
```

|      | `list` is declared as an unchecked `List` and assigned a list literal of `String`s |
| ---- | ------------------------------------------------------------ |
|      | this line passes compilation because of flow typing: the type checker knows that `list` is at this point a `List` |
|      | but you can’t assign a `String` to a `List` so this is a type checking error |

You can also note that even if the variable is declared **without** generics information, the type checker knows what is the component type. Therefore, such code would fail compilation:

```groovy
@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List list = ['a','b','c']           
    list.add(1)                         
}
```

|      | `list` is inferred as `List`                           |
| ---- | ------------------------------------------------------ |
|      | so adding an `int` to a `List` is a compile-time error |

Fixing this requires adding an explicit generic type to the declaration:

```groovy
@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List<? extends Serializable> list = []                      
    list.addAll(['a','b','c'])                                  
    list.add(1)                                                 
}
```

|      | `list` declared as `List` and initialized with an empty list |
| ---- | ------------------------------------------------------------ |
|      | elements added to the list conform to the declaration type of the list |
|      | so adding an `int` to a `List` is allowed                    |

Flow typing has been introduced to reduce the difference in semantics between classic and static Groovy. In particular, consider the behavior of this code in Java:

```java
public Integer compute(String str) {
    return str.length();
}
public String compute(Object o) {
    return "Nope";
}
// ...
Object string = "Some string";          
Object result = compute(string);        
System.out.println(result);             
```

|      | `o` is declared as an `Object` and assigned a `String` |
| ---- | ------------------------------------------------------ |
|      | we call the `compute` method with `o`                  |
|      | and print the result                                   |

In Java, this code will output `Nope`, because method selection is done at compile time and based on the **declared** types. So even if `o` is a `String` at runtime, it is still the `Object` version which is called, because `o` has been declared as an `Object`. To be short, in Java, declared types are most important, be it variable types, parameter types or return types.

In Groovy, we could write:

```groovy
int compute(String string) { string.length() }
String compute(Object o) { "Nope" }
Object o = 'string'
def result = compute(o)
println result
```

But this time, it will return `6`, because the method which is chosen is chosen **at runtime**, based on the *actual* argument types. So at runtime, `o` is a `String` so the `String` variant is used. Note that this behavior has nothing to do with type checking, it’s the way Groovy works in general: dynamic dispatch.

In type checked Groovy, we want to make sure the type checker selects the same method **at compile time**, that the runtime would choose. It is not possible in general, due to the semantics of the language, but we can make things better with flow typing. With flow typing, `o` is *inferred* as a `String` when the `compute` method is called, so the version which takes a `String` and returns an `int` is chosen. This means that we can infer the return type of the method to be an `int`, and not a `String`. This is important for subsequent calls and type safety.

So in type checked Groovy, flow typing is a very important concept, which also implies that if `@TypeChecked` is applied, methods are selected based on the *inferred types* of the arguments, not on the declared types. This doesn’t ensure 100% type safety, because the type checker *may* select a wrong method, but it ensures the closest semantics to dynamic Groovy.

Advanced type inference

A combination of [flow typing](https://docs.groovy-lang.org/latest/html/documentation/#section-flow-typing) and [least upper bound inference](https://docs.groovy-lang.org/latest/html/documentation/#section-lub) is used to perform advanced type inference and ensure type safety in multiple situations. In particular, program control structures are likely to alter the inferred type of a variable:

```groovy
class Top {
   void methodFromTop() {}
}
class Bottom extends Top {
   void methodFromBottom() {}
}
def o
if (someCondition) {
    o = new Top()                               
} else {
    o = new Bottom()                            
}
o.methodFromTop()                               
o.methodFromBottom()  // compilation error      
```

|      | if `someCondition` is true, `o` is assigned a `Top`          |
| ---- | ------------------------------------------------------------ |
|      | if `someCondition` is false, `o` is assigned a `Bottom`      |
|      | calling `methodFromTop` is safe                              |
|      | but calling `methodFromBottom` is not, so it’s a compile time error |

When the type checker visits an `if/else` control structure, it checks all variables which are assigned in `if/else` branches and computes the [least upper bound](https://docs.groovy-lang.org/latest/html/documentation/#section-lub) of all assignments. This type is the type of the inferred variable after the `if/else` block, so in this example, `o` is assigned a `Top` in the `if` branch and a `Bottom` in the `else` branch. The [LUB](https://docs.groovy-lang.org/latest/html/documentation/#section-lub) of those is a `Top`, so after the conditional branches, the compiler infers `o` as being a `Top`. Calling `methodFromTop` will therefore be allowed, but not `methodFromBottom`.

The same reasoning exists with closures and in particular closure shared variables. A closure shared variable is a variable which is defined outside of a closure, but used inside a closure, as in this example:

```groovy
def text = 'Hello, world!'                          
def closure = {
    println text                                    
}
```

|      | a variable named `text` is declared                          |
| ---- | ------------------------------------------------------------ |
|      | `text` is used from inside a closure. It is a *closure shared variable*. |

Groovy allows developers to use those variables without requiring them to be final. This means that a closure shared variable can be reassigned inside a closure:

```groovy
String result
doSomething { String it ->
    result = "Result: $it"
}
result = result?.toUpperCase()
```

The problem is that a closure is an independent block of code that can be executed (or not) at **any** time. In particular, `doSomething` may be asynchronous, for example. This means that the body of a closure doesn’t belong to the main control flow. For that reason, the type checker also computes, for each closure shared variable, the [LUB](https://docs.groovy-lang.org/latest/html/documentation/#section-lub) of all assignments of the variable, and will use that `LUB` as the inferred type outside of the scope of the closure, like in this example:

```groovy
class Top {
   void methodFromTop() {}
}
class Bottom extends Top {
   void methodFromBottom() {}
}
def o = new Top()                               
Thread.start {
    o = new Bottom()                            
}
o.methodFromTop()                               
o.methodFromBottom()  // compilation error      
```

|      | a closure-shared variable is first assigned a `Top` |
| ---- | --------------------------------------------------- |
|      | inside the closure, it is assigned a `Bottom`       |
|      | `methodFromTop` is allowed                          |
|      | `methodFromBottom` is a compilation error           |

Here, it is clear that when `methodFromBottom` is called, there’s no guarantee, at compile-time or runtime that the type of `o` will *effectively* be a `Bottom`. There are chances that it will be, but we can’t make sure, because it’s asynchronous. So the type checker will only allow calls on the [least upper bound](https://docs.groovy-lang.org/latest/html/documentation/#section-lub), which is here a `Top`.

###### Closures and type inference

The type checker performs special inference on closures, resulting on additional checks on one side and improved fluency on the other side.

Return type inference

The first thing that the type checker is capable of doing is inferring the *return type* of a closure. This is simply illustrated in the following example:

```groovy
@groovy.transform.TypeChecked
int testClosureReturnTypeInference(String arg) {
    def cl = { "Arg: $arg" }                                
    def val = cl()                                          

    val.length()                                            
}
```

|      | a closure is defined, and it returns a string (more precisely a `GString`) |
| ---- | ------------------------------------------------------------ |
|      | we call the closure and assign the result to a variable      |
|      | the type checker inferred that the closure would return a string, so calling `length()` is allowed |

As you can see, unlike a method which declares its return type explicitly, there’s no need to declare the return type of a closure: its type is inferred from the body of the closure.

Closures vs methods

It’s worth noting that return type inference is only applicable to closures. While the type checker could do the same on a method, it is in practice not desirable: *in general*, methods can be overridden and it is not statically possible to make sure that the method which is called is not an overridden version. So flow typing would actually think that a method returns something, while in reality, it could return something else, like illustrated in the following example:

```groovy
@TypeChecked
class A {
    def compute() { 'some string' }             
    def computeFully() {
        compute().toUpperCase()                 
    }
}
@TypeChecked
class B extends A {
    def compute() { 123 }                       
}
```

|      | class `A` defines a method `compute` which effectively returns a `String` |
| ---- | ------------------------------------------------------------ |
|      | this will fail compilation because the return type of `compute` is `def`(aka `Object`) |
|      | class `B` extends `A` and redefines `compute`, this type returning an `int` |

As you can see, if the type checker relied on the inferred return type of a method, with [flow typing](https://docs.groovy-lang.org/latest/html/documentation/#section-flow-typing), the type checker could determine that it is ok to call `toUpperCase`. It is in fact an **error**, because a subclass can override `compute` and return a different object. Here, `B#compute` returns an `int`, so someone calling `computeFully` on an instance of `B` would see a runtime error. The compiler prevents this from happening by using the declared return type of methods instead of the inferred return type.

For consistency, this behavior is the same for **every** method, even if they are static or final.

Parameter type inference

In addition to the return type, it is possible for a closure to infer its parameter types from the context. There are two ways for the compiler to infer the parameter types:

- through *implicit SAM type coercion*
- through API metadata

To illustrate this, lets start with an example that will fail compilation due to the inability for the type checker to infer the parameter types:

```groovy
class Person {
    String name
    int age
}

void inviteIf(Person p, Closure<Boolean> predicate) {           
    if (predicate.call(p)) {
        // send invite
        // ...
    }
}

@groovy.transform.TypeChecked
void failCompilation() {
    Person p = new Person(name: 'Gerard', age: 55)
    inviteIf(p) {                                               
        it.age >= 18 // No such property: age                   
    }
}
```

|      | the `inviteIf` method accepts a `Person` and a `Closure`     |
| ---- | ------------------------------------------------------------ |
|      | we call it with a `Person` and a `Closure`                   |
|      | yet `it` is not statically known as being a `Person` and compilation fails |

In this example, the closure body contains `it.age`. With dynamic, not type checked code, this would work, because the type of `it` would be a `Person` at runtime. Unfortunately, at compile-time, there’s no way to know what is the type of `it`, just by reading the signature of `inviteIf`.

Explicit closure parameters

To be short, the type checker doesn’t have enough contextual information on the `inviteIf` method to determine statically the type of `it`. This means that the method call needs to be rewritten like this:

```groovy
inviteIf(p) { Person it ->                                  
    it.age >= 18
}
```

|      | the type of `it` needs to be declared explicitly |
| ---- | ------------------------------------------------ |
|      |                                                  |

By explicitly declaring the type of the `it` variable, you can workaround the problem and make this code statically checked.

Parameters inferred from single-abstract method types

For an API or framework designer, there are two ways to make this more elegant for users, so that they don’t have to declare an explicit type for the closure parameters. The first one, and easiest, is to replace the closure with a SAM type:

```groovy
interface Predicate<On> { boolean apply(On e) }                 

void inviteIf(Person p, Predicate<Person> predicate) {          
    if (predicate.apply(p)) {
        // send invite
        // ...
    }
}

@groovy.transform.TypeChecked
void passesCompilation() {
    Person p = new Person(name: 'Gerard', age: 55)

    inviteIf(p) {                                               
        it.age >= 18                                            
    }
}
```

|      | declare a `SAM` interface with an `apply` method             |
| ---- | ------------------------------------------------------------ |
|      | `inviteIf` now uses a `Predicate` instead of a `Closure`     |
|      | there’s no need to declare the type of the `it` variable anymore |
|      | `it.age` compiles properly, the type of `it` is inferred from the `Predicate#apply` method signature |

|      | By using this technique, we leverage the *automatic coercion of closures to SAM types* feature of Groovy. The question whether you should use a *SAM type* or a *Closure* really depends on what you need to do. In a lot of cases, using a SAM interface is enough, especially if you consider functional interfaces as they are found in Java 8. However, closures provide features that are not accessible to functional interfaces. In particular, closures can have a delegate, and owner and can be manipulated as objects (for example, cloned, serialized, curried, …) before being called. They can also support multiple signatures (polymorphism). So if you need that kind of manipulation, it is preferable to switch to the most advanced type inference annotations which are described below. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The original issue that needs to be solved when it comes to closure parameter type inference, that is to say, statically determining the types of the arguments of a closure *without* having to have them explicitly declared, is that the Groovy type system inherits the Java type system, which is insufficient to describe the types of the arguments.

The `@ClosureParams` annotation

Groovy provides an annotation, `@ClosureParams` which is aimed at completing type information. This annotation is primarily aimed at framework and API developers who want to extend the capabilities of the type checker by providing type inference metadata. This is important if your library makes use of closures and that you want the maximum level of tooling support too.

Let’s illustrate this by fixing the original example, introducing the `@ClosureParams` annotation:

```groovy
import groovy.transform.stc.ClosureParams
import groovy.transform.stc.FirstParam
void inviteIf(Person p, @ClosureParams(FirstParam) Closure<Boolean> predicate) {        
    if (predicate.call(p)) {
        // send invite
        // ...
    }
}
inviteIf(p) {                                                                       
    it.age >= 18
}
```

|      | the closure parameter is annotated with `@ClosureParams`     |
| ---- | ------------------------------------------------------------ |
|      | it’s not necessary to use an explicit type for `it`, which is inferred |

The `@ClosureParams` annotation minimally accepts one argument, which is named a *type hint*. A type hint is a class which is responsible for completing type information at compile time for the closure. In this example, the type hint being used is `groovy.transform.stc.FirstParam` which indicated to the type checker that the closure will accept one parameter whose type is the type of the first parameter of the method. In this case, the first parameter of the method is `Person`, so it indicates to the type checker that the first parameter of the closure is in fact a `Person`.

A second optional argument is named *options*. It’s semantics depend on the *type hint* class. Groovy comes with various bundled type hints, illustrated in the table below:

| Type hint                                                    | Polymorphic? | Description and examples                                     |
| :----------------------------------------------------------- | :----------- | :----------------------------------------------------------- |
| `FirstParam` `SecondParam` `ThirdParam`                      | No           | The first (resp. second, third) parameter type of the method `import groovy.transform.stc.FirstParam void doSomething(String str, @ClosureParams(FirstParam) Closure c) {    c(str) } doSomething('foo') { println it.toUpperCase() }``import groovy.transform.stc.SecondParam void withHash(String str, int seed, @ClosureParams(SecondParam) Closure c) {    c(31*str.hashCode()+seed) } withHash('foo', (int)System.currentTimeMillis()) {    int mod = it%2 }``import groovy.transform.stc.ThirdParam String format(String prefix, String postfix, String o, @ClosureParams(ThirdParam) Closure c) {    "$prefix${c(o)}$postfix" } assert format('foo', 'bar', 'baz') {    it.toUpperCase() } == 'fooBAZbar'` |
| `FirstParam.FirstGenericType` `SecondParam.FirstGenericType` `ThirdParam.FirstGenericType` | No           | The first generic type of the first (resp. second, third) parameter of the method `import groovy.transform.stc.FirstParam public  void doSomething(List strings, @ClosureParams(FirstParam.FirstGenericType) Closure c) {    strings.each {        c(it)    } } doSomething(['foo','bar']) { println it.toUpperCase() } doSomething([1,2,3]) { println(2*it) }`Variants for `SecondGenericType` and `ThirdGenericType` exist for all `FirstParam`, `SecondParam` and `ThirdParam` type hints. |
| `SimpleType`                                                 | No           | A type hint for which the type of closure parameters comes from the options string. `import groovy.transform.stc.SimpleType public void doSomething(@ClosureParams(value=SimpleType,options=['java.lang.String','int']) Closure c) {    c('foo',3) } doSomething { str, len ->    assert str.length() == len }`This type hint supports a **single** signature and each of the parameter is specified as a value of the *options* array using a fully-qualified type name or a primitive type. |
| `MapEntryOrKeyValue`                                         | Yes          | A dedicated type hint for closures that either work on a `Map.Entry` single parameter, or two parameters corresponding to the key and the value. `import groovy.transform.stc.MapEntryOrKeyValue public  void doSomething(Map map, @ClosureParams(MapEntryOrKeyValue) Closure c) {    // ... } doSomething([a: 'A']) { k,v ->    assert k.toUpperCase() == v.toUpperCase() } doSomething([abc: 3]) { e ->    assert e.key.length() == e.value }`This type hint **requires** that the first argument is a `Map` type, and infers the closure parameter types from the map actual key/value types. |
| `FromAbstractTypeMethods`                                    | Yes          | Infers closure parameter types from the abstract method of some type. A signature is inferred for **each** abstract method. `import groovy.transform.stc.FromAbstractTypeMethods abstract class Foo {    abstract void firstSignature(int x, int y)    abstract void secondSignature(String str) } void doSomething(@ClosureParams(value=FromAbstractTypeMethods, options=["Foo"]) Closure cl) {    // ... } doSomething { a, b -> a+b } doSomething { s -> s.toUpperCase() }`If there are multiple signatures like in the example above, the type checker will **only** be able to infer the types of the arguments if the arity of each method is different. In the example above, `firstSignature` takes 2 arguments and `secondSignature` takes 1 argument, so the type checker can infer the argument types based on the number of arguments. But see the optional resolver class attribute discussed next. |
| `FromString`                                                 | Yes          | Infers the closure parameter types from the `options` argument. The `options` argument consists of an array of comma-separated non-primitive types. Each element of the array corresponds to a single signature, and each comma in an element separate parameters of the signature. In short, this is the most generic type hint, and each string of the `options` map is **parsed** as if it was a signature literal. While being very powerful, this type hint must be avoided if you can because it increases the compilation times due to the necessity of parsing the type signatures.A single signature for a closure accepting a `String`:`import groovy.transform.stc.FromString void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {    // ... } doSomething { s -> s.toUpperCase() } doSomething { s,i -> s.toUpperCase()*i }`A polymorphic closure, accepting either a `String` or a `String, Integer`:`import groovy.transform.stc.FromString void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {    // ... } doSomething { s -> s.toUpperCase() } doSomething { s,i -> s.toUpperCase()*i }`A polymorphic closure, accepting either a `T` or a pair `T,T`:`import groovy.transform.stc.FromString public  void doSomething(T e, @ClosureParams(value=FromString, options=["T","T,T"]) Closure cl) {    // ... } doSomething('foo') { s -> s.toUpperCase() } doSomething('foo') { s1,s2 -> assert s1.toUpperCase() == s2.toUpperCase() }` |

|      | Even though you use `FirstParam`, `SecondParam` or `ThirdParam` as a type hint, it doesn’t strictly mean that the argument which will be passed to the closure **will** be the first (resp. second, third) argument of the method call. It only means that the **type** of the parameter of the closure will be the **same** as the type of the first (resp. second, third) argument of the method call. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

In short, the lack of the `@ClosureParams` annotation on a method accepting a `Closure` will **not** fail compilation. If present (and it can be present in Java sources as well as Groovy sources), then the type checker has **more** information and can perform additional type inference. This makes this feature particularly interesting for framework developers.

A third optional argument is named *conflictResolutionStrategy*. It can reference a class (extending from `ClosureSignatureConflictResolver`) that can perform additional resolution of parameter types if more than one are found after initial inference calculations are complete. Groovy comes with the a default type resolver which does nothing, and another which selects the first signature if multiple are found. The resolver is only invoked if more than one signature is found and is by design a post processor. Any statements which need injected typing information must pass one of the parameter signatures determined through type hints. The resolver then picks among the returned candidate signatures.

```
@DelegatesTo
```

The `@DelegatesTo` annotation is used by the type checker to infer the type of the delegate. It allows the API designer to instruct the compiler what is the type of the delegate and the delegation strategy. The `@DelegatesTo` annotation is discussed in a [specific section](https://docs.groovy-lang.org/latest/html/documentation/core-domain-specific-languages.html#section-delegatesto).

##### Static compilation

###### Dynamic vs static

In the [type checking section](https://docs.groovy-lang.org/latest/html/documentation/#static-type-checking), we have seen that Groovy provides optional type checking thanks to the `@TypeChecked` annotation. The type checker runs at compile time and performs a static analysis of dynamic code. The program will behave exactly the same whether type checking has been enabled or not. This means that the `@TypeChecked` annotation is neutral with regards to the semantics of a program. Even though it may be necessary to add type information in the sources so that the program is considered type safe, in the end, the semantics of the program are the same.

While this may sound fine, there is actually one issue with this: type checking of dynamic code, done at compile time, is by definition only correct if no runtime specific behavior occurs. For example, the following program passes type checking:

```groovy
class Computer {
    int compute(String str) {
        str.length()
    }
    String compute(int x) {
        String.valueOf(x)
    }
}

@groovy.transform.TypeChecked
void test() {
    def computer = new Computer()
    computer.with {
        assert compute(compute('foobar')) =='6'
    }
}
```

There are two `compute` methods. One accepts a `String` and returns an `int`, the other accepts an `int` and returns a `String`. If you compile this, it is considered type safe: the inner `compute('foobar')` call will return an `int`, and calling `compute` on this `int` will in turn return a `String`.

Now, before calling `test()`, consider adding the following line:

```groovy
Computer.metaClass.compute = { String str -> new Date() }
```

Using runtime metaprogramming, we’re actually modifying the behavior of the `compute(String)` method, so that instead of returning the length of the provided argument, it will return a `Date`. If you execute the program, it will fail at runtime. Since this line can be added from anywhere, in any thread, there’s absolutely no way for the type checker to statically make sure that no such thing happens. In short, the type checker is vulnerable to monkey patching. This is just one example, but this illustrates the concept that doing static analysis of a dynamic program is inherently wrong.

The Groovy language provides an alternative annotation to `@TypeChecked` which will actually make sure that the methods which are inferred as being called **will** effectively be called at runtime. This annotation turns the Groovy compiler into a **static compiler**, where all method calls are resolved at compile time **and** the generated bytecode makes sure that this happens: the annotation is `@groovy.transform.CompileStatic`.

###### The `@CompileStatic` annotation

The `@CompileStatic` annotation can be added anywhere the `@TypeChecked` annotation can be used, that is to say on a class or a method. It is not necessary to add both `@TypeChecked` and `@CompileStatic`, as `@CompileStatic` performs everything `@TypeChecked` does, but in addition triggers static compilation.

Let’s take the [example which failed](https://docs.groovy-lang.org/latest/html/documentation/#typechecked-defeated), but this time let’s replace the `@TypeChecked` annotation with `@CompileStatic`:

```groovy
class Computer {
    int compute(String str) {
        str.length()
    }
    String compute(int x) {
        String.valueOf(x)
    }
}

@groovy.transform.CompileStatic
void test() {
    def computer = new Computer()
    computer.with {
        assert compute(compute('foobar')) =='6'
    }
}
Computer.metaClass.compute = { String str -> new Date() }
test()
```

This is the **only** difference. If we execute this program, this time, there is no runtime error. The `test` method became immune to monkey patching, because the `compute` methods which are called in its body are linked at compile time, so even if the metaclass of `Computer` changes, the program still behaves **as expected by the type checker**.

###### Key benefits

There are several benefits of using `@CompileStatic` on your code:

- type safety
- immunity to [monkey patching](https://docs.groovy-lang.org/latest/html/documentation/#compilestatic-annotation)
- performance improvements

The performance improvements depend on the kind of program you are executing. If it is I/O bound, the difference between statically compiled code and dynamic code is barely noticeable. On highly CPU intensive code, since the bytecode which is generated is very close, if not equal, to the one that Java would produce for an equivalent program, the performance is greatly improved.

|      | Using the *invokedynamic* version of Groovy, which is accessible to people using JDK 7 and above, the performance of the dynamic code should be very close to the performance of statically compiled code. Sometimes, it can even be faster! There is only one way to determine which version you should choose: measuring. The reason is that depending on your program **and** the JVM that you use, the performance can be significantly different. In particular, the *invokedynamic* version of Groovy is very sensitive to the JVM version in use. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 1.6.7. Type checking extensions

##### Writing a type checking extension

###### Towards a smarter type checker

Despite being a dynamic language, Groovy can be used with a static type checker at compile time, enabled using the [@TypeChecked](https://docs.groovy-lang.org/latest/html/documentation/#static-type-checking) annotation. In this mode, the compiler becomes more verbose and throws errors for, example, typos, non-existent methods,… This comes with a few limitations though, most of them coming from the fact that Groovy remains inherently a dynamic language. For example, you wouldn’t be able to use type checking on code that uses the markup builder:

```groovy
def builder = new MarkupBuilder(out)
builder.html {
    head {
        // ...
    }
    body {
        p 'Hello, world!'
    }
}
```

In the previous example, none of the `html`, `head`, `body` or `p` methods exist. However if you execute the code, it works because Groovy uses dynamic dispatch and converts those method calls at runtime. In this builder, there’s no limitation about the number of tags that you can use, nor the attributes, which means there is no chance for a type checker to know about all the possible methods (tags) at compile time, unless you create a builder dedicated to HTML for example.

Groovy is a platform of choice when it comes to implement internal DSLs. The flexible syntax, combined with runtime and compile-time metaprogramming capabilities make Groovy an interesting choice because it allows the programmer to focus on the DSL rather than on tooling or implementation. Since Groovy DSLs are Groovy code, it’s easy to have IDE support without having to write a dedicated plugin for example.

In a lot of cases, DSL engines are written in Groovy (or Java) then user code is executed as scripts, meaning that you have some kind of wrapper on top of user logic. The wrapper may consist, for example, in a `GroovyShell` or `GroovyScriptEngine` that performs some tasks transparently before running the script (adding imports, applying AST transforms, extending a base script,…). Often, user written scripts come to production without testing because the DSL logic comes to a point where **any** user may write code using the DSL syntax. In the end, a user may just ignore that what he writes is actually **code**. This adds some challenges for the DSL implementer, such as securing execution of user code or, in this case, early reporting of errors.

For example, imagine a DSL which goal is to drive a rover on Mars remotely. Sending a message to the rover takes around 15 minutes. If the rover executes the script and fails with an error (say a typo), you have two problems:

- first, feedback comes only after 30 minutes (the time needed for the rover to get the script and the time needed to receive the error)
- second, some portion of the script has been executed and you may have to change the fixed script significantly (implying that you need to know the current state of the rover…)

Type checking extensions is a mechanism that will allow the developer of a DSL engine to make those scripts safer by applying the same kind of checks that static type checking allows on regular groovy classes.

The principle, here, is to fail early, that is to say fail compilation of scripts as soon as possible, and if possible provide feedback to the user (including nice error messages).

In short, the idea behind type checking extensions is to make the compiler aware of all the runtime metaprogramming tricks that the DSL uses, so that scripts can benefit the same level of compile-time checks as a verbose statically compiled code would have. We will see that you can go even further by performing checks that a normal type checker wouldn’t do, delivering powerful compile-time checks for your users.

###### The extensions attribute

The `@TypeChecked` annotation supports an attribute named `extensions`. This parameter takes an array of strings corresponding to a list of *type checking extensions scripts*. Those scripts are found at **compile time** on classpath. For example, you would write:

```groovy
@TypeChecked(extensions='/path/to/myextension.groovy')
void foo() { ...}
```

In that case, the *foo* methods would be type checked with the rules of the normal type checker completed by those found in the *myextension.groovy* script. Note that while internally the type checker supports multiple mechanisms to implement type checking extensions (including plain old java code), the recommended way is to use those type checking extension scripts.

###### A DSL for type checking

The idea behind type checking extensions is to use a DSL to extend the type checker capabilities. This DSL allows you to hook into the compilation process, more specifically the type checking phase, using an "event-driven" API. For example, when the type checker enters a method body, it throws a *beforeVisitMethod* event that the extension can react to:

```groovy
beforeVisitMethod { methodNode ->
 println "Entering ${methodNode.name}"
}
```

Imagine that you have this rover DSL at hand. A user would write:

```groovy
robot.move 100
```

If you have a class defined as such:

```groovy
class Robot {
    Robot move(int qt) { this }
}
```

The script can be type checked before being executed using the following script:

```groovy
def config = new CompilerConfiguration()
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(TypeChecked)            
)
def shell = new GroovyShell(config)                         
def robot = new Robot()
shell.setVariable('robot', robot)
shell.evaluate(script)                                      
```

|      | a compiler configuration adds the `@TypeChecked` annotation to all classes |
| ---- | ------------------------------------------------------------ |
|      | use the configuration in a `GroovyShell`                     |
|      | so that scripts compiled using the shell are compiled with `@TypeChecked` without the user having to add it explicitly |

Using the compiler configuration above, we can apply *@TypeChecked* transparently to the script. In that case, it will fail at compile time:

```
[Static type checking] - The variable [robot] is undeclared.
```

Now, we will slightly update the configuration to include the ``extensions'' parameter:

```groovy
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        TypeChecked,
        extensions:['robotextension.groovy'])
)
```

Then add the following to your classpath:

robotextension.groovy

```groovy
unresolvedVariable { var ->
    if ('robot'==var.name) {
        storeType(var, classNodeFor(Robot))
        handled = true
    }
}
```

Here, we’re telling the compiler that if an *unresolved variable* is found and that the name of the variable is *robot*, then we can make sure that the type of this variable is `Robot`.

###### Type checking extensions API

AST

The type checking API is a low level API, dealing with the Abstract Syntax Tree. You will have to know your AST well to develop extensions, even if the DSL makes it much easier than just dealing with AST code from plain Java or Groovy.

Events

The type checker sends the following events, to which an extension script can react:

| **Event name**  | setup                                                        |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called after the type checker finished initialization        |
| **Arguments**   | none                                                         |
| **Usage**       | `setup {    // this is called before anything else }`Can be used to perform setup of your extension |

| **Event name**  | finish                                                       |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called after the type checker completed type checking        |
| **Arguments**   | none                                                         |
| **Usage**       | `finish {    // this is after completion    // of all type checking }`Can be used to perform additional checks after the type checker has finished its job. |

| **Event name**  | unresolvedVariable                                           |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called when the type checker finds an unresolved variable    |
| **Arguments**   | VariableExpression var                                       |
| **Usage**       | `unresolvedVariable { var ->    if ('people' == var.name) {        storeType(var, classNodeFor(List))        handled = true    } }`Allows the developer to help the type checker with user-injected variables. |

| **Event name**  | unresolvedProperty                                           |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called when the type checker cannot find a property on the receiver |
| **Arguments**   | PropertyExpression pexp                                      |
| **Usage**       | `unresolvedProperty { pexp ->    if ('longueur'==pexp.propertyAsString &&        getType(pexp.objectExpression)==classNodeFor(String)) {        storeType(pexp,classNodeFor(int))        handled = true    } }`Allows the developer to handle "dynamic" properties |

| **Event name**  | unresolvedAttribute                                          |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called when the type checker cannot find an attribute on the receiver |
| **Arguments**   | AttributeExpression aex                                      |
| **Usage**       | `unresolvedAttribute { aex ->    if (getType(aex.objectExpression)==classNodeFor(String)) {        storeType(aex,classNodeFor(String))        handled = true    } }`Allows the developer to handle missing attributes |

| **Event name**  | beforeMethodCall                                             |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called before the type checker starts type checking a method call |
| **Arguments**   | MethodCall call                                              |
| **Usage**       | `beforeMethodCall { call ->    if (isMethodCallExpression(call)            && call.methodAsString=='toUpperCase') {        addStaticTypeError('Not allowed',call)        handled = true    } }`Allows you to intercept method calls before the type checker performs its own checks. This is useful if you want to replace the default type checking with a custom one for a limited scope. In that case, you must set the handled flag to true, so that the type checker skips its own checks. |

| **Event name**  | afterMethodCall                                              |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called once the type checker has finished type checking a method call |
| **Arguments**   | MethodCall call                                              |
| **Usage**       | `afterMethodCall { call ->    if (getTargetMethod(call).name=='toUpperCase') {        addStaticTypeError('Not allowed',call)        handled = true    } }`Allow you to perform additional checks after the type checker has done its own checks. This is in particular useful if you want to perform the standard type checking tests but also want to ensure additional type safety, for example checking the arguments against each other.Note that `afterMethodCall` is called even if you did `beforeMethodCall` and set the handled flag to true. |

| **Event name**  | onMethodSelection                                            |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called by the type checker when it finds a method appropriate for a method call |
| **Arguments**   | Expression expr, MethodNode node                             |
| **Usage**       | `onMethodSelection { expr, node ->    if (node.declaringClass.name == 'java.lang.String') {        // calling a method on 'String'        // let’s perform additional checks!        if (++count>2) {            addStaticTypeError("You can use only 2 calls on String in your source code",expr)        }    } }`The type checker works by inferring argument types of a method call, then chooses a target method. If it finds one that corresponds, then it triggers this event. It is for example interesting if you want to react on a specific method call, such as entering the scope of a method that takes a closure as argument (as in builders).Please note that this event may be thrown for various types of expressions, not only method calls (binary expressions for example). |

| **Event name**  | methodNotFound                                               |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called by the type checker when it fails to find an appropriate method for a method call |
| **Arguments**   | ClassNode receiver, String name, ArgumentListExpression argList, ClassNode[] argTypes,MethodCall call |
| **Usage**       | `methodNotFound { receiver, name, argList, argTypes, call ->    // receiver is the inferred type of the receiver    // name is the name of the called method    // argList is the list of arguments the method was called with    // argTypes is the array of inferred types for each argument    // call is the method call for which we couldn’t find a target method    if (receiver==classNodeFor(String)            && name=='longueur'            && argList.size()==0) {        handled = true        return newMethod('longueur', classNodeFor(String))    } }`Unlike `onMethodSelection`, this event is sent when the type checker cannot find a target method for a method call (instance or static). It gives you the chance to intercept the error before it is sent to the user, but also set the target method.For this, you need to return a list of `MethodNode`. In most situations, you would either return: an empty list, meaning that you didn’t find a corresponding method, a list with exactly one element, saying that there’s no doubt about the target methodIf you return more than one MethodNode, then the compiler would throw an error to the user stating that the method call is ambiguous, listing the possible methods.For convenience, if you want to return only one method, you are allowed to return it directly instead of wrapping it into a list. |

| **Event name**  | beforeVisitMethod                                            |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called by the type checker before type checking a method body |
| **Arguments**   | MethodNode node                                              |
| **Usage**       | `beforeVisitMethod { methodNode ->    // tell the type checker we will handle the body by ourselves    handled = methodNode.name.startsWith('skip') }`The type checker will call this method before starting to type check a method body. If you want, for example, to perform type checking by yourself instead of letting the type checker do it, you have to set the handled flag to true.This event can also be used to help defining the scope of your extension (for example, applying it only if you are inside method foo). |

| **Event name**  | afterVisitMethod                                             |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called by the type checker after type checking a method body |
| **Arguments**   | MethodNode node                                              |
| **Usage**       | `afterVisitMethod { methodNode ->    scopeExit {        if (methods>2) {            addStaticTypeError("Method ${methodNode.name} contains more than 2 method calls", methodNode)        }    } }`Gives you the opportunity to perform additional checks after a method body is visited by the type checker. This is useful if you collect information, for example, and want to perform additional checks once everything has been collected. |

| **Event name**  | beforeVisitClass                                             |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called by the type checker before type checking a class      |
| **Arguments**   | ClassNode node                                               |
| **Usage**       | `beforeVisitClass { ClassNode classNode ->    def name = classNode.nameWithoutPackage    if (!(name[0] in 'A'..'Z')) {        addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)    } }`If a class is type checked, then before visiting the class, this event will be sent. It is also the case for inner classes defined inside a class annotated with `@TypeChecked`. It can help you define the scope of your extension, or you can even totally replace the visit of the type checker with a custom type checking implementation. For that, you would have to set the `handled` flag to `true`. |

| **Event name**  | afterVisitClass                                              |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called by the type checker after having finished the visit of a type checked class |
| **Arguments**   | ClassNode node                                               |
| **Usage**       | `afterVisitClass { ClassNode classNode ->    def name = classNode.nameWithoutPackage    if (!(name[0] in 'A'..'Z')) {        addStaticTypeError("Class '${name}' doesn't start with an uppercase letter",classNode)    } }`Called for every class being type checked after the type checker finished its work. This includes classes annotated with `@TypeChecked` and any inner/anonymous class defined in the same class with is not skipped. |

| **Event name**  | incompatibleAssignment                                       |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called when the type checker thinks that an assignment is incorrect, meaning that the right hand side of an assignment is incompatible with the left hand side |
| **Arguments**   | ClassNode lhsType, ClassNode rhsType, Expression assignment  |
| **Usage**       | `incompatibleAssignment { lhsType, rhsType, expr ->    if (isBinaryExpression(expr) && isAssignment(expr.operation.type)) {        if (lhsType==classNodeFor(int) && rhsType==classNodeFor(Closure)) {            handled = true        }    } }`Gives the developer the ability to handle incorrect assignments. This is for example useful if a class overrides `setProperty`, because in that case it is possible that assigning a variable of one type to a property of another type is handled through that runtime mechanism. In that case, you can help the type checker just by telling it that the assignment is valid (using `handled` set to `true`). |

| **Event name**  | ambiguousMethods                                             |
| --------------- | ------------------------------------------------------------ |
| **Called When** | Called when the type checker cannot choose between several candidate methods |
| **Arguments**   | List<MethodNode> methods, Expression origin                  |
| **Usage**       | `ambiguousMethods { methods, origin ->    // choose the method which has an Integer as parameter type    methods.find { it.parameters.any { it.type == classNodeFor(Integer) } } }`Gives the developer the ability to handle incorrect assignments. This is for example useful if a class overrides `setProperty`, because in that case it is possible that assigning a variable of one type to a property of another type is handled through that runtime mechanism. In that case, you can help the type checker just by telling it that the assignment is valid (using `handled` set to `true`). |

Of course, an extension script may consist of several blocks, and you can have multiple blocks responding to the same event. This makes the DSL look nicer and easier to write. However, reacting to events is far from sufficient. If you know you can react to events, you also need to deal with the errors, which implies several *helper* methods that will make things easier.

###### Working with extensions

Support classes

The DSL relies on a support class called [org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html) . This class itself extends [org.codehaus.groovy.transform.stc.TypeCheckingExtension](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingExtension.html) . Those two classes define a number of *helper* methods that will make working with the AST easier, especially regarding type checking. One interesting thing to know is that you **have access to the type checker**. This means that you can programmatically call methods of the type checker, including those that allow you to **throw compilation errors**.

The extension script delegates to the [org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html) class, meaning that you have direct access to the following variables:

- *context*: the type checker context, of type [org.codehaus.groovy.transform.stc.TypeCheckingContext](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingContext.html)
- *typeCheckingVisitor*: the type checker itself, a [org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.html) instance
- *generatedMethods*: a list of "generated methods", which is in fact the list of "dummy" methods that you can create inside a type checking extension using the `newMethod` calls

The type checking context contains a lot of information that is useful in context for the type checker. For example, the current stack of enclosing method calls, binary expressions, closures, … This information is in particular important if you have to know *where* you are when an error occurs and that you want to handle it.

Class nodes

Handling class nodes is something that needs particular attention when you work with a type checking extension. Compilation works with an abstract syntax tree (AST) and the tree may not be complete when you are type checking a class. This also means that when you refer to types, you must not use class literals such as `String` or `HashSet`, but to class nodes representing those types. This requires a certain level of abstraction and understanding how Groovy deals with class nodes. To make things easier, Groovy supplies several helper methods to deal with class nodes. For example, if you want to say "the type for String", you can write:

```groovy
assert classNodeFor(String) instanceof ClassNode
```

You would also note that there is a variant of *classNodeFor* that takes a `String` as an argument, instead of a `Class`. In general, you should **not** use that one, because it would create a class node for which the name is `String`, but without any method, any property, … defined on it. The first version returns a class node that is *resolved* but the second one returns one that is *not*. So the latter should be reserved for very special cases.

The second problem that you might encounter is referencing a type which is not yet compiled. This may happen more often than you think. For example, when you compile a set of files together. In that case, if you want to say "that variable is of type Foo" but `Foo` is not yet compiled, you can still refer to the `Foo` class node using `lookupClassNodeFor`:

```groovy
assert lookupClassNodeFor('Foo') instanceof ClassNode
```

Helping the type checker

Say that you know that variable `foo` is of type `Foo` and you want to tell the type checker about it. Then you can use the `storeType` method, which takes two arguments: the first one is the node for which you want to store the type and the second one is the type of the node. If you look at the implementation of `storeType`, you would see that it delegates to the type checker equivalent method, which itself does a lot of work to store node metadata. You would also see that storing the type is not limited to variables: you can set the type of any expression.

Likewise, getting the type of an AST node is just a matter of calling `getType` on that node. This would in general be what you want, but there’s something that you must understand:

- `getType` returns the **inferred type** of an expression. This means that it will not return, for a variable declared of type `Object` the class node for `Object`, but the inferred type of this variable **at this point of the code** (flow typing)
- if you want to access the origin type of a variable (or field/parameter), then you must call the appropriate method on the AST node

Throwing an error

To throw a type checking error, you only have to call the `addStaticTypeError` method which takes two arguments:

- a *message* which is a string that will be displayed to the end user
- an *AST node* responsible for the error. It’s better to provide the best suiting AST node because it will be used to retrieve the line and column numbers

isXXXExpression

It is often required to know the type of an AST node. For readability, the DSL provides a special isXXXExpression method that will delegate to `x instance of XXXExpression`. For example, instead of writing:

```groovy
if (node instanceof BinaryExpression) {
   ...
}
```

which requires you to import the `BinaryExpression` class, you can just write:

```groovy
if (isBinaryExpression(node)) {
   ...
}
```

Virtual methods

When you perform type checking of dynamic code, you may often face the case when you know that a method call is valid but there is no "real" method behind it. As an example, take the Grails dynamic finders. You can have a method call consisting of a method named *findByName(…)*. As there’s no *findByName* method defined in the bean, the type checker would complain. Yet, you would know that this method wouldn’t fail at runtime, and you can even tell what is the return type of this method. For this case, the DSL supports two special constructs that consist of *phantom methods*. This means that you will return a method node that doesn’t really exist but is defined in the context of type checking. Three methods exist:

- `newMethod(String name, Class returnType)`
- `newMethod(String name, ClassNode returnType)`
- `newMethod(String name, Callable return Type)`

All three variants do the same: they create a new method node which name is the supplied name and define the return type of this method. Moreover, the type checker would add those methods in the `generatedMethods` list (see `isGenerated` below). The reason why we only set a name and a return type is that it is only what you need in 90% of the cases. For example, in the `findByName` example upper, the only thing you need to know is that `findByName` wouldn’t fail at runtime, and that it returns a domain class. The `Callable` version of return type is interesting because it defers the computation of the return type when the type checker actually needs it. This is interesting because in some circumstances, you may not know the actual return type when the type checker demands it, so you can use a closure that will be called each time `getReturnType` is called by the type checker on this method node. If you combine this with deferred checks, you can achieve pretty complex type checking including handling of forward references.

```groovy
newMethod(name) {
    // each time getReturnType on this method node will be called, this closure will be called!
    println 'Type checker called me!'
    lookupClassNodeFor(Foo) // return type
}
```

Should you need more than the name and return type, you can always create a new `MethodNode` by yourself.

Scoping

Scoping is very important in DSL type checking and is one of the reasons why we couldn’t use a *pointcut* based approach to DSL type checking. Basically, you must be able to define very precisely when your extension applies and when it does not. Moreover, you must be able to handle situations that a regular type checker would not be able to handle, such as forward references:

```groovy
point a(1,1)
line a,b // b is referenced afterwards!
point b(5,2)
```

Say for example that you want to handle a builder:

```groovy
builder.foo {
   bar
   baz(bar)
}
```

Your extension, then, should only be active once you’ve entered the `foo` method, and inactive outside of this scope. But you could have complex situations like multiple builders in the same file or embedded builders (builders in builders). While you should not try to fix all this from start (you must accept limitations to type checking), the type checker does offer a nice mechanism to handle this: a scoping stack, using the `newScope` and `scopeExit` methods.

- `newScope` creates a new scope and puts it on top of the stack
- `scopeExits` pops a scope from the stack

A scope consists of:

- a parent scope
- a map of custom data

If you want to look at the implementation, it’s simply a `LinkedHashMap` ([org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport.TypeCheckingScope](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport/TypeCheckingScope.html)), but it’s quite powerful. For example, you can use such a scope to store a list of closures to be executed when you exit the scope. This is how you would handle forward references: 

```groovy
def scope = newScope()
scope.secondPassChecks = []
//...
scope.secondPassChecks << { println 'executed later' }
// ...
scopeExit {
    secondPassChecks*.run() // execute deferred checks
}
```

That is to say, that if at some point you are not able to determine the type of an expression, or that you are not able to check at this point that an assignment is valid or not, you can still make the check later… This is a very powerful feature. Now, `newScope` and `scopeExit` provide some interesting syntactic sugar:

```groovy
newScope {
    secondPassChecks = []
}
```

At anytime in the DSL, you can access the current scope using `getCurrentScope()` or more simply `currentScope`:

```groovy
//...
currentScope.secondPassChecks << { println 'executed later' }
// ...
```

The general schema would then be:

- determine a *pointcut* where you push a new scope on stack and initialize custom variables within this scope
- using the various events, you can use the information stored in your custom scope to perform checks, defer checks,…
- determine a *pointcut* where you exit the scope, call `scopeExit` and eventually perform additional checks

Other useful methods

For the complete list of helper methods, please refer to the [org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/stc/GroovyTypeCheckingExtensionSupport.html) and [org.codehaus.groovy.transform.stc.TypeCheckingExtension](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/stc/TypeCheckingExtension.html) classes. However, take special attention to those methods:

- `isDynamic`: takes a VariableExpression as argument and returns true if the variable is a DynamicExpression, which means, in a script, that it wasn’t defined using a type or `def`.
- `isGenerated`: takes a MethodNode as an argument and tells if the method is one that was generated by the type checker extension using the `newMethod` method
- `isAnnotatedBy`: takes an AST node and a Class (or ClassNode), and tells if the node is annotated with this class. For example: `isAnnotatedBy(node, NotNull)`
- `getTargetMethod`: takes a method call as argument and returns the `MethodNode` that the type checker has determined for it
- `delegatesTo`: emulates the behaviour of the `@DelegatesTo` annotation. It allows you to tell that the argument will delegate to a specific type (you can also specify the delegation strategy)

##### Advanced type checking extensions

###### Precompiled type checking extensions

All the examples above use type checking scripts. They are found in source form in classpath, meaning that:

- a Groovy source file, corresponding to the type checking extension, is available on compilation classpath
- this file is compiled by the Groovy compiler for each source unit being compiled (often, a source unit corresponds to a single file)

It is a very convenient way to develop type checking extensions, however it implies a slower compilation phase, because of the compilation of the extension itself for each file being compiled. For those reasons, it can be practical to rely on a precompiled extension. You have two options to do this:

- write the extension in Groovy, compile it, then use a reference to the extension class instead of the source
- write the extension in Java, compile it, then use a reference to the extension class

Writing a type checking extension in Groovy is the easiest path. Basically, the idea is that the type checking extension script becomes the body of the main method of a type checking extension class, as illustrated here:

```groovy
import org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport

class PrecompiledExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {     
    @Override
    Object run() {                                                                          
        unresolvedVariable { var ->
            if ('robot'==var.name) {
                storeType(var, classNodeFor(Robot))                                         
                handled = true
            }
        }
    }
}
```

|      | extending the `TypeCheckingDSL` class is the easiest         |
| ---- | ------------------------------------------------------------ |
|      | then the extension code needs to go inside the `run` method  |
|      | and you can use the very same events as an extension written in source form |

Setting up the extension is very similar to using a source form extension:

```groovy
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        TypeChecked,
        extensions:['typing.PrecompiledExtension'])
)
```

The difference is that instead of using a path in classpath, you just specify the fully qualified class name of the precompiled extension.

In case you really want to write an extension in Java, then you will not benefit from the type checking extension DSL. The extension above can be rewritten in Java this way:

```java
import org.codehaus.groovy.ast.ClassHelper;
import org.codehaus.groovy.ast.expr.VariableExpression;
import org.codehaus.groovy.transform.stc.AbstractTypeCheckingExtension;


import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;

public class PrecompiledJavaExtension extends AbstractTypeCheckingExtension {                   

    public PrecompiledJavaExtension(final StaticTypeCheckingVisitor typeCheckingVisitor) {
        super(typeCheckingVisitor);
    }

    @Override
    public boolean handleUnresolvedVariableExpression(final VariableExpression vexp) {          
        if ("robot".equals(vexp.getName())) {
            storeType(vexp, ClassHelper.make(Robot.class));
            setHandled(true);
            return true;
        }
        return false;
    }

}
```

|      | extend the `AbstractTypeCheckingExtension` class  |
| ---- | ------------------------------------------------- |
|      | then override the `handleXXX` methods as required |

###### Using @Grab in a type checking extension

It is totally possible to use the `@Grab` annotation in a type checking extension. This means you can include libraries that would only be available at compile time. In that case, you must understand that you would increase the time of compilation significantly (at least, the first time it grabs the dependencies).

###### Sharing or packaging type checking extensions

A type checking extension is just a script that need to be on classpath. As such, you can share it as is, or bundle it in a jar file that would be added to classpath.

###### Global type checking extensions

While you can configure the compiler to transparently add type checking extensions to your script, there is currently no way to apply an extension transparently just by having it on classpath.

###### Type checking extensions and @CompileStatic

Type checking extensions are used with `@TypeChecked` but can also be used with `@CompileStatic`. However, you must be aware that:

- a type checking extension used with `@CompileStatic` will in general not be sufficient to let the compiler know how to generate statically compilable code from "unsafe" code
- it is possible to use a type checking extension with `@CompileStatic` just to enhance type checking, that is to say introduce **more** compilation errors, without actually dealing with dynamic code

Let’s explain the first point, which is that even if you use an extension, the compiler will not know how to compile your code statically: technically, even if you tell the type checker what is the type of a dynamic variable, for example, it would not know how to compile it. Is it `getBinding('foo')`, `getProperty('foo')`, `delegate.getFoo()`,…? There’s absolutely no direct way to tell the static compiler how to compile such code even if you use a type checking extension (that would, again, only give hints about the type).

One possible solution for this particular example is to instruct the compiler to use [mixed mode compilation](https://docs.groovy-lang.org/latest/html/documentation/#mixed-mode). The more advanced one is to use [AST transformations during type checking](https://docs.groovy-lang.org/latest/html/documentation/#ast-xform-as-extension) but it is far more complex.

Type checking extensions allow you to help the type checker where it fails, but it also allow you to fail where it doesn’t. In that context, it makes sense to support extensions for `@CompileStatic` too. Imagine an extension that is capable of type checking SQL queries. In that case, the extension would be valid in both dynamic and static context, because without the extension, the code would still pass.

###### Mixed mode compilation

In the previous section, we highlighted the fact that you can activate type checking extensions with `@CompileStatic`. In that context, the type checker would not complain anymore about some unresolved variables or unknown method calls, but it would still wouldn’t know how to compile them statically.

Mixed mode compilation offers a third way, which is to instruct the compiler that whenever an unresolved variable or method call is found, then it should fall back to a dynamic mode. This is possible thanks to type checking extensions and a special `makeDynamic` call.

To illustrate this, let’s come back to the `Robot` example:

```groovy
robot.move 100
```

And let’s try to activate our type checking extension using `@CompileStatic` instead of `@TypeChecked`:

```groovy
def config = new CompilerConfiguration()
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,                                      
        extensions:['robotextension.groovy'])               
)
def shell = new GroovyShell(config)
def robot = new Robot()
shell.setVariable('robot', robot)
shell.evaluate(script)
```

|      | Apply `@CompileStatic` transparently |
| ---- | ------------------------------------ |
|      | Activate the type checking extension |

The script will run fine because the static compiler is told about the type of the `robot` variable, so it is capable of making a direct call to `move`. But before that, how did the compiler know how to get the `robot` variable? In fact by default, in a type checking extension, setting `handled=true` on an unresolved variable will automatically trigger a dynamic resolution, so in this case you don’t have anything special to make the compiler use a mixed mode. However, let’s slightly update our example, starting from the robot script:

```groovy
move 100
```

Here you can notice that there is no reference to `robot` anymore. Our extension will not help then because we will not be able to instruct the compiler that `move` is done on a `Robot` instance. This example of code can be executed in a totally dynamic way thanks to the help of a [groovy.util.DelegatingScript](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/util/DelegatingScript.html):

```groovy
def config = new CompilerConfiguration()
config.scriptBaseClass = 'groovy.util.DelegatingScript'     
def shell = new GroovyShell(config)
def runner = shell.parse(script)                            
runner.setDelegate(new Robot())                             
runner.run()                                                
```

|      | we configure the compiler to use a `DelegatingScript` as the base class |
| ---- | ------------------------------------------------------------ |
|      | the script source needs to be parsed and will return an instance of `DelegatingScript` |
|      | we can then call `setDelegate` to use a `Robot` as the delegate of the script |
|      | then execute the script. `move` will be directly executed on the delegate |

If we want this to pass with `@CompileStatic`, we have to use a type checking extension, so let’s update our configuration:

```groovy
config.addCompilationCustomizers(
    new ASTTransformationCustomizer(
        CompileStatic,                                      
        extensions:['robotextension2.groovy'])              
)
```

|      | apply `@CompileStatic` transparently                         |
| ---- | ------------------------------------------------------------ |
|      | use an alternate type checking extension meant to recognize the call to `move` |

Then in the previous section we have learnt how to deal with unrecognized method calls, so we are able to write this extension:

robotextension2.groovy

```groovy
methodNotFound { receiver, name, argList, argTypes, call ->
    if (isMethodCallExpression(call)                        
        && call.implicitThis                                
        && 'move'==name                                     
        && argTypes.length==1                               
        && argTypes[0] == classNodeFor(int)                 
    ) {
        handled = true                                      
        newMethod('move', classNodeFor(Robot))              
    }
}
```

|      | if the call is a method call (not a static method call)      |
| ---- | ------------------------------------------------------------ |
|      | that this call is made on "implicit this" (no explicit `this.`) |
|      | that the method being called is `move`                       |
|      | and that the call is done with a single argument             |
|      | and that argument is of type `int`                           |
|      | then tell the type checker that the call is valid            |
|      | and that the return type of the call is `Robot`              |

If you try to execute this code, then you could be surprised that it actually fails at runtime:

```
java.lang.NoSuchMethodError: java.lang.Object.move()Ltyping/Robot;
```

The reason is very simple: while the type checking extension is sufficient for `@TypeChecked`, which does not involve static compilation, it is not enough for `@CompileStatic` which requires additional information. In this case, you told the compiler that the method existed, but you didn’t explain to it **what** method it is in reality, and what is the receiver of the message (the delegate).

Fixing this is very easy and just implies replacing the `newMethod` call with something else:

robotextension3.groovy

```groovy
methodNotFound { receiver, name, argList, argTypes, call ->
    if (isMethodCallExpression(call)
        && call.implicitThis
        && 'move'==name
        && argTypes.length==1
        && argTypes[0] == classNodeFor(int)
    ) {
        makeDynamic(call, classNodeFor(Robot))              
    }
}
```

|      | tell the compiler that the call should be make dynamic |
| ---- | ------------------------------------------------------ |
|      |                                                        |

The `makeDynamic` call does 3 things:

- it returns a virtual method just like `newMethod`
- automatically sets the `handled` flag to `true` for you
- but also marks the `call` to be done dynamically

So when the compiler will have to generate bytecode for the call to `move`, since it is now marked as a dynamic call, it will fallback to the dynamic compiler and let it handle the call. And since the extension tells us that the return type of the dynamic call is a `Robot`, subsequent calls will be done statically!

Some would wonder why the static compiler doesn’t do this by default without an extension. It is a design decision:

- if the code is statically compiled, we normally want type safety and best performance
- so if unrecognized variables/method calls are made dynamic, you loose type safety, but also all support for typos at compile time!

In short, if you want to have mixed mode compilation, it **has** to be explicit, through a type checking extension, so that the compiler, and the designer of the DSL, are totally aware of what they are doing.

`makeDynamic` can be used on 3 kind of AST nodes:

- a method node (`MethodNode`)
- a variable (`VariableExpression`)
- a property expression (`PropertyExpression`)

If that is not enough, then it means that static compilation cannot be done directly and that you have to rely on AST transformations.

###### Transforming the AST in an extension

Type checking extensions look very attractive from an AST transformation design point of view: extensions have access to context like inferred types, which is often nice to have. And an extension has a direct access to the abstract syntax tree. Since you have access to the AST, there is nothing in theory that prevents you from modifying the AST. However, we do not recommend you to do so, unless you are an advanced AST transformation designer and well aware of the compiler internals:

- First of all, you would explicitly break the contract of type checking, which is to annotate, and only annotate the AST. Type checking should **not** modify the AST tree because you wouldn’t be able to guarantee anymore that code without the *@TypeChecked* annotation behaves the same without the annotation.
- If your extension is meant to work with *@CompileStatic*, then you **can** modify the AST because this is indeed what *@CompileStatic* will eventually do. Static compilation doesn’t guarantee the same semantics at dynamic Groovy so there is effectively a difference between code compiled with *@CompileStatic* and code compiled with *@TypeChecked*. It’s up to you to choose whatever strategy you want to update the AST, but probably using an AST transformation that runs before type checking is easier.
- if you cannot rely on a transformation that kicks in before the type checker, then you must be **very** careful

|      | The type checking phase is the last phase running in the compiler before bytecode generation. All other AST transformations run before that and the compiler does a very good job at "fixing" incorrect AST generated before the type checking phase. As soon as you perform a transformation during type checking, for example directly in a type checking extension, then you have to do all this work of generating a 100% compiler compliant abstract syntax tree by yourself, which can easily become complex. That’s why we do not recommend to go that way if you are beginning with type checking extensions and AST transformations. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Examples

Examples of real life type checking extensions are easy to find. You can download the source code for Groovy and take a look at the [TypeCheckingExtensionsTest](https://github.com/apache/groovy/blob/master/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy) class which is linked to [various extension scripts](https://github.com/apache/groovy/tree/master/src/test-resources/groovy/transform/stc).

An example of a complex type checking extension can be found in the [Markup Template Engine](https://docs.groovy-lang.org/latest/html/documentation/markup-template-engine.html) source code: this template engine relies on a type checking extension and AST transformations to transform templates into fully statically compiled code. Sources for this can be found [here](https://github.com/apache/groovy/tree/master/subprojects/groovy-templates/src/main/groovy/groovy/text/markup).