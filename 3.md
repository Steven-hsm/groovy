## 3. User Guides

### 3.1. Getting started

#### 3.1.1. Download

In this download area, you will be able to download the distribution (binary and source), the Windows installer and the documentation for **Groovy**.

For a quick and effortless start on Mac OSX, Linux or Cygwin, you can use [SDKMAN!](http://sdkman.io/) (The Software Development Kit Manager) to download and configure any **Groovy** version of your choice. Basic [instructions](https://docs.groovy-lang.org/latest/html/documentation/#SDKMAN) can be found below.

##### Stable

- **Download zip**: [**Binary Release**](https://bintray.com/artifact/download/groovy/maven/apache-groovy-binary-3.0.3.zip) | [Source Release](https://bintray.com/artifact/download/groovy/maven/groovy-src-3.0.3.zip)
- **Download documentation**: [**JavaDoc and zipped online documentation**](https://bintray.com/artifact/download/groovy/maven/apache-groovy-docs-3.0.3.zip)
- **Combined binary / source / documentation bundle**: [**Distribution bundle**](https://bintray.com/artifact/download/groovy/maven/apache-groovy-sdk-3.0.3.zip)

You can learn more about this version in the [release notes](http://groovy-lang.org/releasenotes/groovy-3.0.html) or in the [changelog](http://groovy-lang.org/changelogs/changelog-3.0.3.html).

If you plan on using invokedynamic support, [read those notes](https://docs.groovy-lang.org/latest/html/documentation/invokedynamic-support.html).

##### Snapshots

For those who want to test the very latest versions of Groovy and live on the bleeding edge, you can use our [snapshot builds](https://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy). As soon as a build succeeds on our continuous integration server a snapshot is deployed to Artifactory’s OSS snapshot repository.

##### Prerequisites

Groovy 3.0 requires Java 6+ with full support up to Java 8. There are currently some known issues for some aspects when using Java 9 snapshots. The `groovy-nio` module requires Java 7+. Using Groovy’s invokeDynamic features require Java 7+ but we recommend Java 8.

The Groovy CI server is also useful to look at to confirm supported Java versions for different Groovy releases. The test suite (getting close to 10000 tests) runs for the currently supported streams of Groovy across all the main versions of Java each stream supports.

#### 3.1.2. Maven Repository

If you wish to embed Groovy in your application, you may just prefer to point to your favourite maven repositories or the [JCenter maven repository](https://oss.jfrog.org/oss-release-local/org/codehaus/groovy).

##### Stable Release

| Gradle                                     | Maven                                                        | Explanation                                                  |
| :----------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 'org.codehaus.groovy:groovy:3.0.3'         | <groupId>org.codehaus.groovy</groupId> <artifactId>groovy</artifactId> <version>3.0.3</version> | Just the core of groovy without the modules (see below).     |
| 'org.codehaus.groovy:groovy-$module:3.0.3' | <groupId>org.codehaus.groovy</groupId> <artifactId>groovy-$module</artifactId> <version>3.0.3</version> | "$module" stands for the different optional groovy modules "ant", "bsf", "console", "docgenerator", "groovydoc", "groovysh", "jmx", "json", "jsr223", "servlet", "sql", "swing", "test", "testng" and "xml". Example: <artifactId>groovy-sql</artifactId> |
| 'org.codehaus.groovy:groovy-all:3.0.3'     | <groupId>org.codehaus.groovy</groupId> <artifactId>groovy-all</artifactId> <version>3.0.3</version> <type>pom</type> <!-- required JUST since Groovy 2.5.0 --> | The core plus all the modules. Optional dependencies are marked as optional. You may need to include some of the optional dependencies to use some features of Groovy, e.g. AntBuilder, GroovyMBeans, etc. |

To use the [InvokeDynamic](https://docs.groovy-lang.org/latest/html/documentation/invokedynamic-support.html) version of the jars just append ':indy' for Gradle or <classifier>indy</classifier> for Maven.

#### 3.1.3. SDKMAN! (The Software Development Kit Manager)

This tool makes installing Groovy on any Bash platform (Mac OSX, Linux, Cygwin, Solaris or FreeBSD) very easy.

Simply open a new terminal and enter:

```shell
$ curl -s get.sdkman.io | bash
```

Follow the instructions on-screen to complete installation.

Open a new terminal or type the command:

```shell
$ source "$HOME/.sdkman/bin/sdkman-init.sh"
```

Then install the latest stable Groovy:

```shell
$ sdk install groovy
```

After installation is complete and you’ve made it your default version, test it with:

```shell
$ groovy -version
```

That’s all there is to it!

#### 3.1.4. Other ways to get Groovy

##### Installation on Mac OS X

###### MacPorts

If you’re on MacOS and have [MacPorts](http://www.macports.org/) installed, you can run:

```shell
sudo port install groovy
```

###### Homebrew

If you’re on MacOS and have [Homebrew](http://mxcl.github.com/homebrew) installed, you can run:

```shell
brew install groovy
```

##### Installation on Windows

If you’re on Windows, you can also use the [NSIS Windows installer](https://docs.groovy-lang.org/latest/html/documentation/TODO-Windows+NSIS-Installer).

##### Other Distributions

You may download other distributions of Groovy from [this site](https://bintray.com/groovy/maven).

##### Source Code

If you prefer to live on the bleeding edge, you can also grab the [source code from GitHub](https://github.com/apache/groovy).

##### IDE plugin

If you are an IDE user, you can just grab the latest [IDE plugin](https://docs.groovy-lang.org/latest/html/documentation/tools-ide.html) and follow the plugin installation instructions.

#### 3.1.5. Install Binary

These instructions describe how to install a binary distribution of **Groovy**.

- First, [Download](https://docs.groovy-lang.org/latest/html/documentation/#download-groovy) a binary distribution of Groovy and unpack it into some file on your local file system.
- Set your `GROOVY_HOME` environment variable to the directory you unpacked the distribution.
- Add `GROOVY_HOME/bin` to your `PATH` environment variable.
- Set your `JAVA_HOME` environment variable to point to your JDK. On OS X this is `/Library/Java/Home`, on other unixes its often `/usr/java` etc. If you’ve already installed tools like Ant or Maven you’ve probably already done this step.

You should now have Groovy installed properly. You can test this by typing the following in a command shell:

```shell
groovysh
```

Which should create an interactive groovy shell where you can type Groovy statements. Or to run the [Swing interactive console](https://docs.groovy-lang.org/latest/html/documentation/groovy-console.html#title-heading) type:

```shell
groovyConsole
```

To run a specific Groovy script type:

```shell
groovy SomeScript
```

### 3.2. Differences with Java

Groovy tries to be as natural as possible for Java developers. We’ve tried to follow the principle of least surprise when designing Groovy, particularly for developers learning Groovy who’ve come from a Java background.

Here we list all the major differences between Java and Groovy.

#### 3.2.1. Default imports

All these packages and classes are imported by default, i.e. you do not have to use an explicit `import` statement to use them:

- java.io.*
- java.lang.*
- java.math.BigDecimal
- java.math.BigInteger
- java.net.*
- java.util.*
- groovy.lang.*
- groovy.util.*

#### 3.2.2. Multi-methods

In Groovy, the methods which will be invoked are chosen at runtime. This is called runtime dispatch or multi-methods. It means that the method will be chosen based on the types of the arguments at runtime. In Java, this is the opposite: methods are chosen at compile time, based on the declared types.

The following code, written as Java code, can be compiled in both Java and Groovy, but it will behave differently:

```java
int method(String arg) {
    return 1;
}
int method(Object arg) {
    return 2;
}
Object o = "Object";
int result = method(o);
```

In Java, you would have:

```java
assertEquals(2, result);
```

Whereas in Groovy:

```java
assertEquals(1, result);
```

That is because Java will use the static information type, which is that `o` is declared as an `Object`, whereas Groovy will choose at runtime, when the method is actually called. Since it is called with a `String`, then the `String` version is called.

#### 3.2.3. Array initializers

In Java, array initializers take either of these two forms:

```java
int[] array = {1, 2, 3};             // Java array initializer shorthand syntax
int[] array2 = new int[] {4, 5, 6};  // Java array initializer long syntax
```

In Groovy, the `{ … }` block is reserved for closures. That means that you cannot create array literals using Java’s array initializer shorthand syntax. You instead borrow Groovy’s literal list notation like this:

```groovy
int[] array = [1, 2, 3]
```

For Groovy 3+, you can optionally use the Java’s array initializer long syntax:

```groovy
def array2 = new int[] {1, 2, 3} // Groovy 3.0+ supports the Java-style array initialization long syntax
```

#### 3.2.4. Package scope visibility

In Groovy, omitting a modifier on a field doesn’t result in a package-private field like in Java:

```groovy
class Person {
    String name
}
```

Instead, it is used to create a *property*, that is to say a *private field*, an associated *getter* and an associated *setter*.

It is possible to create a package-private field by annotating it with `@PackageScope`:

```groovy
class Person {
    @PackageScope String name
}
```

#### 3.2.5. ARM blocks

Java 7 introduced ARM (Automatic Resource Management) blocks like this:

```java
Path file = Paths.get("/path/to/file");
Charset charset = Charset.forName("UTF-8");
try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }

} catch (IOException e) {
    e.printStackTrace();
}
```

Such blocks are supported from Groovy 3+. However, Groovy provides various methods relying on closures, which have the same effect while being more idiomatic. For example:

```groovy
new File('/path/to/file').eachLine('UTF-8') {
   println it
}
```

or, if you want a version closer to Java:

```groovy
new File('/path/to/file').withReader('UTF-8') { reader ->
   reader.eachLine {
       println it
   }
}
```

#### 3.2.6. Inner classes

|      | The implementation of anonymous inner classes and nested classes follow Java closely, but there are some differences, e.g. local variables accessed from within such classes don’t have to be final. We piggy-back on some implementation details we use for `groovy.lang.Closure` when generating inner class bytecode. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Static inner classes

Here’s an example of static inner class:

```groovy
class A {
    static class B {}
}

new A.B()
```

The usage of static inner classes is the best supported one. If you absolutely need an inner class, you should make it a static one.

##### Anonymous Inner Classes

```groovy
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

CountDownLatch called = new CountDownLatch(1)

Timer timer = new Timer()
timer.schedule(new TimerTask() {
    void run() {
        called.countDown()
    }
}, 0)

assert called.await(10, TimeUnit.SECONDS)
```

##### Creating Instances of Non-Static Inner Classes

In Java you can do this:

```java
public class Y {
    public class X {}
    public X foo() {
        return new X();
    }
    public static X createX(Y y) {
        return y.new X();
    }
}
```

Before 3.0.0, Groovy doesn’t support the `y.new X()` syntax. Instead, you have to write `new X(y)`, like in the code below:

```groovy
public class Y {
    public class X {}
    public X foo() {
        return new X()
    }
    public static X createX(Y y) {
        return new X(y)
    }
}
```

|      | Caution though, Groovy supports calling methods with one parameter without giving an argument. The parameter will then have the value null. Basically the same rules apply to calling a constructor. There is a danger that you will write new X() instead of new X(this) for example. Since this might also be the regular way we have not yet found a good way to prevent this problem. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

|      | Groovy 3.0.0 supports Java style syntax for creating instances of non-static inner classes. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

#### 3.2.7. Lambda expressions and the method reference operator

Java 8+ supports lambda expressions and the method reference operator (`::`):

```java
Runnable run = () -> System.out.println("Run");  // Java
list.forEach(System.out::println);
```

Groovy 3 and above also support these within the Parrot parser. In earlier versions of Groovy you should use closures instead:

```groovy
Runnable run = { println 'run' }
list.each { println it } // or list.each(this.&println)
```

#### 3.2.8. GStrings

As double-quoted string literals are interpreted as `GString` values, Groovy may fail with compile error or produce subtly different code if a class with `String` literal containing a dollar character is compiled with Groovy and Java compiler.

While typically, Groovy will auto-cast between `GString` and `String` if an API declares the type of a parameter, beware of Java APIs that accept an `Object` parameter and then check the actual type.

#### 3.2.9. String and Character literals

Singly-quoted literals in Groovy are used for `String`, and double-quoted result in `String` or `GString`, depending whether there is interpolation in the literal.

```groovy
assert 'c'.getClass()==String
assert "c".getClass()==String
assert "c${1}".getClass() in GString
```

Groovy will automatically cast a single-character `String` to `char` only when assigning to a variable of type `char`. When calling methods with arguments of type `char` we need to either cast explicitly or make sure the value has been cast in advance.

```groovy
char a='a'
assert Character.digit(a, 16)==10 : 'But Groovy does boxing'
assert Character.digit((char) 'a', 16)==10

try {
  assert Character.digit('a', 16)==10
  assert false: 'Need explicit cast'
} catch(MissingMethodException e) {
}
```

Groovy supports two styles of casting and in the case of casting to `char` there are subtle differences when casting a multi-char strings. The Groovy style cast is more lenient and will take the first character, while the C-style cast will fail with exception.

```groovy
// for single char strings, both are the same
assert ((char) "c").class==Character
assert ("c" as char).class==Character

// for multi char strings they are not
try {
  ((char) 'cx') == 'c'
  assert false: 'will fail - not castable'
} catch(GroovyCastException e) {
}
assert ('cx' as char) == 'c'
assert 'cx'.asType(char) == 'c'
```

#### 3.2.10. Primitives and wrappers

Because Groovy uses Objects for everything, it [autowraps](https://docs.groovy-lang.org/latest/html/documentation/core-object-orientation.html#_primitive_types) references to primitives. Because of this, it does not follow Java’s behavior of widening taking priority over boxing. Here’s an example using `int`

```groovy
int i
m(i)

void m(long l) {           
  println "in m(long)"
}

void m(Integer i) {        
  println "in m(Integer)"
}
```

|      | This is the method that Java would call, since widening has precedence over unboxing. |
| ---- | ------------------------------------------------------------ |
|      | This is the method Groovy actually calls, since all primitive references use their wrapper class. |

#### 3.2.11. Behaviour of `==`

In Java `==` means equality of primitive types or identity for objects. In Groovy `==` means equality in all cases. It translates to `a.compareTo(b) == 0`, when evaluating equality for `Comparable` objects, and `a.equals(b)` otherwise. To check for identity (reference equality), use the `is` method: `a.is(b)`. From Groovy 3, you can also use the `===` operator (or negated version): `a === b` (or `c !== d`).

#### 3.2.12. Conversions

Java does automatic widening and narrowing [conversions](https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html).

|                   | **Converts to** |          |           |          |         |          |           |            |
| ----------------- | --------------- | -------- | --------- | -------- | ------- | -------- | --------- | ---------- |
| **Converts from** | **boolean**     | **byte** | **short** | **char** | **int** | **long** | **float** | **double** |
| **boolean**       | -               | N        | N         | N        | N       | N        | N         | N          |
| **byte**          | N               | -        | Y         | C        | Y       | Y        | Y         | Y          |
| **short**         | N               | C        | -         | C        | Y       | Y        | Y         | Y          |
| **char**          | N               | C        | C         | -        | Y       | Y        | Y         | Y          |
| **int**           | N               | C        | C         | C        | -       | Y        | T         | Y          |
| **long**          | N               | C        | C         | C        | C       | -        | T         | T          |
| **float**         | N               | C        | C         | C        | C       | C        | -         | Y          |
| **double**        | N               | C        | C         | C        | C       | C        | C         | -          |

\* 'Y' indicates a conversion Java can make, 'C' indicates a conversion Java can make when there is an explicit cast, 'T` indicates a conversion Java can make but data is truncated, 'N' indicates a conversion Java can’t make.

Groovy expands greatly on this.

|                   | **Converts to** |             |          |          |           |           |          |               |         |             |          |          |                |           |           |            |            |                |
| ----------------- | --------------- | ----------- | -------- | -------- | --------- | --------- | -------- | ------------- | ------- | ----------- | -------- | -------- | -------------- | --------- | --------- | ---------- | ---------- | -------------- |
| **Converts from** | **boolean**     | **Boolean** | **byte** | **Byte** | **short** | **Short** | **char** | **Character** | **int** | **Integer** | **long** | **Long** | **BigInteger** | **float** | **Float** | **double** | **Double** | **BigDecimal** |
| **boolean**       | -               | B           | N        | N        | N         | N         | N        | N             | N       | N           | N        | N        | N              | N         | N         | N          | N          | N              |
| **Boolean**       | B               | -           | N        | N        | N         | N         | N        | N             | N       | N           | N        | N        | N              | N         | N         | N          | N          | N              |
| **byte**          | T               | T           | -        | B        | Y         | Y         | Y        | D             | Y       | Y           | Y        | Y        | Y              | Y         | Y         | Y          | Y          | Y              |
| **Byte**          | T               | T           | B        | -        | Y         | Y         | Y        | D             | Y       | Y           | Y        | Y        | Y              | Y         | Y         | Y          | Y          | Y              |
| **short**         | T               | T           | D        | D        | -         | B         | Y        | D             | Y       | Y           | Y        | Y        | Y              | Y         | Y         | Y          | Y          | Y              |
| **Short**         | T               | T           | D        | T        | B         | -         | Y        | D             | Y       | Y           | Y        | Y        | Y              | Y         | Y         | Y          | Y          | Y              |
| **char**          | T               | T           | Y        | D        | Y         | D         | -        | D             | Y       | D           | Y        | D        | D              | Y         | D         | Y          | D          | D              |
| **Character**     | T               | T           | D        | D        | D         | D         | D        | -             | D       | D           | D        | D        | D              | D         | D         | D          | D          | D              |
| **int**           | T               | T           | D        | D        | D         | D         | Y        | D             | -       | B           | Y        | Y        | Y              | Y         | Y         | Y          | Y          | Y              |
| **Integer**       | T               | T           | D        | D        | D         | D         | Y        | D             | B       | -           | Y        | Y        | Y              | Y         | Y         | Y          | Y          | Y              |
| **long**          | T               | T           | D        | D        | D         | D         | Y        | D             | D       | D           | -        | B        | Y              | T         | T         | T          | T          | Y              |
| **Long**          | T               | T           | D        | D        | D         | T         | Y        | D             | D       | T           | B        | -        | Y              | T         | T         | T          | T          | Y              |
| **BigInteger**    | T               | T           | D        | D        | D         | D         | D        | D             | D       | D           | D        | D        | -              | D         | D         | D          | D          | T              |
| **float**         | T               | T           | D        | D        | D         | D         | T        | D             | D       | D           | D        | D        | D              | -         | B         | Y          | Y          | Y              |
| **Float**         | T               | T           | D        | T        | D         | T         | T        | D             | D       | T           | D        | T        | D              | B         | -         | Y          | Y          | Y              |
| **double**        | T               | T           | D        | D        | D         | D         | T        | D             | D       | D           | D        | D        | D              | D         | D         | -          | B          | Y              |
| **Double**        | T               | T           | D        | T        | D         | T         | T        | D             | D       | T           | D        | T        | D              | D         | T         | B          | -          | Y              |
| **BigDecimal**    | T               | T           | D        | D        | D         | D         | D        | D             | D       | D           | D        | D        | D              | T         | D         | T          | D          | -              |

\* 'Y' indicates a conversion Groovy can make, 'D' indicates a conversion Groovy can make when compiled dynamically or explicitly cast, 'T` indicates a conversion Groovy can make but data is truncated, 'B' indicates a boxing/unboxing operation, 'N' indicates a conversion Groovy can’t make.

The truncation uses [Groovy Truth](https://docs.groovy-lang.org/latest/html/documentation/#Groovy-Truth) when converting to `boolean`/`Boolean`. Converting from a number to a character casts the `Number.intvalue()` to `char`. Groovy constructs `BigInteger` and `BigDecimal` using `Number.doubleValue()` when converting from a `Float` or `Double`, otherwise it constructs using `toString()`. Other conversions have their behavior defined by `java.lang.Number`.

#### 3.2.13. Extra keywords

Groovy has many of the same keywords as Java and Groovy 3 also has the same `var` reserved type as Java. In addition, Groovy has the following keywords:

- `as`
- `def`
- `in`
- `trait`
- `it` // within closures

Groovy is less stringent that Java in that it allows some keywords to appear in places that would be illegal in Java, e.g. the following is valid: `var var = [def: 1, as: 2, in: 3, trait: 4]`. Never-the-less, you are discouraged from using the above keywords in places that might cause confusion even when the compiler might be happy. In particular, avoid using them for variable, method and class names, so our previous `var var` example would be considered poor style.

### 3.3. Groovy Development Kit

#### 3.3.1. Working with IO

Groovy provides a number of [helper methods](https://docs.groovy-lang.org/latest/html/documentation/gdk.html) for working with I/O. While you could use standard Java code in Groovy to deal with those, Groovy provides much more convenient ways to handle files, streams, readers, …

In particular, you should take a look at methods added to:

- the `java.io.File` class : http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html
- the `java.io.InputStream` class: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html
- the `java.io.OutputStream` class: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html
- the `java.io.Reader` class: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html
- the `java.io.Writer` class: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html
- the `java.nio.file.Path` class: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html

The following section focuses on sample idiomatic constructs using helper methods available above but is not meant to be a complete description of all available methods. For that, please read the [GDK API](https://docs.groovy-lang.org/latest/html/documentation/gdk.html).

##### Reading files

As a first example, let’s see how you would print all lines of a text file in Groovy:

```groovy
new File(baseDir, 'haiku.txt').eachLine { line ->
    println line
}
```

The `eachLine` method is a method added to the `File` class automatically by Groovy and has many variants, for example if you need to know the line number, you can use this variant:

```groovy
new File(baseDir, 'haiku.txt').eachLine { line, nb ->
    println "Line $nb: $line"
}
```

If for whatever reason an exception is thrown in the `eachLine` body, the method makes sure that the resource is properly closed. This is true for all I/O resource methods that Groovy adds.

For example in some cases you will prefer to use a `Reader`, but still benefit from the automatic resource management from Groovy. In the next example, the reader **will** be closed even if the exception occurs:

```groovy
def count = 0, MAXSIZE = 3
new File(baseDir,"haiku.txt").withReader { reader ->
    while (reader.readLine()) {
        if (++count > MAXSIZE) {
            throw new RuntimeException('Haiku should only have 3 verses')
        }
    }
}
```

Should you need to collect the lines of a text file into a list, you can do:

```groovy
def list = new File(baseDir, 'haiku.txt').collect {it}
```

Or you can even leverage the `as` operator to get the contents of the file into an array of lines:

```groovy
def array = new File(baseDir, 'haiku.txt') as String[]
```

How many times did you have to get the contents of a file into a `byte[]` and how much code does it require? Groovy makes it very easy actually:

```groovy
byte[] contents = file.bytes
```

Working with I/O is not limited to dealing with files. In fact, a lot of operations rely on input/output streams, hence why Groovy adds a lot of support methods to those, as you can see in the [documentation](http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html).

As an example, you can obtain an `InputStream` from a `File` very easily:

```groovy
def is = new File(baseDir,'haiku.txt').newInputStream()
// do something ...
is.close()
```

However you can see that it requires you to deal with closing the inputstream. In Groovy it is in general a better idea to use the `withInputStream` idiom that will take care of that for you:

```groovy
new File(baseDir,'haiku.txt').withInputStream { stream ->
    // do something ...
}
```

##### Writing files

Of course in some cases you won’t want to read but write a file. One of the options is to use a `Writer`:

```groovy
new File(baseDir,'haiku.txt').withWriter('utf-8') { writer ->
    writer.writeLine 'Into the ancient pond'
    writer.writeLine 'A frog jumps'
    writer.writeLine 'Water’s sound!'
}
```

But for such a simple example, using the `<<` operator would have been enough:

```groovy
new File(baseDir,'haiku.txt') << '''Into the ancient pond
A frog jumps
Water’s sound!'''
```

Of course we do not always deal with text contents, so you could use the `Writer` or directly write bytes as in this example:

```groovy
file.bytes = [66,22,11]
```

Of course you can also directly deal with output streams. For example, here is how you would create an output stream to write into a file:

```groovy
def os = new File(baseDir,'data.bin').newOutputStream()
// do something ...
os.close()
```

However you can see that it requires you to deal with closing the output stream. Again it is in general a better idea to use the `withOutputStream` idiom that will handle the exceptions and close the stream in any case:

```groovy
new File(baseDir,'data.bin').withOutputStream { stream ->
    // do something ...
}
```

##### Traversing file trees

In scripting contexts it is a common task to traverse a file tree in order to find some specific files and do something with them. Groovy provides multiple methods to do this. For example you can perform something on all files of a directory:

```groovy
dir.eachFile { file ->                      
    println file.name
}
dir.eachFileMatch(~/.*\.txt/) { file ->     
    println file.name
}
```

|      | executes the closure code on each file found in the directory |
| ---- | ------------------------------------------------------------ |
|      | executes the closure code on files in the directory matching the specified pattern |

Often you will have to deal with a deeper hierarchy of files, in which case you can use `eachFileRecurse`:

```groovy
dir.eachFileRecurse { file ->                      
    println file.name
}

dir.eachFileRecurse(FileType.FILES) { file ->      
    println file.name
}
```

|      | executes the closure code on each file or directory found in the directory, recursively |
| ---- | ------------------------------------------------------------ |
|      | executes the closure code only on files, but recursively     |

For more complex traversal techniques you can use the `traverse` method, which requires you to set a special flag indicating what to do with the traversal:

```groovy
dir.traverse { file ->
    if (file.directory && file.name=='bin') {
        FileVisitResult.TERMINATE                   
    } else {
        println file.name
        FileVisitResult.CONTINUE                    
    }

}
```

|      | if the current file is a directory and its name is `bin`, stop the traversal |
| ---- | ------------------------------------------------------------ |
|      | otherwise print the file name and continue                   |

##### Data and objects

In Java it is not uncommon to serialize and deserialize data using the `java.io.DataOutputStream` and `java.io.DataInputStream` classes respectively. Groovy will make it even easier to deal with them. For example, you could serialize data into a file and deserialize it using this code:

```groovy
boolean b = true
String message = 'Hello from Groovy'
// Serialize data into a file
file.withDataOutputStream { out ->
    out.writeBoolean(b)
    out.writeUTF(message)
}
// ...
// Then read it back
file.withDataInputStream { input ->
    assert input.readBoolean() == b
    assert input.readUTF() == message
}
```

And similarily, if the data you want to serialize implements the `Serializable` interface, you can proceed with an object output stream, as illustrated here:

```groovy
Person p = new Person(name:'Bob', age:76)
// Serialize data into a file
file.withObjectOutputStream { out ->
    out.writeObject(p)
}
// ...
// Then read it back
file.withObjectInputStream { input ->
    def p2 = input.readObject()
    assert p2.name == p.name
    assert p2.age == p.age
}
```

##### Executing External Processes

The previous section described how easy it was to deal with files, readers or streams in Groovy. However in domains like system administration or devops it is often required to communicate with external processes.

Groovy provides a simple way to execute command line processes. Simply write the command line as a string and call the `execute()` method. E.g., on a *nix machine (or a windows machine with appropriate *nix commands installed), you can execute this:

```groovy
def process = "ls -l".execute()             
println "Found text ${process.text}"        
```

|      | executes the `ls` command in an external process        |
| ---- | ------------------------------------------------------- |
|      | consume the output of the command and retrieve the text |

The `execute()` method returns a `java.lang.Process` instance which will subsequently allow the in/out/err streams to be processed and the exit value from the process to be inspected etc.

e.g. here is the same command as above but we will now process the resulting stream a line at a time:

```groovy
def process = "ls -l".execute()             
process.in.eachLine { line ->               
    println line                            
}
```

|      | executes the `ls` command in an external process |
| ---- | ------------------------------------------------ |
|      | for each line of the input stream of the process |
|      | print the line                                   |

It is worth noting that `in` corresponds to an input stream to the standard output of the command. `out` will refer to a stream where you can send data to the process (its standard input).

Remember that many commands are shell built-ins and need special handling. So if you want a listing of files in a directory on a Windows machine and write:

```groovy
def process = "dir".execute()
println "${process.text}"
```

you will receive an `IOException` saying *Cannot run program "dir": CreateProcess error=2, The system cannot find the file specified.*

This is because `dir` is built-in to the Windows shell (`cmd.exe`) and can’t be run as a simple executable. Instead, you will need to write:

```groovy
def process = "cmd /c dir".execute()
println "${process.text}"
```

Also, because this functionality currently makes use of `java.lang.Process` undercover, the deficiencies of that class must be taken into consideration. In particular, the javadoc for this class says:

> Because some native platforms only provide limited buffer size for standard input and output streams, failure to promptly write the input stream or read the output stream of the subprocess may cause the subprocess to block, and even deadlock

Because of this, Groovy provides some additional helper methods which make stream handling for processes easier.

Here is how to gobble all of the output (including the error stream output) from your process:

```groovy
def p = "rm -f foo.tmp".execute([], tmpDir)
p.consumeProcessOutput()
p.waitFor()
```

There are also variations of `consumeProcessOutput` that make use of `StringBuffer`, `InputStream`, `OutputStream` etc… For a complete list, please read the [GDK API for java.lang.Process](http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Process.html)

In addition, these is a `pipeTo` command (mapped to `|` to allow overloading) which lets the output stream of one process be fed into the input stream of another process.

Here are some examples of use:

Pipes in action

```groovy
proc1 = 'ls'.execute()
proc2 = 'tr -d o'.execute()
proc3 = 'tr -d e'.execute()
proc4 = 'tr -d i'.execute()
proc1 | proc2 | proc3 | proc4
proc4.waitFor()
if (proc4.exitValue()) {
    println proc4.err.text
} else {
    println proc4.text
}
```

Consuming errors

```groovy
def sout = new StringBuilder()
def serr = new StringBuilder()
proc2 = 'tr -d o'.execute()
proc3 = 'tr -d e'.execute()
proc4 = 'tr -d i'.execute()
proc4.consumeProcessOutput(sout, serr)
proc2 | proc3 | proc4
[proc2, proc3].each { it.consumeProcessErrorStream(serr) }
proc2.withWriter { writer ->
    writer << 'testfile.groovy'
}
proc4.waitForOrKill(1000)
println "Standard output: $sout"
println "Standard error: $serr"
```

#### 3.3.2. Working with collections

Groovy provides native support for various collection types, including [lists](https://docs.groovy-lang.org/latest/html/documentation/#Collections-Lists), [maps](https://docs.groovy-lang.org/latest/html/documentation/#Collections-Maps) or [ranges](https://docs.groovy-lang.org/latest/html/documentation/#Collections-Ranges). Most of those are based on the Java collection types and decorated with additional methods found in the [Groovy development kit](http://www.groovy-lang.org/gdk.html).

##### Lists

###### List literals

You can create lists as follows. Notice that `[]` is the empty list expression.

```groovy
def list = [5, 6, 7, 8]
assert list.get(2) == 7
assert list[2] == 7
assert list instanceof java.util.List

def emptyList = []
assert emptyList.size() == 0
emptyList.add(5)
assert emptyList.size() == 1
```

Each list expression creates an implementation of [java.util.List](http://docs.oracle.com/javase/8/docs/api/java/util/List.html).

Of course lists can be used as a source to construct another list:

```groovy
def list1 = ['a', 'b', 'c']
//construct a new list, seeded with the same items as in list1
def list2 = new ArrayList<String>(list1)

assert list2 == list1 // == checks that each corresponding element is the same

// clone() can also be called
def list3 = list1.clone()
assert list3 == list1
```

A list is an ordered collection of objects:

```groovy
def list = [5, 6, 7, 8]
assert list.size() == 4
assert list.getClass() == ArrayList     // the specific kind of list being used

assert list[2] == 7                     // indexing starts at 0
assert list.getAt(2) == 7               // equivalent method to subscript operator []
assert list.get(2) == 7                 // alternative method

list[2] = 9
assert list == [5, 6, 9, 8,]           // trailing comma OK

list.putAt(2, 10)                       // equivalent method to [] when value being changed
assert list == [5, 6, 10, 8]
assert list.set(2, 11) == 10            // alternative method that returns old value
assert list == [5, 6, 11, 8]

assert ['a', 1, 'a', 'a', 2.5, 2.5f, 2.5d, 'hello', 7g, null, 9 as byte]
//objects can be of different types; duplicates allowed

assert [1, 2, 3, 4, 5][-1] == 5             // use negative indices to count from the end
assert [1, 2, 3, 4, 5][-2] == 4
assert [1, 2, 3, 4, 5].getAt(-2) == 4       // getAt() available with negative index...
try {
    [1, 2, 3, 4, 5].get(-2)                 // but negative index not allowed with get()
    assert false
} catch (e) {
    assert e instanceof IndexOutOfBoundsException
}
```

###### List as a boolean expression

Lists can be evaluated as a `boolean` value:

```groovy
assert ![]             // an empty list evaluates as false

//all other lists, irrespective of contents, evaluate as true
assert [1] && ['a'] && [0] && [0.0] && [false] && [null]
```

###### Iterating on a list

Iterating on elements of a list is usually done calling the `each` and `eachWithIndex` methods, which execute code on each item of a list:

```groovy
[1, 2, 3].each {
    println "Item: $it" // `it` is an implicit parameter corresponding to the current element
}
['a', 'b', 'c'].eachWithIndex { it, i -> // `it` is the current element, while `i` is the index
    println "$i: $it"
}
```

In addition to iterating, it is often useful to create a new list by transforming each of its elements into something else. This operation, often called mapping, is done in Groovy thanks to the `collect` method:

```groovy
assert [1, 2, 3].collect { it * 2 } == [2, 4, 6]

// shortcut syntax instead of collect
assert [1, 2, 3]*.multiply(2) == [1, 2, 3].collect { it.multiply(2) }

def list = [0]
// it is possible to give `collect` the list which collects the elements
assert [1, 2, 3].collect(list) { it * 2 } == [0, 2, 4, 6]
assert list == [0, 2, 4, 6]
```

###### Manipulating lists

Filtering and searching

The [Groovy development kit](http://www.groovy-lang.org/gdk.html) contains a lot of methods on collections that enhance the standard collections with pragmatic methods, some of which are illustrated here:

```groovy
assert [1, 2, 3].find { it > 1 } == 2           // find 1st element matching criteria
assert [1, 2, 3].findAll { it > 1 } == [2, 3]   // find all elements matching critieria
assert ['a', 'b', 'c', 'd', 'e'].findIndexOf {      // find index of 1st element matching criteria
    it in ['c', 'e', 'g']
} == 2

assert ['a', 'b', 'c', 'd', 'c'].indexOf('c') == 2  // index returned
assert ['a', 'b', 'c', 'd', 'c'].indexOf('z') == -1 // index -1 means value not in list
assert ['a', 'b', 'c', 'd', 'c'].lastIndexOf('c') == 4

assert [1, 2, 3].every { it < 5 }               // returns true if all elements match the predicate
assert ![1, 2, 3].every { it < 3 }
assert [1, 2, 3].any { it > 2 }                 // returns true if any element matches the predicate
assert ![1, 2, 3].any { it > 3 }

assert [1, 2, 3, 4, 5, 6].sum() == 21                // sum anything with a plus() method
assert ['a', 'b', 'c', 'd', 'e'].sum {
    it == 'a' ? 1 : it == 'b' ? 2 : it == 'c' ? 3 : it == 'd' ? 4 : it == 'e' ? 5 : 0
    // custom value to use in sum
} == 15
assert ['a', 'b', 'c', 'd', 'e'].sum { ((char) it) - ((char) 'a') } == 10
assert ['a', 'b', 'c', 'd', 'e'].sum() == 'abcde'
assert [['a', 'b'], ['c', 'd']].sum() == ['a', 'b', 'c', 'd']

// an initial value can be provided
assert [].sum(1000) == 1000
assert [1, 2, 3].sum(1000) == 1006

assert [1, 2, 3].join('-') == '1-2-3'           // String joining
assert [1, 2, 3].inject('counting: ') {
    str, item -> str + item                     // reduce operation
} == 'counting: 123'
assert [1, 2, 3].inject(0) { count, item ->
    count + item
} == 6
```

And here is idiomatic Groovy code for finding the maximum and minimum in a collection:

```groovy
def list = [9, 4, 2, 10, 5]
assert list.max() == 10
assert list.min() == 2

// we can also compare single characters, as anything comparable
assert ['x', 'y', 'a', 'z'].min() == 'a'

// we can use a closure to specify the sorting behaviour
def list2 = ['abc', 'z', 'xyzuvw', 'Hello', '321']
assert list2.max { it.size() } == 'xyzuvw'
assert list2.min { it.size() } == 'z'
```

In addition to closures, you can use a `Comparator` to define the comparison criteria:

```groovy
Comparator mc = { a, b -> a == b ? 0 : (a < b ? -1 : 1) }

def list = [7, 4, 9, -6, -1, 11, 2, 3, -9, 5, -13]
assert list.max(mc) == 11
assert list.min(mc) == -13

Comparator mc2 = { a, b -> a == b ? 0 : (Math.abs(a) < Math.abs(b)) ? -1 : 1 }


assert list.max(mc2) == -13
assert list.min(mc2) == -1

assert list.max { a, b -> a.equals(b) ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } == -13
assert list.min { a, b -> a.equals(b) ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } == -1
```

Adding or removing elements

We can use `[]` to assign a new empty list and `<<` to append items to it:

```groovy
def list = []
assert list.empty

list << 5
assert list.size() == 1

list << 7 << 'i' << 11
assert list == [5, 7, 'i', 11]

list << ['m', 'o']
assert list == [5, 7, 'i', 11, ['m', 'o']]

//first item in chain of << is target list
assert ([1, 2] << 3 << [4, 5] << 6) == [1, 2, 3, [4, 5], 6]

//using leftShift is equivalent to using <<
assert ([1, 2, 3] << 4) == ([1, 2, 3].leftShift(4))
```

We can add to a list in many ways:

```groovy
assert [1, 2] + 3 + [4, 5] + 6 == [1, 2, 3, 4, 5, 6]
// equivalent to calling the `plus` method
assert [1, 2].plus(3).plus([4, 5]).plus(6) == [1, 2, 3, 4, 5, 6]

def a = [1, 2, 3]
a += 4      // creates a new list and assigns it to `a`
a += [5, 6]
assert a == [1, 2, 3, 4, 5, 6]

assert [1, *[222, 333], 456] == [1, 222, 333, 456]
assert [*[1, 2, 3]] == [1, 2, 3]
assert [1, [2, 3, [4, 5], 6], 7, [8, 9]].flatten() == [1, 2, 3, 4, 5, 6, 7, 8, 9]

def list = [1, 2]
list.add(3)
list.addAll([5, 4])
assert list == [1, 2, 3, 5, 4]

list = [1, 2]
list.add(1, 3) // add 3 just before index 1
assert list == [1, 3, 2]

list.addAll(2, [5, 4]) //add [5,4] just before index 2
assert list == [1, 3, 5, 4, 2]

list = ['a', 'b', 'z', 'e', 'u', 'v', 'g']
list[8] = 'x' // the [] operator is growing the list as needed
// nulls inserted if required
assert list == ['a', 'b', 'z', 'e', 'u', 'v', 'g', null, 'x']
```

It is however important that the `+` operator on a list is **not mutating**. Compared to `<<`, it will create a new list, which is often not what you want and can lead to performance issues.

The [Groovy development kit](http://www.groovy-lang.org/gdk.html) also contains methods allowing you to easily remove elements from a list by value:

```groovy
assert ['a','b','c','b','b'] - 'c' == ['a','b','b','b']
assert ['a','b','c','b','b'] - 'b' == ['a','c']
assert ['a','b','c','b','b'] - ['b','c'] == ['a']

def list = [1,2,3,4,3,2,1]
list -= 3           // creates a new list by removing `3` from the original one
assert list == [1,2,4,2,1]
assert ( list -= [2,4] ) == [1,1]
```

It is also possible to remove an element by passing its index to the `remove` method, in which case the list is mutated:

```groovy
def list = ['a','b','c','d','e','f','b','b','a']
assert list.remove(2) == 'c'        // remove the third element, and return it
assert list == ['a','b','d','e','f','b','b','a']
```

In case you only want to remove the first element having the same value in a list, instead of removing all elements, you can call the `remove` method passing the value:

```groovy
def list= ['a','b','c','b','b']
assert list.remove('c')             // remove 'c', and return true because element removed
assert list.remove('b')             // remove first 'b', and return true because element removed

assert ! list.remove('z')           // return false because no elements removed
assert list == ['a','b','b']
```

As you can see, there are two `remove` methods available. One that takes an integer and removes an element by its index, and another that will remove the first element that matches the passed value. So what should we do when we have a list of integers? In this case, you may wish to use `removeAt` to remove an element by its index, and `removeElement` to remove the first element that matches a value.

```groovy
def list = [1,2,3,4,5,6,2,2,1]

assert list.remove(2) == 3          // this removes the element at index 2, and returns it
assert list == [1,2,4,5,6,2,2,1]

assert list.removeElement(2)        // remove first 2 and return true
assert list == [1,4,5,6,2,2,1]

assert ! list.removeElement(8)      // return false because 8 is not in the list
assert list == [1,4,5,6,2,2,1]

assert list.removeAt(1) == 4        // remove element at index 1, and return it
assert list == [1,5,6,2,2,1]
```

Of course, `removeAt` and `removeElement` will work with lists of any type.

Additionally, removing all the elements in a list can be done by calling the `clear` method:

```groovy
def list= ['a',2,'c',4]
list.clear()
assert list == []
```

Set operations

The [Groovy development kit](http://www.groovy-lang.org/gdk.html) also includes methods making it easy to reason on sets:

```groovy
assert 'a' in ['a','b','c']             // returns true if an element belongs to the list
assert ['a','b','c'].contains('a')      // equivalent to the `contains` method in Java
assert [1,3,4].containsAll([1,4])       // `containsAll` will check that all elements are found

assert [1,2,3,3,3,3,4,5].count(3) == 4  // count the number of elements which have some value
assert [1,2,3,3,3,3,4,5].count {
    it%2==0                             // count the number of elements which match the predicate
} == 2

assert [1,2,4,6,8,10,12].intersect([1,3,6,9,12]) == [1,6,12]

assert [1,2,3].disjoint( [4,6,9] )
assert ![1,2,3].disjoint( [2,4,6] )
```

Sorting

Working with collections often implies sorting. Groovy offers a variety of options to sort lists, from using closures to comparators, as in the following examples:

```groovy
assert [6, 3, 9, 2, 7, 1, 5].sort() == [1, 2, 3, 5, 6, 7, 9]

def list = ['abc', 'z', 'xyzuvw', 'Hello', '321']
assert list.sort {
    it.size()
} == ['z', 'abc', '321', 'Hello', 'xyzuvw']

def list2 = [7, 4, -6, -1, 11, 2, 3, -9, 5, -13]
assert list2.sort { a, b -> a == b ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } ==
        [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]

Comparator mc = { a, b -> a == b ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 }

// JDK 8+ only
// list2.sort(mc)
// assert list2 == [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]

def list3 = [6, -3, 9, 2, -7, 1, 5]

Collections.sort(list3)
assert list3 == [-7, -3, 1, 2, 5, 6, 9]

Collections.sort(list3, mc)
assert list3 == [1, 2, -3, 5, 6, -7, 9]
```

Duplicating elements

The [Groovy development kit](http://www.groovy-lang.org/gdk.html) also takes advantage of operator overloading to provide methods allowing duplication of elements of a list:

```groovy
assert [1, 2, 3] * 3 == [1, 2, 3, 1, 2, 3, 1, 2, 3]
assert [1, 2, 3].multiply(2) == [1, 2, 3, 1, 2, 3]
assert Collections.nCopies(3, 'b') == ['b', 'b', 'b']

// nCopies from the JDK has different semantics than multiply for lists
assert Collections.nCopies(2, [1, 2]) == [[1, 2], [1, 2]] //not [1,2,1,2]
```

##### Maps

###### Map literals

In Groovy, maps (also known as associative arrays) can be created using the map literal syntax: `[:]`:

```groovy
def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.get('name') == 'Gromit'
assert map.get('id') == 1234
assert map['name'] == 'Gromit'
assert map['id'] == 1234
assert map instanceof java.util.Map

def emptyMap = [:]
assert emptyMap.size() == 0
emptyMap.put("foo", 5)
assert emptyMap.size() == 1
assert emptyMap.get("foo") == 5
```

Map keys are strings by default: `[a:1]` is equivalent to `['a':1]`. This can be confusing if you define a variable named `a` and that you want the **value** of `a` to be the key in your map. If this is the case, then you **must** escape the key by adding parenthesis, like in the following example:

```groovy
def a = 'Bob'
def ages = [a: 43]
assert ages['Bob'] == null // `Bob` is not found
assert ages['a'] == 43     // because `a` is a literal!

ages = [(a): 43]            // now we escape `a` by using parenthesis
assert ages['Bob'] == 43   // and the value is found!
```

In addition to map literals, it is possible, to get a new copy of a map, to clone it:

```groovy
def map = [
        simple : 123,
        complex: [a: 1, b: 2]
]
def map2 = map.clone()
assert map2.get('simple') == map.get('simple')
assert map2.get('complex') == map.get('complex')
map2.get('complex').put('c', 3)
assert map.get('complex').get('c') == 3
```

The resulting map is a **shallow** copy of the original one, as illustrated in the previous example.

###### Map property notation

Maps also act like beans so you can use the property notation to get/set items inside the `Map` as long as the keys are strings which are valid Groovy identifiers:

```groovy
def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.name == 'Gromit'     // can be used instead of map.get('name')
assert map.id == 1234

def emptyMap = [:]
assert emptyMap.size() == 0
emptyMap.foo = 5
assert emptyMap.size() == 1
assert emptyMap.foo == 5
```

Note: by design `map.foo` will always look for the key `foo` in the map. This means `foo.class` will return `null` on a map that doesn’t contain the `class` key. Should you really want to know the class, then you must use `getClass()`:

```groovy
def map = [name: 'Gromit', likes: 'cheese', id: 1234]
assert map.class == null
assert map.get('class') == null
assert map.getClass() == LinkedHashMap // this is probably what you want

map = [1      : 'a',
       (true) : 'p',
       (false): 'q',
       (null) : 'x',
       'null' : 'z']
assert map.containsKey(1) // 1 is not an identifier so used as is
assert map.true == null
assert map.false == null
assert map.get(true) == 'p'
assert map.get(false) == 'q'
assert map.null == 'z'
assert map.get(null) == 'x'
```

###### Iterating on maps

As usual in the [Groovy development kit](http://www.groovy-lang.org/gdk.html), idiomatic iteration on maps makes use of the `each` and `eachWithIndex` methods. It’s worth noting that maps created using the map literal notation are **ordered**, that is to say that if you iterate on map entries, it is guaranteed that the entries will be returned in the same order they were added in the map.

```groovy
def map = [
        Bob  : 42,
        Alice: 54,
        Max  : 33
]

// `entry` is a map entry
map.each { entry ->
    println "Name: $entry.key Age: $entry.value"
}

// `entry` is a map entry, `i` the index in the map
map.eachWithIndex { entry, i ->
    println "$i - Name: $entry.key Age: $entry.value"
}

// Alternatively you can use key and value directly
map.each { key, value ->
    println "Name: $key Age: $value"
}

// Key, value and i as the index in the map
map.eachWithIndex { key, value, i ->
    println "$i - Name: $key Age: $value"
}
```

###### Manipulating maps

Adding or removing elements

Adding an element to a map can be done either using the `put` method, the subscript operator or using `putAll`:

```groovy
def defaults = [1: 'a', 2: 'b', 3: 'c', 4: 'd']
def overrides = [2: 'z', 5: 'x', 13: 'x']

def result = new LinkedHashMap(defaults)
result.put(15, 't')
result[17] = 'u'
result.putAll(overrides)
assert result == [1: 'a', 2: 'z', 3: 'c', 4: 'd', 5: 'x', 13: 'x', 15: 't', 17: 'u']
```

Removing all the elements of a map can be done by calling the `clear` method:

```groovy
def m = [1:'a', 2:'b']
assert m.get(1) == 'a'
m.clear()
assert m == [:]
```

Maps generated using the map literal syntax are using the object `equals` and `hashcode` methods. This means that you should **never** use an object which hash code is subject to change over time, or you wouldn’t be able to get the associated value back.

It is also worth noting that you should **never** use a `GString` as the key of a map, because the hash code of a `GString` is not the same as the hash code of an equivalent `String`:

```groovy
def key = 'some key'
def map = [:]
def gstringKey = "${key.toUpperCase()}"
map.put(gstringKey,'value')
assert map.get('SOME KEY') == null
```

Keys, values and entries

We can inspect the keys, values, and entries in a view:

```groovy
def map = [1:'a', 2:'b', 3:'c']

def entries = map.entrySet()
entries.each { entry ->
  assert entry.key in [1,2,3]
  assert entry.value in ['a','b','c']
}

def keys = map.keySet()
assert keys == [1,2,3] as Set
```

Mutating values returned by the view (be it a map entry, a key or a value) is highly discouraged because success of the operation directly depends on the type of the map being manipulated. In particular, Groovy relies on collections from the JDK that in general make no guarantee that a collection can safely be manipulated through `keySet`, `entrySet`, or `values`.

Filtering and searching

The [Groovy development kit](http://www.groovy-lang.org/gdk.html) contains filtering, searching and collecting methods similar to those found for [lists](https://docs.groovy-lang.org/latest/html/documentation/#List-Filtering):

```groovy
def people = [
    1: [name:'Bob', age: 32, gender: 'M'],
    2: [name:'Johnny', age: 36, gender: 'M'],
    3: [name:'Claire', age: 21, gender: 'F'],
    4: [name:'Amy', age: 54, gender:'F']
]

def bob = people.find { it.value.name == 'Bob' } // find a single entry
def females = people.findAll { it.value.gender == 'F' }

// both return entries, but you can use collect to retrieve the ages for example
def ageOfBob = bob.value.age
def agesOfFemales = females.collect {
    it.value.age
}

assert ageOfBob == 32
assert agesOfFemales == [21,54]

// but you could also use a key/pair value as the parameters of the closures
def agesOfMales = people.findAll { id, person ->
    person.gender == 'M'
}.collect { id, person ->
    person.age
}
assert agesOfMales == [32, 36]

// `every` returns true if all entries match the predicate
assert people.every { id, person ->
    person.age > 18
}

// `any` returns true if any entry matches the predicate

assert people.any { id, person ->
    person.age == 54
}
```

Grouping

We can group a list into a map using some criteria:

```groovy
assert ['a', 7, 'b', [2, 3]].groupBy {
    it.class
} == [(String)   : ['a', 'b'],
      (Integer)  : [7],
      (ArrayList): [[2, 3]]
]

assert [
        [name: 'Clark', city: 'London'], [name: 'Sharma', city: 'London'],
        [name: 'Maradona', city: 'LA'], [name: 'Zhang', city: 'HK'],
        [name: 'Ali', city: 'HK'], [name: 'Liu', city: 'HK'],
].groupBy { it.city } == [
        London: [[name: 'Clark', city: 'London'],
                 [name: 'Sharma', city: 'London']],
        LA    : [[name: 'Maradona', city: 'LA']],
        HK    : [[name: 'Zhang', city: 'HK'],
                 [name: 'Ali', city: 'HK'],
                 [name: 'Liu', city: 'HK']],
]
```

##### Ranges

Ranges allow you to create a list of sequential values. These can be used as `List` since [Range](http://docs.groovy-lang.org/latest/html/api/groovy/lang/Range.html) extends [java.util.List](http://docs.oracle.com/javase/8/docs/api/java/util/List.html).

Ranges defined with the `..` notation are inclusive (that is the list contains the from and to value).

Ranges defined with the `..<` notation are half-open, they include the first value but not the last value.

```groovy
// an inclusive range
def range = 5..8
assert range.size() == 4
assert range.get(2) == 7
assert range[2] == 7
assert range instanceof java.util.List
assert range.contains(5)
assert range.contains(8)

// lets use a half-open range
range = 5..<8
assert range.size() == 3
assert range.get(2) == 7
assert range[2] == 7
assert range instanceof java.util.List
assert range.contains(5)
assert !range.contains(8)

//get the end points of the range without using indexes
range = 1..10
assert range.from == 1
assert range.to == 10
```

Note that int ranges are implemented efficiently, creating a lightweight Java object containing a from and to value.

Ranges can be used for any Java object which implements java.lang.Comparable for comparison and also have methods `next()` and `previous()` to return the next / previous item in the range. For example, you can create a range of `String` elements:

```groovy
// an inclusive range
def range = 'a'..'d'
assert range.size() == 4
assert range.get(2) == 'c'
assert range[2] == 'c'
assert range instanceof java.util.List
assert range.contains('a')
assert range.contains('d')
assert !range.contains('e')
```

You can iterate on a range using a classic `for` loop:

```groovy
for (i in 1..10) {
    println "Hello ${i}"
}
```

but alternatively you can achieve the same effect in a more Groovy idiomatic style, by iterating a range with `each` method:

```groovy
(1..10).each { i ->
    println "Hello ${i}"
}
```

Ranges can be also used in the `switch` statement:

```groovy
switch (years) {
    case 1..10: interestRate = 0.076; break;
    case 11..25: interestRate = 0.052; break;
    default: interestRate = 0.037;
}
```

##### Syntax enhancements for collections

###### GPath support

Thanks to the support of property notation for both lists and maps, Groovy provides syntactic sugar making it really easy to deal with nested collections, as illustrated in the following examples:

```groovy
def listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22]]
assert listOfMaps.a == [11, 21] //GPath notation
assert listOfMaps*.a == [11, 21] //spread dot notation

listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22], null]
assert listOfMaps*.a == [11, 21, null] // caters for null values
assert listOfMaps*.a == listOfMaps.collect { it?.a } //equivalent notation
// But this will only collect non-null values
assert listOfMaps.a == [11,21]
```

###### Spread operator

The spread operator can be used to "inline" a collection into another. It is syntactic sugar which often avoids calls to `putAll` and facilitates the realization of one-liners:

```groovy
assert [ 'z': 900,
         *: ['a': 100, 'b': 200], 'a': 300] == ['a': 300, 'b': 200, 'z': 900]
//spread map notation in map definition
assert [*: [3: 3, *: [5: 5]], 7: 7] == [3: 3, 5: 5, 7: 7]

def f = { [1: 'u', 2: 'v', 3: 'w'] }
assert [*: f(), 10: 'zz'] == [1: 'u', 10: 'zz', 2: 'v', 3: 'w']
//spread map notation in function arguments
f = { map -> map.c }
assert f(*: ['a': 10, 'b': 20, 'c': 30], 'e': 50) == 30

f = { m, i, j, k -> [m, i, j, k] }
//using spread map notation with mixed unnamed and named arguments
assert f('e': 100, *[4, 5], *: ['a': 10, 'b': 20, 'c': 30], 6) ==
        [["e": 100, "b": 20, "c": 30, "a": 10], 4, 5, 6]
```

###### The star-dot `*.' operator

The "star-dot" operator is a shortcut operator allowing you to call a method or a property on all elements of a collection:

```groovy
assert [1, 3, 5] == ['a', 'few', 'words']*.size()

class Person {
    String name
    int age
}
def persons = [new Person(name:'Hugo', age:17), new Person(name:'Sandra',age:19)]
assert [17, 19] == persons*.age
```

###### Slicing with the subscript operator

You can index into lists, arrays, maps using the subscript expression. It is interesting that strings are considered as special kinds of collections in that context:

```groovy
def text = 'nice cheese gromit!'
def x = text[2]

assert x == 'c'
assert x.class == String

def sub = text[5..10]
assert sub == 'cheese'

def list = [10, 11, 12, 13]
def answer = list[2,3]
assert answer == [12,13]
```

Notice that you can use ranges to extract part of a collection:

```groovy
list = 100..200
sub = list[1, 3, 20..25, 33]
assert sub == [101, 103, 120, 121, 122, 123, 124, 125, 133]
```

The subscript operator can be used to update an existing collection (for collection type which are not immutable):

```groovy
list = ['a','x','x','d']
list[1..2] = ['b','c']
assert list == ['a','b','c','d']
```

It is worth noting that negative indices are allowed, to extract more easily from the end of a collection:

```groovy
text = "nice cheese gromit!"
x = text[-1]
assert x == "!"
```

You can use negative indices to count from the end of the List, array, String etc.

```groovy
def name = text[-7..-2]
assert name == "gromit"
```

Eventually, if you use a backwards range (the starting index is greater than the end index), then the answer is reversed.

```groovy
text = "nice cheese gromit!"
name = text[3..1]
assert name == "eci"
```

##### Enhanced Collection Methods

In addition to [lists](https://docs.groovy-lang.org/latest/html/documentation/#Collections-Lists), [maps](https://docs.groovy-lang.org/latest/html/documentation/#Collections-Maps) or [ranges](https://docs.groovy-lang.org/latest/html/documentation/#Collections-Ranges), Groovy offers a lot of additional methods for filtering, collecting, grouping, counting, … which are directly available on either collections or more easily iterables.

In particular, we invite you to read the [Groovy development kit](http://www.groovy-lang.org/gdk.html) API docs and specifically:

- methods added to `Iterable` can be found [here](http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Iterable.html)
- methods added to `Iterator` can be found [here](http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Iterator.html)
- methods added to `Collection` can be found [here](http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Collection.html)
- methods added to `List` can be found [here](http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/List.html)
- methods added to `Map` can be found [here](http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html)

#### 3.3.3. Working with legacy Date/Calendar types

The `groovy-dateutil` module supports numerous extensions for working with Java’s classic `Date` and `Calendar` classes.

You can access the properties of a `Date` or `Calendar` using the normal array index notation with the constant field numbers from the `Calendar` class as shown in the following example:

```groovy
import static java.util.Calendar.*    

def cal = Calendar.instance
cal[YEAR] = 2000                      
cal[MONTH] = JANUARY                  
cal[DAY_OF_MONTH] = 1                 
assert cal[DAY_OF_WEEK] == SATURDAY   
```

|      | Import the constants                                |
| ---- | --------------------------------------------------- |
|      | Setting the calendar’s year, month and day of month |
|      | Accessing the calendar’s day of week                |

Groovy supports arithmetic on and iteration between `Date` and `Calendar` instances as shown in the following example:

```groovy
def utc = TimeZone.getTimeZone('UTC')
Date date = Date.parse("yyyy-MM-dd HH:mm", "2010-05-23 09:01", utc)

def prev = date - 1
def next = date + 1

def diffInDays = next - prev
assert diffInDays == 2

int count = 0
prev.upto(next) { count++ }
assert count == 3
```

You can parse strings into dates and output dates into formatted strings:

```groovy
def orig = '2000-01-01'
def newYear = Date.parse('yyyy-MM-dd', orig)
assert newYear[DAY_OF_WEEK] == SATURDAY
assert newYear.format('yyyy-MM-dd') == orig
assert newYear.format('dd/MM/yyyy') == '01/01/2000'
```

You can also create a new Date or Calendar based on an existing one:

```groovy
def newYear = Date.parse('yyyy-MM-dd', '2000-01-01')
def newYearsEve = newYear.copyWith(
    year: 1999,
    month: DECEMBER,
    dayOfMonth: 31
)
assert newYearsEve[DAY_OF_WEEK] == FRIDAY
```

#### 3.3.4. Working with Date/Time types

The `groovy-datetime` module supports numerous extensions for working with the [Date/Time API](http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html) introduced in Java 8. This documentation refers to the data types defined by this API as "JSR 310 types."

##### Formatting and parsing

A common use case when working with date/time types is to convert them to Strings (formatting) and from Strings (parsing). Groovy provides these additional formatting methods:

| Method                      | Description                                                  | Example                                                      |
| :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `getDateString()`           | For `LocalDate` and `LocalDateTime`, formats with [`DateTimeFormatter.ISO_LOCAL_DATE`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE) | `2018-03-10`                                                 |
|                             | For `OffsetDateTime`, formats with [`DateTimeFormatter.ISO_OFFSET_DATE`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE) | `2018-03-10+04:00`                                           |
|                             | For `ZonedDateTime`, formats with [`DateTimeFormatter.ISO_LOCAL_DATE`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE) and appends the `ZoneId` short name | `2018-03-10EST`                                              |
| `getDateTimeString()`       | For `LocalDateTime`, formats with [`DateTimeFormatter.ISO_LOCAL_DATE_TIME`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME) | `2018-03-10T20:30:45`                                        |
|                             | For `OffsetDateTime`, formats with [`DateTimeFormatter.ISO_OFFSET_DATE_TIME`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME) | `2018-03-10T20:30:45+04:00`                                  |
|                             | For `ZonedDateTime`, formats with [`DateTimeFormatter.ISO_LOCAL_DATE_TIME`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME) and appends the `ZoneId` short name | `2018-03-10T20:30:45EST`                                     |
| `getTimeString()`           | For `LocalTime` and `LocalDateTime`, formats with [`DateTimeFormatter.ISO_LOCAL_TIME`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME) | `20:30:45`                                                   |
|                             | For `OffsetTime` and `OffsetDateTime`, formats with [`DateTimeFormatter.ISO_OFFSET_TIME`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME) formatter | `20:30:45+04:00`                                             |
|                             | For `ZonedDateTime`, formats with [`DateTimeFormatter.ISO_LOCAL_TIME`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME) and appends the `ZoneId` short name | `20:30:45EST`                                                |
| `format(FormatStyle style)` | For `LocalTime` and `OffsetTime`, formats with [`DateTimeFormatter.ofLocalizedTime(style)`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedTime-java.time.format.FormatStyle-) | `4:30 AM` (with style `FormatStyle.SHORT`, e.g.)             |
|                             | For `LocalDate`, formats with [`DateTimeFormatter.ofLocalizedDate(style)`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDate-java.time.format.FormatStyle-) | `Saturday, March 10, 2018` (with style `FormatStyle.FULL`, e.g.) |
|                             | For `LocalDateTime`, `OffsetDateTime`, and `ZonedDateTime` formats with [`DateTimeFormatter.ofLocalizedDateTime(style)`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-) | `Mar 10, 2019 4:30:45 AM` (with style `FormatStyle.MEDIUM`, e.g.) |
| `format(String pattern)`    | Formats with [`DateTimeFormatter.ofPattern(pattern)`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-) | `03/10/2018` (with pattern ’MM/dd/yyyy', e.g.)               |

For parsing, Groovy adds a static `parse` method to many of the JSR 310 types. The method takes two arguments: the value to be formatted and the pattern to use. The pattern is defined by the [`java.time.format.DateTimeFormatter` API](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html). As an example:

```groovy
def date = LocalDate.parse('Jun 3, 04', 'MMM d, yy')
assert date == LocalDate.of(2004, Month.JUNE, 3)

def time = LocalTime.parse('4:45', 'H:mm')
assert time == LocalTime.of(4, 45, 0)

def offsetTime = OffsetTime.parse('09:47:51-1234', 'HH:mm:ssZ')
assert offsetTime == OffsetTime.of(9, 47, 51, 0, ZoneOffset.ofHoursMinutes(-12, -34))

def dateTime = ZonedDateTime.parse('2017/07/11 9:47PM Pacific Standard Time', 'yyyy/MM/dd h:mma zzzz')
assert dateTime == ZonedDateTime.of(
        LocalDate.of(2017, 7, 11),
        LocalTime.of(21, 47, 0),
        ZoneId.of('America/Los_Angeles')
)
```

Note that these `parse` methods have a different argument ordering than the static `parse` method Groovy added to `java.util.Date`. This was done to be consistent with the existing `parse` methods of the Date/Time API.

##### Manipulating date/time

###### Addition and subtraction

`Temporal` types have `plus` and `minus` methods for adding or subtracting a provided `java.time.temporal.TemporalAmount` argument. Because Groovy maps the `+` and `-` operators to single-argument methods of these names, a more natural expression syntax can be used to add and subtract.

```groovy
def aprilFools = LocalDate.of(2018, Month.APRIL, 1)

def nextAprilFools = aprilFools + Period.ofDays(365) // add 365 days
assert nextAprilFools.year == 2019

def idesOfMarch = aprilFools - Period.ofDays(17) // subtract 17 days
assert idesOfMarch.dayOfMonth == 15
assert idesOfMarch.month == Month.MARCH
```

Groovy provides additional `plus` and `minus` methods that accept an integer argument, enabling the above to be rewritten more succinctly:

```groovy
def nextAprilFools = aprilFools + 365 // add 365 days
def idesOfMarch = aprilFools - 17 // subtract 17 days
```

The unit of these integers depends on the JSR 310 type operand. As evident above, integers used with `ChronoLocalDate` types like `LocalDate` have a unit of [days](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#DAYShttp://days). Integers used with `Year` and `YearMonth` have a unit of [years](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#YEARS) and [months](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#MONTHS), respectively. All other types have a unit of [seconds](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS), such as `LocalTime`, for instance:

```groovy
def mars = LocalTime.of(12, 34, 56) // 12:34:56 pm

def thirtySecondsToMars = mars - 30 // go back 30 seconds
assert thirtySecondsToMars.second == 26
```

###### Multiplication and division

The `*` operator can be used to multiply `Period` and `Duration` instances by an integer value; the `/` operator can be used to divide `Duration` instances by an integer value.

```groovy
def period = Period.ofMonths(1) * 2 // a 1-month period times 2
assert period.months == 2

def duration = Duration.ofSeconds(10) / 5// a 10-second duration divided by 5
assert duration.seconds == 2
```

###### Incrementing and decrementing

The `++` and `--` operators can be used increment and decrement date/time values by one unit. Since the JSR 310 types are immutable, the operation will create a new instance with the incremented/decremented value and reassign it to the reference.

```groovy
def year = Year.of(2000)
--year // decrement by one year
assert year.value == 1999

def offsetTime = OffsetTime.of(0, 0, 0, 0, ZoneOffset.UTC) // 00:00:00.000 UTC
offsetTime++ // increment by one second
assert offsetTime.second == 1
```

###### Negation

The `Duration` and `Period` types represent a negative or positive length of time. These can be negated with the unary `-` operator.

```groovy
def duration = Duration.ofSeconds(-15)
def negated = -duration
assert negated.seconds == 15
```

##### Interacting with date/time values

###### Property notation

The [`getLong(TemporalField)`](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong-java.time.temporal.TemporalField-) method of `TemporalAccessor` types (e.g. `LocalDate`, `LocalTime`, `ZonedDateTime`, etc.) and the [`get(TemporalUnit)`](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get-java.time.temporal.TemporalUnit-) method of `TemporalAmount` types (namely `Period` and `Duration`), can be invoked with Groovy’s property notation. For example:

```groovy
def date = LocalDate.of(2018, Month.MARCH, 12)
assert date[ChronoField.YEAR] == 2018
assert date[ChronoField.MONTH_OF_YEAR] == Month.MARCH.value
assert date[ChronoField.DAY_OF_MONTH] == 12
assert date[ChronoField.DAY_OF_WEEK] == DayOfWeek.MONDAY.value

def period = Period.ofYears(2).withMonths(4).withDays(6)
assert period[ChronoUnit.YEARS] == 2
assert period[ChronoUnit.MONTHS] == 4
assert period[ChronoUnit.DAYS] == 6
```

###### Ranges, `upto`, and `downto`

The JSR 310 types can be used with the [range operator](https://docs.groovy-lang.org/latest/html/documentation/#_range_operator). The following example iterates between today and the `LocalDate` six days from now, printing out the day of the week for each iteration. As both range bounds are inclusive, this prints all seven days of the week.

```groovy
def start = LocalDate.now()
def end = start + 6 // 6 days later
(start..end).each { date ->
    println date.dayOfWeek
}
```

The `upto` method will accomplish the same as the range in the above example. The `upto` method iterates from the earlier `start` value (inclusive) to the later `end` value (also inclusive), calling the closure with the incremented `next` value once per iteration.

```groovy
def start = LocalDate.now()
def end = start + 6 // 6 days later
start.upto(end) { next ->
    println next.dayOfWeek
}
```

The `downto` method iterates in the opposite direction, from a later `start` value to an earlier `end` value.

The unit of iteration for `upto`, `downto`, and ranges is the same as the unit for addition and subtraction: `LocalDate` iterates by one day at a time, `YearMonth` iterates by one month, `Year` by one year, and everything else by one second. Both methods also support an optional a `TemporalUnit` argument to change the unit of iteration.

Consider the following example, where March 1st, 2018 is iterated up to March 2nd, 2018 using an iteration unit of [months](https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#MONTHS).

```groovy
def start = LocalDate.of(2018, Month.MARCH, 1)
def end = start + 1 // 1 day later

int iterationCount = 0
start.upto(end, ChronoUnit.MONTHS) { next ->
    println next
    ++iterationCount
}

assert iterationCount == 1
```

Since the `start` date is inclusive, the closure is called with a `next` date value of March 1st. The `upto` method then increments the date by one month, yielding the date, April 1st. Because this date is *after* the specified `end` date of March 2nd, the iteration stops immediately, having only called the closure once. This behavior is the same for the `downto` method except that the iteration will stop as soon as the value of `next` becomes earlier than the targeted `end` date.

In short, when iterating with the `upto` or `downto` methods with a custom unit of iteration, the current value of iteration will never exceed the end value.

###### Combining date/time values

The left-shift operator (`<<`) can be used to combine two JSR 310 types into an aggregate type. For example, a `LocalDate` can be left-shifted into a `LocalTime` to produce a composite `LocalDateTime` instance.

```groovy
MonthDay monthDay = Month.JUNE << 3 // June 3rd
LocalDate date = monthDay << Year.of(2015) // 3-Jun-2015
LocalDateTime dateTime = date << LocalTime.NOON // 3-Jun-2015 @ 12pm
OffsetDateTime offsetDateTime = dateTime << ZoneOffset.ofHours(-5) // 3-Jun-2015 @ 12pm UTC-5
```

The left-shift operator is reflexive; the order of the operands does not matter.

```groovy
def year = Year.of(2000)
def month = Month.DECEMBER

YearMonth a = year << month
YearMonth b = month << year
assert a == b
```

###### Creating periods and durations

The right-shift operator (`>>`) produces a value representing the period or duration between the operands. For `ChronoLocalDate`, `YearMonth`, and `Year`, the operator yields a `Period` instance:

```groovy
def newYears = LocalDate.of(2018, Month.JANUARY, 1)
def aprilFools = LocalDate.of(2018, Month.APRIL, 1)

def period = newYears >> aprilFools
assert period instanceof Period
assert period.months == 3
```

The operator produces a `Duration` for the time-aware JSR types:

```groovy
def duration = LocalTime.NOON >> (LocalTime.NOON + 30)
assert duration instanceof Duration
assert duration.seconds == 30
```

If the value on the left-hand side of the operator is earlier than the value on the right-hand side, the result is positive. If the left-hand side is later than the right-hand side, the result is negative:

```groovy
def decade = Year.of(2010) >> Year.of(2000)
assert decade.years == -10
```

##### Converting between legacy and JSR 310 types

Despite the shortcomings of `Date`, `Calendar`, and `TimeZone` types in the `java.util` package they are farily common in Java APIs (at least in those prior to Java 8). To accommodate use of such APIs, Groovy provides methods for converting between the JSR 310 types and legacy types.

Most JSR types have been fitted with `toDate()` and `toCalendar()` methods for converting to relatively equivalent `java.util.Date` and `java.util.Calendar` values. Both `ZoneId` and `ZoneOffset` have been given a `toTimeZone()` method for converting to `java.util.TimeZone`.

```groovy
// LocalDate to java.util.Date
def valentines = LocalDate.of(2018, Month.FEBRUARY, 14)
assert valentines.toDate().format('MMMM dd, yyyy') == 'February 14, 2018'

// LocalTime to java.util.Date
def noon = LocalTime.of(12, 0, 0)
assert noon.toDate().format('HH:mm:ss') == '12:00:00'

// ZoneId to java.util.TimeZone
def newYork = ZoneId.of('America/New_York')
assert newYork.toTimeZone() == TimeZone.getTimeZone('America/New_York')

// ZonedDateTime to java.util.Calendar
def valAtNoonInNY = ZonedDateTime.of(valentines, noon, newYork)
assert valAtNoonInNY.toCalendar().getTimeZone().toZoneId() == newYork
```

Note that when converting to a legacy type:

- Nanosecond values are truncated to milliseconds. A `LocalTime`, for example, with a `ChronoUnit.NANOS` value of 999,999,999 nanoseconds translates to 999 milliseconds.
- When converting the "local" types (`LocalDate`, `LocalTime`, and `LocalDateTime`), the time zone of the returned `Date` or `Calendar` will be the system default.
- When converting a time-only type (`LocalTime` or `OffsetTime`), the year/month/day of the `Date` or `Calendar` is set to the current date.
- When converting a date-only type (`LocalDate`), the time value of the `Date` or `Calendar` will be cleared, i.e. `00:00:00.000`.
- When converting an `OffsetDateTime` to a `Calendar`, only the hours and minutes of the `ZoneOffset` convey into the corresponding `TimeZone`. Fortunately, Zone Offsets with non-zero seconds are rare.

Groovy has added a number of methods to `Date` and `Calendar` for converting into the various JSR 310 types:

```groovy
Date legacy = Date.parse('yyyy-MM-dd HH:mm:ss.SSS', '2010-04-03 10:30:58.999')

assert legacy.toLocalDate() == LocalDate.of(2010, 4, 3)
assert legacy.toLocalTime() == LocalTime.of(10, 30, 58, 999_000_000) // 999M ns = 999ms
assert legacy.toOffsetTime().hour == 10
assert legacy.toYear() == Year.of(2010)
assert legacy.toMonth() == Month.APRIL
assert legacy.toDayOfWeek() == DayOfWeek.SATURDAY
assert legacy.toMonthDay() == MonthDay.of(Month.APRIL, 3)
assert legacy.toYearMonth() == YearMonth.of(2010, Month.APRIL)
assert legacy.toLocalDateTime().year == 2010
assert legacy.toOffsetDateTime().dayOfMonth == 3
assert legacy.toZonedDateTime().zone == ZoneId.systemDefault()
```

#### 3.3.5. Handy utilities

##### ConfigSlurper

`ConfigSlurper` is a utility class for reading configuration files defined in the form of Groovy scripts. Like it is the case with Java `*.properties` files, `ConfigSlurper` allows a dot notation. But in addition, it allows for Closure scoped configuration values and arbitrary object types.

```groovy
def config = new ConfigSlurper().parse('''
    app.date = new Date()  
    app.age  = 42
    app {                  
        name = "Test${42}"
    }
''')

assert config.app.date instanceof Date
assert config.app.age == 42
assert config.app.name == 'Test42'
```

|      | Usage of the dot notation                                    |
| ---- | ------------------------------------------------------------ |
|      | Usage of Closure scopes as an alternative to the dot notation |

As can be seen in the above example, the `parse` method can be used to retrieve `groovy.util.ConfigObject` instances. The `ConfigObject` is a specialized `java.util.Map` implementation that either returns the configured value or a new `ConfigObject` instance but never `null`.

```groovy
def config = new ConfigSlurper().parse('''
    app.date = new Date()
    app.age  = 42
    app.name = "Test${42}"
''')

assert config.test != null   
```

|      | `config.test` has not been specified yet it returns a `ConfigObject` when being called. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

In the case of a dot being part of a configuration variable name, it can be escaped by using single or double quotes.

```groovy
def config = new ConfigSlurper().parse('''
    app."person.age"  = 42
''')

assert config.app."person.age" == 42
```

In addition, `ConfigSlurper` comes with support for `environments`. The `environments` method can be used to hand over a Closure instance that itself may consist of a several sections. Let’s say we wanted to create a particular configuration value for the development environment. When creating the `ConfigSlurper` instance we can use the `ConfigSlurper(String)` constructor to specify the target environment.

```groovy
def config = new ConfigSlurper('development').parse('''
  environments {
       development {
           app.port = 8080
       }

       test {
           app.port = 8082
       }

       production {
           app.port = 80
       }
  }
''')

assert config.app.port == 8080
```

|      | The `ConfigSlurper` environments aren’t restricted to any particular environment names. It solely depends on the `ConfigSlurper` client code what value are supported and interpreted accordingly. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The `environments` method is built-in but the `registerConditionalBlock` method can be used to register other method names in addition to the `environments` name.

```groovy
def slurper = new ConfigSlurper()
slurper.registerConditionalBlock('myProject', 'developers')   

def config = slurper.parse('''
  sendMail = true

  myProject {
       developers {
           sendMail = false
       }
  }
''')

assert !config.sendMail
```

|      | Once the new block is registered `ConfigSlurper` can parse it. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

For Java integration purposes the `toProperties` method can be used to convert the `ConfigObject` to a `java.util.Properties` object that might be stored to a `*.properties` text file. Be aware though that the configuration values are converted to `String` instances during adding them to the newly created `Properties` instance.

```groovy
def config = new ConfigSlurper().parse('''
    app.date = new Date()
    app.age  = 42
    app {
        name = "Test${42}"
    }
''')

def properties = config.toProperties()

assert properties."app.date" instanceof String
assert properties."app.age" == '42'
assert properties."app.name" == 'Test42'
```

##### Expando

The `Expando` class can be used to create a dynamically expandable object. Despite its name it does not use the `ExpandoMetaClass` underneath. Each `Expando` object represents a standalone, dynamically-crafted instance that can be extended with properties (or methods) at runtime.

```groovy
def expando = new Expando()
expando.name = 'John'

assert expando.name == 'John'
```

A special case occurs when a dynamic property registers a `Closure` code block. Once being registered it can be invoked as it would be done with a method call.

```groovy
def expando = new Expando()
expando.toString = { -> 'John' }
expando.say = { String s -> "John says: ${s}" }

assert expando as String == 'John'
assert expando.say('Hi') == 'John says: Hi'
```

##### Observable list, map and set

Groovy comes with observable lists, maps and sets. Each of these collections trigger `java.beans.PropertyChangeEvent` events when elements are added, removed or changed. Note that a `PropertyChangeEvent` is not only signalling that a certain event has occurred, moreover, it holds information on the property name and the old/new value a certain property has been changed to.

Depending on the type of change that has happened, observable collections might fire more specialized `PropertyChangeEvent` types. For example, adding an element to an observable list fires an `ObservableList.ElementAddedEvent` event.

```groovy
def event                                       
def listener = {
    if (it instanceof ObservableList.ElementEvent)  {  
        event = it
    }
} as PropertyChangeListener


def observable = [1, 2, 3] as ObservableList    
observable.addPropertyChangeListener(listener)  

observable.add 42                               

assert event instanceof ObservableList.ElementAddedEvent

def elementAddedEvent = event as ObservableList.ElementAddedEvent
assert elementAddedEvent.changeType == ObservableList.ChangeType.ADDED
assert elementAddedEvent.index == 3
assert elementAddedEvent.oldValue == null
assert elementAddedEvent.newValue == 42
```

|      | Declares a `PropertyChangeEventListener` that is capturing the fired events |
| ---- | ------------------------------------------------------------ |
|      | `ObservableList.ElementEvent` and its descendant types are relevant for this listener |
|      | Registers the listener                                       |
|      | Creates an `ObservableList` from the given list              |
|      | Triggers an `ObservableList.ElementAddedEvent` event         |

|      | Be aware that adding an element in fact causes two events to be triggered. The first is of type `ObservableList.ElementAddedEvent`, the second is a plain `PropertyChangeEvent` that informs listeners about the change of property `size`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The `ObservableList.ElementClearedEvent` event type is another interesting one. Whenever multiple elements are removed, for example when calling `clear()`, it holds the elements being removed from the list.

```groovy
def event
def listener = {
    if (it instanceof ObservableList.ElementEvent)  {
        event = it
    }
} as PropertyChangeListener


def observable = [1, 2, 3] as ObservableList
observable.addPropertyChangeListener(listener)

observable.clear()

assert event instanceof ObservableList.ElementClearedEvent

def elementClearedEvent = event as ObservableList.ElementClearedEvent
assert elementClearedEvent.values == [1, 2, 3]
assert observable.size() == 0
```

To get an overview of all the supported event types the reader is encouraged to have a look at the JavaDoc documentation or the source code of the observable collection in use.

`ObservableMap` and `ObservableSet` come with the same concepts as we have seen for `ObservableList` in this section.

### 3.4. Metaprogramming

The Groovy language supports two flavors of metaprogramming: runtime and compile-time. The first allows altering the class model and the behavior of a program at runtime while the second only occurs at compile-time. Both have pros and cons that we will detail in this section.

#### 3.4.1. Runtime metaprogramming

With runtime metaprogramming we can postpone to runtime the decision to intercept, inject and even synthesize methods of classes and interfaces. For a deep understanding of Groovy’s metaobject protocol (MOP) we need to understand Groovy objects and Groovy’s method handling. In Groovy we work with three kinds of objects: POJO, POGO and Groovy Interceptors. Groovy allows metaprogramming for all types of objects but in a different manner.

- POJO - A regular Java object whose class can be written in Java or any other language for the JVM.
- POGO - A Groovy object whose class is written in Groovy. It extends `java.lang.Object` and implements the [groovy.lang.GroovyObject](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyObject.html) interface by default.
- Groovy Interceptor - A Groovy object that implements the [groovy.lang.GroovyInterceptable](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyInterceptable.html) interface and has method-interception capability which is discussed in the [GroovyInterceptable](https://docs.groovy-lang.org/latest/html/documentation/#_groovyinterceptable) section.

For every method call Groovy checks whether the object is a POJO or a POGO. For POJOs, Groovy fetches its `MetaClass` from the [groovy.lang.MetaClassRegistry](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/MetaClassRegistry.html) and delegates method invocation to it. For POGOs, Groovy takes more steps, as illustrated in the following figure:

![GroovyInterceptions](https://docs.groovy-lang.org/latest/html/documentation/assets/img/GroovyInterceptions.png)

Figure 1. Groovy interception mechanism

##### GroovyObject interface

[groovy.lang.GroovyObject](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyObject.html) is the main interface in Groovy as the `Object` class is in Java. `GroovyObject` has a default implementation in the [groovy.lang.GroovyObjectSupport](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyObjectSupport.html) class and it is responsible to transfer invocation to the [groovy.lang.MetaClass](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/MetaClass.html) object. The `GroovyObject` source looks like this:

```java
package groovy.lang;

public interface GroovyObject {

    Object invokeMethod(String name, Object args);

    Object getProperty(String propertyName);

    void setProperty(String propertyName, Object newValue);

    MetaClass getMetaClass();

    void setMetaClass(MetaClass metaClass);
}
```

###### invokeMethod

This method is primarily intended to be used in conjunction with the [GroovyInterceptable](https://docs.groovy-lang.org/latest/html/documentation/#_groovyinterceptable) interface or an object’s `MetaClass` where it will intercept all method calls.

It is also invoked when the method called is not present on a Groovy object. Here is a simple example using an overridden `invokeMethod()` method:

```groovy
class SomeGroovyClass {

    def invokeMethod(String name, Object args) {
        return "called invokeMethod $name $args"
    }

    def test() {
        return 'method exists'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.test() == 'method exists'
assert someGroovyClass.someMethod() == 'called invokeMethod someMethod []'
```

However, the use of `invokeMethod` to intercept missing methods is discouraged. In cases where the intent is to only intercept method calls in the case of a failed method dispatch use [methodMissing](https://docs.groovy-lang.org/latest/html/documentation/#_methodmissing) instead.

###### get/setProperty

Every read access to a property can be intercepted by overriding the `getProperty()` method of the current object. Here is a simple example:

```groovy
class SomeGroovyClass {

    def property1 = 'ha'
    def field2 = 'ho'
    def field4 = 'hu'

    def getField1() {
        return 'getHa'
    }

    def getProperty(String name) {
        if (name != 'field3')
            return metaClass.getProperty(this, name) 
        else
            return 'field3'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.field1 == 'getHa'
assert someGroovyClass.field2 == 'ho'
assert someGroovyClass.field3 == 'field3'
assert someGroovyClass.field4 == 'hu'
```

|      | Forwards the request to the getter for all properties except `field3`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

You can intercept write access to properties by overriding the `setProperty()` method:

```groovy
class POGO {

    String property

    void setProperty(String name, Object value) {
        this.@"$name" = 'overridden'
    }
}

def pogo = new POGO()
pogo.property = 'a'

assert pogo.property == 'overridden'
```

###### get/setMetaClass

You can access an object’s `metaClass` or set your own `MetaClass` implementation for changing the default interception mechanism. For example, you can write your own implementation of the `MetaClass` interface and assign it to objects in order to change the interception mechanism:

```groovy
// getMetaclass
someObject.metaClass

// setMetaClass
someObject.metaClass = new OwnMetaClassImplementation()
```

|      | You can find an additional example in the [GroovyInterceptable](https://docs.groovy-lang.org/latest/html/documentation/#_groovyinterceptable) topic. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### get/setAttribute

This functionality is related to the `MetaClass` implementation. In the default implementation you can access fields without invoking their getters and setters. The examples below demonstrates this approach:

```groovy
class SomeGroovyClass {

    def field1 = 'ha'
    def field2 = 'ho'

    def getField1() {
        return 'getHa'
    }
}

def someGroovyClass = new SomeGroovyClass()

assert someGroovyClass.metaClass.getAttribute(someGroovyClass, 'field1') == 'ha'
assert someGroovyClass.metaClass.getAttribute(someGroovyClass, 'field2') == 'ho'
class POGO {

    private String field
    String property1

    void setProperty1(String property1) {
        this.property1 = "setProperty1"
    }
}

def pogo = new POGO()
pogo.metaClass.setAttribute(pogo, 'field', 'ha')
pogo.metaClass.setAttribute(pogo, 'property1', 'ho')

assert pogo.field == 'ha'
assert pogo.property1 == 'ho'
```

##### methodMissing

Groovy supports the concept of `methodMissing`. This method differs from `invokeMethod` in that it is only invoked in the case of a failed method dispatch when no method can be found for the given name and/or the given arguments:

```groovy
class Foo {

   def methodMissing(String name, def args) {
        return "this is me"
   }
}

assert new Foo().someUnknownMethod(42l) == 'this is me'
```

Typically when using `methodMissing` it is possible to cache the result for the next time the same method is called.

For example, consider dynamic finders in GORM. These are implemented in terms of `methodMissing`. The code resembles something like this:

```groovy
class GORM {

   def dynamicMethods = [...] // an array of dynamic methods that use regex

   def methodMissing(String name, args) {
       def method = dynamicMethods.find { it.match(name) }
       if(method) {
          GORM.metaClass."$name" = { Object[] varArgs ->
             method.invoke(delegate, name, varArgs)
          }
          return method.invoke(delegate,name, args)
       }
       else throw new MissingMethodException(name, delegate, args)
   }
}
```

Notice how, if we find a method to invoke, we then dynamically register a new method on the fly using [ExpandoMetaClass](https://docs.groovy-lang.org/latest/html/documentation/#metaprogramming_emc). This is so that the next time the same method is called it is more efficient. This way of using `methodMissing` does not have the overhead of `invokeMethod` *and* is not expensive from the second call on.

##### propertyMissing

Groovy supports the concept of `propertyMissing` for intercepting otherwise failing property resolution attempts. In the case of a getter method, `propertyMissing` takes a single `String` argument containing the property name:

```groovy
class Foo {
   def propertyMissing(String name) { name }
}

assert new Foo().boo == 'boo'
```

The `propertyMissing(String)` method is only called when no getter method for the given property can be found by the Groovy runtime.

For setter methods a second `propertyMissing` definition can be added that takes an additional value argument:

```groovy
class Foo {
   def storage = [:]
   def propertyMissing(String name, value) { storage[name] = value }
   def propertyMissing(String name) { storage[name] }
}

def f = new Foo()
f.foo = "bar"

assert f.foo == "bar"
```

As with `methodMissing` it is best practice to dynamically register new properties at runtime to improve the overall lookup performance.

##### static methodMissing

Static variant of `methodMissing` method can be added via the [ExpandoMetaClass](https://docs.groovy-lang.org/latest/html/documentation/#metaprogramming_emc) or can be implemented at the class level with `$static_methodMissing` method.

```groovy
class Foo {
    static def $static_methodMissing(String name, Object args) {
        return "Missing static method name is $name"
    }
}

assert Foo.bar() == 'Missing static method name is bar'
```

##### static propertyMissing

Static variant of `propertyMissing` method can be added via the [ExpandoMetaClass](https://docs.groovy-lang.org/latest/html/documentation/#metaprogramming_emc) or can be implemented at the class level with `$static_propertyMissing` method.

```groovy
class Foo {
    static def $static_propertyMissing(String name) {
        return "Missing static property name is $name"
    }
}

assert Foo.foobar == 'Missing static property name is foobar'
```

##### GroovyInterceptable

The [groovy.lang.GroovyInterceptable](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyInterceptable.html) interface is marker interface that extends `GroovyObject` and is used to notify the Groovy runtime that all methods should be intercepted through the method dispatcher mechanism of the Groovy runtime.

```java
package groovy.lang;

public interface GroovyInterceptable extends GroovyObject {
}
```

When a Groovy object implements the `GroovyInterceptable` interface, its `invokeMethod()` is called for any method calls. Below you can see a simple example of an object of this type:

```groovy
class Interception implements GroovyInterceptable {

    def definedMethod() { }

    def invokeMethod(String name, Object args) {
        'invokedMethod'
    }
}
```

The next piece of code is a test which shows that both calls to existing and non-existing methods will return the same value.

```groovy
class InterceptableTest extends GroovyTestCase {

    void testCheckInterception() {
        def interception = new Interception()

        assert interception.definedMethod() == 'invokedMethod'
        assert interception.someMethod() == 'invokedMethod'
    }
}
```

|      | We cannot use default groovy methods like `println` because these methods are injected into all Groovy objects so they will be intercepted too. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

If we want to intercept all method calls but do not want to implement the `GroovyInterceptable` interface we can implement `invokeMethod()` on an object’s `MetaClass`. This approach works for both POGOs and POJOs, as shown by this example:

```groovy
class InterceptionThroughMetaClassTest extends GroovyTestCase {

    void testPOJOMetaClassInterception() {
        String invoking = 'ha'
        invoking.metaClass.invokeMethod = { String name, Object args ->
            'invoked'
        }

        assert invoking.length() == 'invoked'
        assert invoking.someMethod() == 'invoked'
    }

    void testPOGOMetaClassInterception() {
        Entity entity = new Entity('Hello')
        entity.metaClass.invokeMethod = { String name, Object args ->
            'invoked'
        }

        assert entity.build(new Object()) == 'invoked'
        assert entity.someMethod() == 'invoked'
    }
}
```

|      | Additional information about `MetaClass` can be found in the [MetaClasses](https://docs.groovy-lang.org/latest/html/documentation/#_metaclasses) section. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Categories

There are situations where it is useful if a class *not* under control had additional methods. In order to enable this capability, Groovy implements a feature borrowed from Objective-C, called *Categories*.

Categories are implemented with so-called *category classes*. A category class is special in that it needs to meet certain pre-defined rules for defining extension methods.

There are a few categories that are included in the system for adding functionality to classes that make them more usable within the Groovy environment:

- [groovy.time.TimeCategory](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/time/TimeCategory.html)
- [groovy.servlet.ServletCategory](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/servlet/ServletCategory.html)
- [groovy.xml.dom.DOMCategory](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/xml/dom/DOMCategory.html)

Category classes aren’t enabled by default. To use the methods defined in a category class it is necessary to apply the scoped `use` method that is provided by the GDK and available from inside every Groovy object instance:

```groovy
use(TimeCategory)  {
    println 1.minute.from.now       
    println 10.hours.ago

    def someDate = new Date()       
    println someDate - 3.months
}
```

|      | `TimeCategory` adds methods to `Integer` |
| ---- | ---------------------------------------- |
|      | `TimeCategory` adds methods to `Date`    |

The `use` method takes the category class as its first parameter and a closure code block as second parameter. Inside the `Closure` access to the category methods is available. As can be seen in the example above even JDK classes like `java.lang.Integer` or `java.util.Date` can be enriched with user-defined methods.

A category needs not to be directly exposed to the user code, the following will also do:

```groovy
class JPACategory{
  // Let's enhance JPA EntityManager without getting into the JSR committee
  static void persistAll(EntityManager em , Object[] entities) { //add an interface to save all
    entities?.each { em.persist(it) }
  }
}

def transactionContext = {
  EntityManager em, Closure c ->
  def tx = em.transaction
  try {
    tx.begin()
    use(JPACategory) {
      c()
    }
    tx.commit()
  } catch (e) {
    tx.rollback()
  } finally {
    //cleanup your resource here
  }
}

// user code, they always forget to close resource in exception, some even forget to commit, let's not rely on them.
EntityManager em; //probably injected
transactionContext (em) {
 em.persistAll(obj1, obj2, obj3)
 // let's do some logics here to make the example sensible
 em.persistAll(obj2, obj4, obj6)
}
```

When we have a look at the `groovy.time.TimeCategory` class we see that the extension methods are all declared as `static` methods. In fact, this is one of the requirements that must be met by category classes for its methods to be successfully added to a class inside the `use` code block:

```groovy
public class TimeCategory {

    public static Date plus(final Date date, final BaseDuration duration) {
        return duration.plus(date);
    }

    public static Date minus(final Date date, final BaseDuration duration) {
        final Calendar cal = Calendar.getInstance();

        cal.setTime(date);
        cal.add(Calendar.YEAR, -duration.getYears());
        cal.add(Calendar.MONTH, -duration.getMonths());
        cal.add(Calendar.DAY_OF_YEAR, -duration.getDays());
        cal.add(Calendar.HOUR_OF_DAY, -duration.getHours());
        cal.add(Calendar.MINUTE, -duration.getMinutes());
        cal.add(Calendar.SECOND, -duration.getSeconds());
        cal.add(Calendar.MILLISECOND, -duration.getMillis());

        return cal.getTime();
    }

    // ...
```

Another requirement is the first argument of the static method must define the type the method is attached to once being activated. The other arguments are the normal arguments the method will take as parameters.

Because of the parameter and static method convention, category method definitions may be a bit less intuitive than normal method definitions. As an alternative Groovy comes with a `@Category` annotation that transforms annotated classes into category classes at compile-time.

```groovy
class Distance {
    def number
    String toString() { "${number}m" }
}

@Category(Number)
class NumberCategory {
    Distance getMeters() {
        new Distance(number: this)
    }
}

use (NumberCategory)  {
    assert 42.meters.toString() == '42m'
}
```

Applying the `@Category` annotation has the advantage of being able to use instance methods without the target type as a first parameter. The target type class is given as an argument to the annotation instead.

|      | There is a distinct section on `@Category` in the [compile-time metaprogramming section](https://docs.groovy-lang.org/latest/html/documentation/#xform-Category). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Metaclasses

As explained earlier, Metaclasses play a central role in method resolution. For every method invocation from groovy code, Groovy will find the `MetaClass` for the given object and delegate the method resolution to the metaclass via [MetaClass#invokeMethod](https://docs.groovy-lang.org/3.0.3/html/gapi/groovy/lang/MetaClass.html#invokeMethod(java.lang.Class, java.lang.Object, java.lang.String, java.lang.Object, boolean, boolean)) which should not be confused with [GroovyObject#invokeMethod](https://docs.groovy-lang.org/3.0.3/html/gapi/groovy/lang/GroovyObject.html#invokeMethod(java.lang.String, java.lang.Object)) which happens to be a method that the metaclass may eventually call.

###### The default metaclass `MetaClassImpl`

By default, objects get an instance of `MetaClassImpl` that implements the default method lookup. This method lookup includes looking up of the method in the object class ("regular" method) but also if no method is found this way it will resort to calling `methodMissing` and ultimately [GroovyObject#invokeMethod](https://docs.groovy-lang.org/3.0.3/html/gapi/groovy/lang/GroovyObject.html#invokeMethod(java.lang.String, java.lang.Object))

```groovy
class Foo {}

def f = new Foo()

assert f.metaClass =~ /MetaClassImpl/
```

###### Custom metaclasses

You can change the metaclass of any object or class and replace with a custom implementation of the `MetaClass` [interface](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/MetaClass.html). Usually you will want to subclass one of the existing metaclasses `MetaClassImpl`, `DelegatingMetaClass`, `ExpandoMetaClass`, `ProxyMetaClass`, etc. otherwise you will need to implement the complete method lookup logic. Before using a new metaclass instance you should call [groovy.lang.MetaClass#initialize()](https://docs.groovy-lang.org/3.0.3/html/gapi/groovy/lang/MetaClass.html#initialize()) otherwise the metaclass may or may not behave as expected.

Delegating metaclass

If you only need to decorate an existing metaclass the `DelegatingMetaClass` simplifies that use case. The old metaclass implementation is still accessible via `super` making easy to apply pretransformations to the inputs, routing to other methods and postprocess the outputs.

```groovy
class Foo { def bar() { "bar" } }

class MyFooMetaClass extends DelegatingMetaClass {
  MyFooMetaClass(MetaClass metaClass) { super(metaClass) }
  MyFooMetaClass(Class theClass) { super(theClass) }

  Object invokeMethod(Object object, String methodName, Object[] args) {
     def result = super.invokeMethod(object,methodName.toLowerCase(), args)
     result.toUpperCase();
  }
}


def mc =  new MyFooMetaClass(Foo.metaClass)
mc.initialize()

Foo.metaClass = mc
def f = new Foo()

assert f.BAR() == "BAR" // the new metaclass routes .BAR() to .bar() and uppercases the result
```

Magic package

It is possible to change the metaclass at startup time by giving the metaclass a specially crafted (magic) class name and package name. In order to change the metaclass for `java.lang.Integer` it’s enough to put a class `groovy.runtime.metaclass.java.lang.IntegerMetaClass` in the classpath. This is useful, for example, when working with frameworks if you want to do metaclass changes before your code is executed by the framework. The general form of the magic package is `groovy.runtime.metaclass.[package].[class]MetaClass`. In the example below the `[package]` is `java.lang` and the `[class]` is `Integer`:

```groovy
// file: IntegerMetaClass.groovy
package groovy.runtime.metaclass.java.lang;

class IntegerMetaClass extends DelegatingMetaClass {
  IntegerMetaClass(MetaClass metaClass) { super(metaClass) }
  IntegerMetaClass(Class theClass) { super(theClass) }
  Object invokeMethod(Object object, String name, Object[] args) {
    if (name =~ /isBiggerThan/) {
      def other = name.split(/isBiggerThan/)[1].toInteger()
      object > other
    } else {
      return super.invokeMethod(object,name, args);
    }
  }
}
```

By compiling the above file with `groovyc IntegerMetaClass.groovy` a `./groovy/runtime/metaclass/java/lang/IntegerMetaClass.class` will be generated. The example below will use this new metaclass:

```groovy
// File testInteger.groovy
def i = 10

assert i.isBiggerThan5()
assert !i.isBiggerThan15()

println i.isBiggerThan5()
```

By running that file with `groovy -cp . testInteger.groovy` the `IntegerMetaClass` will be in the classpath and therefore it will become the metaclass for `java.lang.Integer` intercepting the method calls to `isBiggerThan*()` methods.

###### Per instance metaclass

You can change the metaclass of individual objects separately, so it’s possible to have multiple object of the same class with different metaclasses.

```groovy
class Foo { def bar() { "bar" }}

class FooMetaClass extends DelegatingMetaClass {
  FooMetaClass(MetaClass metaClass) { super(metaClass) }
  Object invokeMethod(Object object, String name, Object[] args) {
      super.invokeMethod(object,name,args).toUpperCase()
  }
}

def f1 = new Foo()
def f2 = new Foo()
f2.metaClass = new FooMetaClass(f2.metaClass)

assert f1.bar() == "bar"
assert f2.bar() == "BAR"
assert f1.metaClass =~ /MetaClassImpl/
assert f2.metaClass =~ /FooMetaClass/
assert f1.class.toString() == "class Foo"
assert f2.class.toString() == "class Foo"
```

###### ExpandoMetaClass

Groovy comes with a special `MetaClass` the so-called `ExpandoMetaClass`. It is special in that it allows for dynamically adding or changing methods, constructors, properties and even static methods by using a neat closure syntax.

Applying those modifications can be especially useful in mocking or stubbing scenarios as shown in the [Testing Guide](https://docs.groovy-lang.org/latest/html/documentation/#testing_guide_emc).

Every `java.lang.Class` is supplied by Groovy with a special `metaClass` property that will give you a reference to an `ExpandoMetaClass` instance. This instance can then be used to add methods or change the behaviour of already existing ones.

|      | By default `ExpandoMetaClass` doesn’t do inheritance. To enable this you must call `ExpandoMetaClass#enableGlobally()` before your app starts such as in the main method or servlet bootstrap. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The following sections go into detail on how `ExpandoMetaClass` can be used in various scenarios.

Methods

Once the `ExpandoMetaClass` is accessed by calling the `metaClass` property, methods can added by using either the left shift `<<` or the `=` operator.

|      | Note that the left shift operator is used to *append* a new method. If a public method with the same name and parameter types is declared by the class or interface, including those inherited from superclasses and superinterfaces but excluding those added to the `metaClass` at runtime, an exception will be thrown. If you want to *replace* a method declared by the class or interface you can use the `=` operator. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The operators are applied on a non-existent property of `metaClass` passing an instance of a `Closure` code block.

```groovy
class Book {
   String title
}

Book.metaClass.titleInUpperCase << {-> title.toUpperCase() }

def b = new Book(title:"The Stand")

assert "THE STAND" == b.titleInUpperCase()
```

The example above shows how a new method can be added to a class by accessing the `metaClass` property and using the `<<` or `=` operator to assign a `Closure` code block. The `Closure` parameters are interpreted as method parameters. Parameterless methods can be added by using the `{→ …}` syntax.

Properties

`ExpandoMetaClass` supports two mechanisms for adding or overriding properties.

Firstly, it has support for declaring a *mutable property* by simply assigning a value to a property of `metaClass`:

```groovy
class Book {
   String title
}

Book.metaClass.author = "Stephen King"
def b = new Book()

assert "Stephen King" == b.author
```

Another way is to add getter and/or setter methods by using the standard mechanisms for adding instance methods.

```groovy
class Book {
  String title
}
Book.metaClass.getAuthor << {-> "Stephen King" }

def b = new Book()

assert "Stephen King" == b.author
```

In the source code example above the property is dictated by the closure and is a read-only property. It is feasible to add an equivalent setter method but then the property value needs to be stored for later usage. This could be done as shown in the following example.

```groovy
class Book {
  String title
}

def properties = Collections.synchronizedMap([:])

Book.metaClass.setAuthor = { String value ->
   properties[System.identityHashCode(delegate) + "author"] = value
}
Book.metaClass.getAuthor = {->
   properties[System.identityHashCode(delegate) + "author"]
}
```

This is not the only technique however. For example in a servlet container one way might be to store the values in the currently executing request as request attributes (as is done in some cases in Grails).

Constructors

Constructors can be added by using a special `constructor` property. Either the `<<` or `=` operator can be used to assign a `Closure` code block. The `Closure` arguments will become the constructor arguments when the code is executed at runtime.

```groovy
class Book {
    String title
}
Book.metaClass.constructor << { String title -> new Book(title:title) }

def book = new Book('Groovy in Action - 2nd Edition')
assert book.title == 'Groovy in Action - 2nd Edition'
```

|      | Be careful when adding constructors however, as it is very easy to get into stack overflow troubles. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Static Methods

Static methods can be added using the same technique as instance methods with the addition of the `static` qualifier before the method name.

```groovy
class Book {
   String title
}

Book.metaClass.static.create << { String title -> new Book(title:title) }

def b = Book.create("The Stand")
```

Borrowing Methods

With `ExpandoMetaClass` it is possible to use Groovy’s method pointer syntax to borrow methods from other classes.

```groovy
class Person {
    String name
}
class MortgageLender {
   def borrowMoney() {
      "buy house"
   }
}

def lender = new MortgageLender()

Person.metaClass.buyHouse = lender.&borrowMoney

def p = new Person()

assert "buy house" == p.buyHouse()
```

Dynamic Method Names

Since Groovy allows you to use Strings as property names this in turns allows you to dynamically create method and property names at runtime. To create a method with a dynamic name simply use the language feature of reference property names as strings.

```groovy
class Person {
   String name = "Fred"
}

def methodName = "Bob"

Person.metaClass."changeNameTo${methodName}" = {-> delegate.name = "Bob" }

def p = new Person()

assert "Fred" == p.name

p.changeNameToBob()

assert "Bob" == p.name
```

The same concept can be applied to static methods and properties.

One application of dynamic method names can be found in the Grails web application framework. The concept of "dynamic codecs" is implemented by using dynamic method names.

`HTMLCodec` Class

```groovy
class HTMLCodec {
    static encode = { theTarget ->
        HtmlUtils.htmlEscape(theTarget.toString())
    }

    static decode = { theTarget ->
    	HtmlUtils.htmlUnescape(theTarget.toString())
    }
}
```

The example above shows a codec implementation. Grails comes with various codec implementations each defined in a single class. At runtime there will be multiple codec classes in the application classpath. At application startup the framework adds a `encodeXXX` and a `decodeXXX` method to certain meta-classes where `XXX` is the first part of the codec class name (e.g. `encodeHTML`). This mechanism is in the following shown in some Groovy pseudo-code:

```groovy
def codecs = classes.findAll { it.name.endsWith('Codec') }

codecs.each { codec ->
    Object.metaClass."encodeAs${codec.name-'Codec'}" = { codec.newInstance().encode(delegate) }
    Object.metaClass."decodeFrom${codec.name-'Codec'}" = { codec.newInstance().decode(delegate) }
}


def html = '<html><body>hello</body></html>'

assert '<html><body>hello</body></html>' == html.encodeAsHTML()
```

Runtime Discovery

At runtime it is often useful to know what other methods or properties exist at the time the method is executed. `ExpandoMetaClass` provides the following methods as of this writing:

- `getMetaMethod`
- `hasMetaMethod`
- `getMetaProperty`
- `hasMetaProperty`

Why can’t you just use reflection? Well because Groovy is different, it has the methods that are "real" methods and methods that are available only at runtime. These are sometimes (but not always) represented as MetaMethods. The MetaMethods tell you what methods are available at runtime, thus your code can adapt.

This is of particular use when overriding `invokeMethod`, `getProperty` and/or `setProperty`.

GroovyObject Methods

Another feature of `ExpandoMetaClass` is that it allows to override the methods `invokeMethod`, `getProperty` and `setProperty`, all of them can be found in the `groovy.lang.GroovyObject` class.

The following example shows how to override `invokeMethod`:

```groovy
class Stuff {
   def invokeMe() { "foo" }
}

Stuff.metaClass.invokeMethod = { String name, args ->
   def metaMethod = Stuff.metaClass.getMetaMethod(name, args)
   def result
   if(metaMethod) result = metaMethod.invoke(delegate,args)
   else {
      result = "bar"
   }
   result
}

def stf = new Stuff()

assert "foo" == stf.invokeMe()
assert "bar" == stf.doStuff()
```

The first step in the `Closure` code is to lookup the `MetaMethod` for the given name and arguments. If the method can be found everything is fine and it is delegated to. If not, a dummy value is returned.

|      | A `MetaMethod` is a method that is known to exist on the `MetaClass` whether added at runtime or at compile-time. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The same logic can be used to override `setProperty` or `getProperty`.

```groovy
class Person {
   String name = "Fred"
}

Person.metaClass.getProperty = { String name ->
   def metaProperty = Person.metaClass.getMetaProperty(name)
   def result
   if(metaProperty) result = metaProperty.getProperty(delegate)
   else {
      result = "Flintstone"
   }
   result
}

def p = new Person()

assert "Fred" == p.name
assert "Flintstone" == p.other
```

The important thing to note here is that instead of a `MetaMethod` a `MetaProperty` instance is looked up. If that exists the `getProperty` method of the `MetaProperty` is called, passing the delegate.

Overriding Static invokeMethod

`ExpandoMetaClass` even allows for overriding static method with a special `invokeMethod` syntax.

```groovy
class Stuff {
   static invokeMe() { "foo" }
}

Stuff.metaClass.'static'.invokeMethod = { String name, args ->
   def metaMethod = Stuff.metaClass.getStaticMetaMethod(name, args)
   def result
   if(metaMethod) result = metaMethod.invoke(delegate,args)
   else {
      result = "bar"
   }
   result
}

assert "foo" == Stuff.invokeMe()
assert "bar" == Stuff.doStuff()
```

The logic that is used for overriding the static method is the same as we’ve seen before for overriding instance methods. The only difference is the access to the `metaClass.static` property and the call to `getStaticMethodName` for retrieving the static `MetaMethod` instance.

Extending Interfaces

It is possible to add methods onto interfaces with `ExpandoMetaClass`. To do this however, it **must** be enabled globally using the `ExpandoMetaClass.enableGlobally()` method before application start-up.

```groovy
List.metaClass.sizeDoubled = {-> delegate.size() * 2 }

def list = []

list << 1
list << 2

assert 4 == list.sizeDoubled()
```

##### Extension modules

###### Extending existing classes

An extension module allows you to add new methods to existing classes, including classes which are precompiled, like classes from the JDK. Those new methods, unlike those defined through a metaclass or using a category, are available globally. For example, when you write:

Standard extension method

```groovy
def file = new File(...)
def contents = file.getText('utf-8')
```

The `getText` method doesn’t exist on the `File` class. However, Groovy knows it because it is defined in a special class, `ResourceGroovyMethods`:

ResourceGroovyMethods.java

```java
public static String getText(File file, String charset) throws IOException {
 return IOGroovyMethods.getText(newReader(file, charset));
}
```

You may notice that the extension method is defined using a static method in a helper class (where various extension methods are defined). The first argument of the `getText` method corresponds to the receiver, while additional parameters correspond to the arguments of the extension method. So here, we are defining a method called *getText* on the `File` class (because the first argument is of type `File`), which takes a single argument as a parameter (the encoding `String`).

The process of creating an extension module is simple:

- write an extension class like above
- write a module descriptor file

Then you have to make the extension module visible to Groovy, which is as simple as having the extension module classes and descriptor available on classpath. This means that you have the choice:

- either provide the classes and module descriptor directly on classpath
- or bundle your extension module into a jar for reusability

An extension module may add two kind of methods to a class:

- instance methods (to be called on an instance of a class)
- static methods (to be called on the class itself)

###### Instance methods

To add an instance method to an existing class, you need to create an extension class. For example, let’s say you want to add a `maxRetries` method on `Integer` which accepts a closure and executes it at most *n* times until no exception is thrown. To do that, you only need to write the following:

MaxRetriesExtension.groovy

```groovy
class MaxRetriesExtension {                                     
    static void maxRetries(Integer self, Closure code) {        
        assert self >= 0
        int retries = self
        Throwable e = null
        while (retries > 0) {
            try {
                code.call()
                break
            } catch (Throwable err) {
                e = err
                retries--
            }
        }
        if (retries == 0 && e) {
            throw e
        }
    }
}
```

|      | The extension class                                          |
| ---- | ------------------------------------------------------------ |
|      | First argument of the static method corresponds to the receiver of the message, that is to say the extended instance |

Then, after [having declared your extension class](https://docs.groovy-lang.org/latest/html/documentation/#module-descriptor), you can call it this way:

```groovy
int i=0
5.maxRetries {
    i++
}
assert i == 1
i=0
try {
    5.maxRetries {
        i++
        throw new RuntimeException("oops")
    }
} catch (RuntimeException e) {
    assert i == 5
}
```

###### Static methods

It is also possible to add static methods to a class. In that case, the static method needs to be defined in its **own** file. Static and instance extension methods **cannot** be present in the same class.

StaticStringExtension.groovy

```groovy
class StaticStringExtension {                                       
    static String greeting(String self) {                           
        'Hello, world!'
    }
}
```

|      | The static extension class                                   |
| ---- | ------------------------------------------------------------ |
|      | First argument of the static method corresponds to the class being extended and is **unused** |

In which case you can call it directly on the `String` class:

```groovy
assert String.greeting() == 'Hello, world!'
```

###### Module descriptor

For Groovy to be able to load your extension methods, you must declare your extension helper classes. You must create a file named `org.codehaus.groovy.runtime.ExtensionModule` into the `META-INF/groovy` directory:

org.codehaus.groovy.runtime.ExtensionModule

```
moduleName=Test module for specifications
moduleVersion=1.0-test
extensionClasses=support.MaxRetriesExtension
staticExtensionClasses=support.StaticStringExtension
```

The module descriptor requires 4 keys:

- *moduleName* : the name of your module
- *moduleVersion*: the version of your module. Note that version number is only used to check that you don’t load the same module in two different versions.
- *extensionClasses*: the list of extension helper classes for instance methods. You can provide several classes, given that they are comma separated.
- *staticExtensionClasses*: the list of extension helper classes for static methods. You can provide several classes, given that they are comma separated.

Note that it is not required for a module to define both static helpers and instance helpers, and that you may add several classes to a single module. You can also extend different classes in a single module without problem. It is even possible to use different classes in a single extension class, but it is recommended to group extension methods into classes by feature set.

###### Extension modules and classpath

It’s worth noting that you can’t use an extension which is compiled at the same time as code using it. That means that to use an extension, it **has** to be available on classpath, as compiled classes, before the code using it gets compiled. Usually, this means that you can’t have the *test* classes in the same source unit as the extension class itself. Since in general, test sources are separated from normal sources and executed in another step of the build, this is not an issue.

###### Compatibility with type checking

Unlike categories, extension modules are compatible with type checking: if they are found on classpath, then the type checker is aware of the extension methods and will not complain when you call them. It is also compatible with static compilation.

#### 3.4.2. Compile-time metaprogramming

Compile-time metaprogramming in Groovy allows code generation at compile-time. Those transformations are altering the Abstract Syntax Tree (AST) of a program, which is why in Groovy we call it AST transformations. AST transformations allow you to hook into the compilation process, modify the AST and continue the compilation process to generate regular bytecode. Compared to runtime metaprogramming, this has the advantage of making the changes visible in the class file itself (that is to say, in the bytecode). Making it visible in the bytecode is important for example if you want the transformations to be part of the class contract (implementing interfaces, extending abstract classes, …) or even if you need your class to be callable from Java (or other JVM languages). For example, an AST transformation can add methods to a class. If you do it with runtime metaprogramming, the new method would only be visible from Groovy. If you do the same using compile-time metaprogramming, the method would be visible from Java too. Last but not least, performance would likely be better with compile-time metaprogramming (because no initialization phase is required).

In this section, we will start with explaining the various compile-time transformations that are bundled with the Groovy distribution. In a subsequent section, we will describe how you can [implement your own AST transformations](https://docs.groovy-lang.org/latest/html/documentation/#developing-ast-xforms) and what are the disadvantages of this technique.

##### Available AST transformations

Groovy comes with various AST transformations covering different needs: reducing boilerplate (code generation), implementing design patterns (delegation, …), logging, declarative concurrency, cloning, safer scripting, tweaking the compilation, implementing Swing patterns, testing and eventually managing dependencies. If none of those AST transformations cover your needs, you can still implement your own, as show in section [Developing your own AST transformations](https://docs.groovy-lang.org/latest/html/documentation/#developing-ast-xforms).

AST transformations can be separated into two categories:

- global AST transformations are applied transparently, globally, as soon as they are found on compile classpath
- local AST transformations are applied by annotating the source code with markers. Unlike global AST transformations, local AST transformations may support parameters.

Groovy doesn’t ship with any global AST transformation, but you can find a list of local AST transformations available for you to use in your code here:

###### Code generation transformations

This category of transformation includes AST transformations which help removing boilerplate code. This is typically code that you have to write but that does not carry any useful information. By autogenerating this boilerplate code, the code you have to write is left clean and concise and the chance of introducing an error by getting such boilerplate code incorrect is reduced.

```
@groovy.transform.ToString
```

The `@ToString` AST transformation generates a human readable `toString` representation of the class. For example, annotating the `Person` class like below will automatically generate the `toString` method for you:

```groovy
import groovy.transform.ToString

@ToString
class Person {
    String firstName
    String lastName
}
```

With this definition, then the following assertion passes, meaning that a `toString` method taking the field values from the class and printing them out has been generated:

```groovy
def p = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p.toString() == 'Person(Jack, Nicholson)'
```

The `@ToString` annotation accepts several parameters which are summarized in the following table:

| Attribute              | Default value                                | Description                                                  | Example                                                      |
| :--------------------- | :------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| excludes               | Empty list                                   | List of properties to exclude from toString                  | `@ToString(excludes=['firstName']) class Person {    String firstName    String lastName } def p = new Person(firstName: 'Jack', lastName: 'Nicholson') assert p.toString() == 'Person(Nicholson)'` |
| includes               | Undefined marker list (indicates all fields) | List of fields to include in toString                        | `@ToString(includes=['lastName']) class Person {    String firstName    String lastName } def p = new Person(firstName: 'Jack', lastName: 'Nicholson') assert p.toString() == 'Person(Nicholson)'` |
| includeSuper           | False                                        | Should superclass be included in toString                    | `@ToString class Id { long id } @ToString(includeSuper=true) class Person extends Id {    String firstName    String lastName } def p = new Person(id:1, firstName: 'Jack', lastName: 'Nicholson') assert p.toString() == 'Person(Jack, Nicholson, Id(1))'` |
| includeNames           | false                                        | Whether to include names of properties in generated toString. | `@ToString(includeNames=true) class Person {    String firstName    String lastName } def p = new Person(firstName: 'Jack', lastName: 'Nicholson') assert p.toString() == 'Person(firstName:Jack, lastName:Nicholson)'` |
| includeFields          | False                                        | Should fields be included in toString, in addition to properties | `@ToString(includeFields=true) class Person {    String firstName    String lastName    private int age    void test() {       age = 42    } } def p = new Person(firstName: 'Jack', lastName: 'Nicholson') p.test() assert p.toString() == 'Person(Jack, Nicholson, 42)'` |
| includeSuperProperties | False                                        | Should super properties be included in toString              | `class Person {    String name } @ToString(includeSuperProperties = true, includeNames = true) class BandMember extends Person {    String bandName } def bono = new BandMember(name:'Bono', bandName: 'U2').toString() assert bono.toString() == 'BandMember(bandName:U2, name:Bono)'` |
| includeSuperFields     | False                                        | Should visible super fields be included in toString          | `class Person {    protected String name } @ToString(includeSuperFields = true, includeNames = true) @MapConstructor(includeSuperFields = true) class BandMember extends Person {    String bandName } def bono = new BandMember(name:'Bono', bandName: 'U2').toString() assert bono.toString() == 'BandMember(bandName:U2, name:Bono)'` |
| ignoreNulls            | False                                        | Should properties/fields with null value be displayed        | `@ToString(ignoreNulls=true) class Person {    String firstName    String lastName } def p = new Person(firstName: 'Jack') assert p.toString() == 'Person(Jack)'` |
| includePackage         | True                                         | Use fully qualified class name instead of simple name in toString | `@ToString(includePackage=true) class Person {    String firstName    String lastName } def p = new Person(firstName: 'Jack', lastName:'Nicholson') assert p.toString() == 'acme.Person(Jack, Nicholson)'` |
| allProperties          | True                                         | Include all JavaBean properties in toString                  | `@ToString(includeNames=true) class Person {    String firstName    String getLastName() { 'Nicholson' } } def p = new Person(firstName: 'Jack') assert p.toString() == 'acme.Person(firstName:Jack, lastName:Nicholson)'` |
| cache                  | False                                        | Cache the toString string. Should only be set to true if the class is immutable. | `@ToString(cache=true) class Person {    String firstName    String lastName } def p = new Person(firstName: 'Jack', lastName:'Nicholson') def s1 = p.toString() def s2 = p.toString() assert s1 == s2 assert s1 == 'Person(Jack, Nicholson)' assert s1.is(s2) // same instance` |
| allNames               | False                                        | Should fields and/or properties with internal names be included in the generated toString | `@ToString(allNames=true) class Person {    String $firstName } def p = new Person($firstName: "Jack") assert p.toString() == 'acme.Person(Jack)'` |

```
@groovy.transform.EqualsAndHashCode
```

The `@EqualsAndHashCode` AST transformation aims at generating `equals` and `hashCode` methods for you. The generated hashcode follows the best practices as described in *Effective Java* by *Josh Bloch*:

```groovy
import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
def p2 = new Person(firstName: 'Jack', lastName: 'Nicholson')

assert p1==p2
assert p1.hashCode() == p2.hashCode()
```

There are several options available to tweak the behavior of `@EqualsAndHashCode`:

| Attribute     | Default value                                 | Description                                                  | Example                                                      |
| :------------ | :-------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| excludes      | Empty list                                    | List of properties to exclude from equals/hashCode           | `import groovy.transform.EqualsAndHashCode @EqualsAndHashCode(excludes=['firstName']) class Person {    String firstName    String lastName } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson') def p2 = new Person(firstName: 'Bob', lastName: 'Nicholson') assert p1==p2 assert p1.hashCode() == p2.hashCode()` |
| includes      | Undefined marker list (indicating all fields) | List of fields to include in equals/hashCode                 | `import groovy.transform.EqualsAndHashCode @EqualsAndHashCode(includes=['lastName']) class Person {    String firstName    String lastName } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson') def p2 = new Person(firstName: 'Bob', lastName: 'Nicholson') assert p1==p2 assert p1.hashCode() == p2.hashCode()` |
| cache         | False                                         | Cache the hashCode computation. Should only be set to true if the class is immutable. | `import groovy.transform.EqualsAndHashCode import groovy.transform.Immutable @Immutable class SlowHashCode {    static final SLEEP_PERIOD = 500     int hashCode() {        sleep SLEEP_PERIOD        127    } } @EqualsAndHashCode(cache=true) @Immutable class Person {    SlowHashCode slowHashCode = new SlowHashCode() } def p = new Person() p.hashCode() def start = System.currentTimeMillis() p.hashCode() assert System.currentTimeMillis() - start < SlowHashCode.SLEEP_PERIOD` |
| callSuper     | False                                         | Whether to include super in equals and hashCode calculations | `import groovy.transform.EqualsAndHashCode @EqualsAndHashCode class Living {    String race } @EqualsAndHashCode(callSuper=true) class Person extends Living {    String firstName    String lastName } def p1 = new Person(race:'Human', firstName: 'Jack', lastName: 'Nicholson') def p2 = new Person(race: 'Human being', firstName: 'Jack', lastName: 'Nicholson') assert p1!=p2 assert p1.hashCode() != p2.hashCode()` |
| includeFields | False                                         | Should fields be included in equals/hashCode, in addition to properties | `import groovy.transform.EqualsAndHashCode @EqualsAndHashCode(includeFields=true) class Person {    private String firstName     Person(String firstName) {        this.firstName = firstName    } } def p1 = new Person('Jack') def p2 = new Person('Jack') def p3 = new Person('Bob') assert p1 == p2 assert p1 != p3` |
| useCanEqual   | True                                          | Should equals call canEqual helper method.                   | See http://www.artima.com/lejava/articles/equality.html      |
| allProperties | False                                         | Should JavaBean properties be included in equals and hashCode calculations | `@EqualsAndHashCode(allProperties=true, excludes='first, last') class Person {    String first, last    String getInitials() { first[0] + last[0] } } def p1 = new Person(first: 'Jack', last: 'Smith') def p2 = new Person(first: 'Jack', last: 'Spratt') def p3 = new Person(first: 'Bob', last: 'Smith') assert p1 == p2 assert p1.hashCode() == p2.hashCode() assert p1 != p3 assert p1.hashCode() != p3.hashCode()` |
| allNames      | False                                         | Should fields and/or properties with internal names be included in equals and hashCode calculations | `import groovy.transform.EqualsAndHashCode @EqualsAndHashCode(allNames=true) class Person {    String $firstName } def p1 = new Person($firstName: 'Jack') def p2 = new Person($firstName: 'Bob') assert p1 != p2 assert p1.hashCode() != p2.hashCode()` |

```
@groovy.transform.TupleConstructor
```

The `@TupleConstructor` annotation aims at eliminating boilerplate code by generating constructors for you. A tuple constructor is created having a parameter for each property (and possibly each field). Each parameter has a default value (using the initial value of the property if present or otherwise Java’s default value according to the properties type).

Implementation Details

Normally you don’t need to understand the imp[ementation details of the generated constructor(s); you just use them in the normal way. However, if you want to add multiple constructors, understand Java integration options or meet requirements of some dependency injection frameworks, then some details are useful.

As previously mentioned, the generated constructor has default values applied. In later compilation phases, the Groovy compiler’s standard default value processing behavior is then applied. The end result is that multiple constructors are placed within the bytecode of your class. This provides a well understood semantics and is also useful for Java integration purposes. As an example, the following code will generate 3 constructors:

```groovy
import groovy.transform.TupleConstructor

@TupleConstructor
class Person {
    String firstName
    String lastName
}

// traditional map-style constructor
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
// generated tuple constructor
def p2 = new Person('Jack', 'Nicholson')
// generated tuple constructor with default value for second property
def p3 = new Person('Jack')
```

The first constructor is a no-arg constructor which allows the traditional map-style construction so long as you don’t have final properties. Groovy calls the no-arg constructor and then the relevant setters under the covers. It is worth noting that if the first property (or field) has type LinkedHashMap or if there is a single Map, AbstractMap or HashMap property (or field), then the map-style named arguments won’t be available.

The other constructors are generated by taking the properties in the order they are defined. Groovy will generate as many constructors as there are properties (or fields, depending on the options).

Setting the `defaults` attribute (see the available configuration options table) to `false`, disables the normal default values behavior which means:

- Exactly one constructor will be produced
- Attempting to use an initial value will produce an error
- Map-style named arguments won’t be available

This attribute is normally only used in situations where another Java framework is expecting exactly one constructor, e.g. injection frameworks or JUnit parameterized runners.

Immutability support

If the `@PropertyOptions` annotation is also found on the class with the `@TupleConstructor` annotation, then the generated constructor may contain custom property handling logic. The `propertyHandler` attribute on the `@PropertyOptions` annotation could for instance be set to `ImmutablePropertyHandler` which will result in the addition of the necessary logic for immutable classes (defensive copy in, cloning, etc.). This normally would happen automatically behind the scenes when you use the `@Immutable` meta-annotation. Some of the annotation attributes might not be supported by all property handlers.

Customization options

The `@TupleConstructor` AST transformation accepts several annotation attributes:

| Attribute              | Default value                         | Description                                                  | Example                                                      |
| :--------------------- | :------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| excludes               | Empty list                            | List of properties to exclude from tuple constructor generation | `import groovy.transform.TupleConstructor @TupleConstructor(excludes=['lastName']) class Person {    String firstName    String lastName } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson') def p2 = new Person('Jack') try {    // will fail because the second property is excluded    def p3 = new Person('Jack', 'Nicholson') } catch (e) {    assert e.message.contains ('Could not find matching constructor') }` |
| includes               | Undefined list (indicates all fields) | List of fields to include in tuple constructor generation    | `import groovy.transform.TupleConstructor @TupleConstructor(includes=['firstName']) class Person {    String firstName    String lastName } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson') def p2 = new Person('Jack') try {    // will fail because the second property is not included    def p3 = new Person('Jack', 'Nicholson') } catch (e) {    assert e.message.contains ('Could not find matching constructor') }` |
| includeProperties      | True                                  | Should properties be included in tuple constructor generation | `import groovy.transform.TupleConstructor @TupleConstructor(includeProperties=false) class Person {    String firstName    String lastName } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson') try {    def p2 = new Person('Jack', 'Nicholson') } catch(e) {    // will fail because properties are not included }` |
| includeFields          | False                                 | Should fields be included in tuple constructor generation, in addition to properties | `import groovy.transform.TupleConstructor @TupleConstructor(includeFields=true) class Person {    String firstName    String lastName    private String occupation    public String toString() {        "$firstName $lastName: $occupation"    } } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson', occupation: 'Actor') def p2 = new Person('Jack', 'Nicholson', 'Actor') assert p1.firstName == p2.firstName assert p1.lastName == p2.lastName assert p1.toString() == 'Jack Nicholson: Actor' assert p1.toString() == p2.toString()` |
| includeSuperProperties | True                                  | Should properties from super classes be included in tuple constructor generation | `import groovy.transform.TupleConstructor class Base {    String occupation } @TupleConstructor(includeSuperProperties=true) class Person extends Base {    String firstName    String lastName    public String toString() {        "$firstName $lastName: $occupation"    } } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson') def p2 = new Person('Actor', 'Jack', 'Nicholson') assert p1.firstName == p2.firstName assert p1.lastName == p2.lastName assert p1.toString() == 'Jack Nicholson: null' assert p2.toString() == 'Jack Nicholson: Actor'` |
| includeSuperFields     | False                                 | Should fields from super classes be included in tuple constructor generation | `import groovy.transform.TupleConstructor class Base {    protected String occupation    public String occupation() { this.occupation } } @TupleConstructor(includeSuperFields=true) class Person extends Base {    String firstName    String lastName    public String toString() {        "$firstName $lastName: ${occupation()}"    } } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson', occupation: 'Actor') def p2 = new Person('Actor', 'Jack', 'Nicholson') assert p1.firstName == p2.firstName assert p1.lastName == p2.lastName assert p1.toString() == 'Jack Nicholson: Actor' assert p2.toString() == p1.toString()` |
| callSuper              | False                                 | Should super properties be called within a call to the parent constructor rather than set as properties | `import groovy.transform.TupleConstructor class Base {    String occupation    Base() {}    Base(String job) { occupation = job?.toLowerCase() } } @TupleConstructor(includeSuperProperties = true, callSuper=true) class Person extends Base {    String firstName    String lastName    public String toString() {        "$firstName $lastName: $occupation"    } } def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson') def p2 = new Person('ACTOR', 'Jack', 'Nicholson') assert p1.firstName == p2.firstName assert p1.lastName == p2.lastName assert p1.toString() == 'Jack Nicholson: null' assert p2.toString() == 'Jack Nicholson: actor'` |
| force                  | False                                 | By default, the transformation will do nothing if a constructor is already defined. Setting this attribute to true, the constructor will be generated and it’s your responsibility to ensure that no duplicate constructor is defined. | `import groovy.transform.* @ToString @TupleConstructor(force=true) final class Person {    String name    // explicit constructor would normally disable tuple constructor    Person(String first, String last) { this("$first $last") } } assert new Person('john smith').toString() == 'Person(john smith)' assert new Person('john', 'smith').toString() == 'Person(john smith)'` |
| defaults               | True                                  | Indicates that default value processing is enabled for constructor parameters. Set to false to obtain exactly one constructor but with initial value support and named-arguments disabled. | `@ToString @TupleConstructor(defaults=false) class Musician {  String name  String instrument  int born } assert new Musician('Jimi', 'Guitar', 1942).toString() == 'Musician(Jimi, Guitar, 1942)' assert Musician.constructors.size() == 1` |
| useSetters             | False                                 | By default, the transformation will directly set the backing field of each property from its corresponding constructor parameter. Setting this attribute to true, the constructor will instead call setters if they exist. It’s usually deemed bad style from within a constructor to call setters that can be overridden. It’s your responsibility to avoid such bad style. | `import groovy.transform.* @ToString @TupleConstructor(useSetters=true) final class Foo {    String bar    void setBar(String bar) {        this.bar = bar?.toUpperCase() // null-safe    } } assert new Foo('cat').toString() == 'Foo(CAT)' assert new Foo(bar: 'cat').toString() == 'Foo(CAT)'` |
| allNames               | False                                 | Should fields and/or properties with internal names be included within the constructor | `import groovy.transform.TupleConstructor @TupleConstructor(allNames=true) class Person {    String $firstName } def p = new Person('Jack') assert p.$firstName == 'Jack'` |
| allProperties          | False                                 | Should JavaBean properties be included within the constructor | `@TupleConstructor(allProperties=true) class Person {    String first    private String last    void setLast(String last) {        this.last = last    }    String getName() { "$first $last" } } assert new Person('john', 'smith').name == 'john smith'` |
| pre                    | empty                                 | A closure containing statements to be inserted at the start of the generated constructor(s) | `import groovy.transform.TupleConstructor @TupleConstructor(pre={ first = first?.toLowerCase() }) class Person {    String first } def p = new Person('Jack') assert p.first == 'jack'` |
| post                   | empty                                 | A closure containing statements to be inserted at the end of the generated constructor(s) | `import groovy.transform.TupleConstructor import static groovy.test.GroovyAssert.shouldFail @TupleConstructor(post={ assert first }) class Person {    String first } def jack = new Person('Jack') shouldFail {  def unknown = new Person() }` |

Setting the `defaults` annotation attribute to `false` and the `force` annotation attribute to `true` allows multiple tuple constructors to be created by using different customization options for the different cases (provided each case has a different type signature) as shown in the following example:

```groovy
class Named {
  String name
}

@ToString(includeSuperProperties=true, ignoreNulls=true, includeNames=true, includeFields=true)
@TupleConstructor(force=true, defaults=false)
@TupleConstructor(force=true, defaults=false, includeFields=true)
@TupleConstructor(force=true, defaults=false, includeSuperProperties=true)
class Book extends Named {
  Integer published
  private Boolean fiction
  Book() {}
}

assert new Book("Regina", 2015).toString() == 'Book(published:2015, name:Regina)'
assert new Book(2015, false).toString() == 'Book(published:2015, fiction:false)'
assert new Book(2015).toString() == 'Book(published:2015)'
assert new Book().toString() == 'Book()'
assert Book.constructors.size() == 4
```

Similarly, here is another example using different options for `includes`:

```groovy
@ToString(includeSuperProperties=true, ignoreNulls=true, includeNames=true, includeFields=true)
@TupleConstructor(force=true, defaults=false, includes='name,year')
@TupleConstructor(force=true, defaults=false, includes='year,fiction')
@TupleConstructor(force=true, defaults=false, includes='name,fiction')
class Book {
    String name
    Integer year
    Boolean fiction
}

assert new Book("Regina", 2015).toString() == 'Book(name:Regina, year:2015)'
assert new Book(2015, false).toString() == 'Book(year:2015, fiction:false)'
assert new Book("Regina", false).toString() == 'Book(name:Regina, fiction:false)'
assert Book.constructors.size() == 3
@groovy.transform.MapConstructor
```

The `@MapConstructor` annotation aims at eliminating boilerplate code by generating a map constructor for you. A map constructor is created such that each property in the class is set based on the value in the supplied map having the key with the name of the property. Usage is as shown in this example:

```groovy
import groovy.transform.*

@ToString
@MapConstructor
class Person {
    String firstName
    String lastName
}

def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack, Nicholson)'
```

The generated constructor will be roughly like this:

```groovy
public Person(Map args) {
    if (args.containsKey('firstName')) {
        this.firstName = args.get('firstName')
    }
    if (args.containsKey('lastName')) {
        this.lastName = args.get('lastName')
    }
}
@groovy.transform.Canonical
```

The `@Canonical` meta-annotation combines the [@ToString](https://docs.groovy-lang.org/latest/html/documentation/#xform-ToString), [@EqualsAndHashCode](https://docs.groovy-lang.org/latest/html/documentation/#xform-EqualsAndHashCode) and [@TupleConstructor](https://docs.groovy-lang.org/latest/html/documentation/#xform-TupleConstructor) annotations:

```groovy
import groovy.transform.Canonical

@Canonical
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack, Nicholson)' // Effect of @ToString

def p2 = new Person('Jack','Nicholson') // Effect of @TupleConstructor
assert p2.toString() == 'Person(Jack, Nicholson)'

assert p1==p2 // Effect of @EqualsAndHashCode
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode
```

A similar immutable class can be generated using the [@Immutable](https://docs.groovy-lang.org/latest/html/documentation/#xform-Immutable) meta-annotation instead. The `@Canonical` meta-annotation supports the configuration options found in the annotations it aggregates. See those annotations for more details.

```groovy
import groovy.transform.Canonical

@Canonical(excludes=['lastName'])
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack)' // Effect of @ToString(excludes=['lastName'])

def p2 = new Person('Jack') // Effect of @TupleConstructor(excludes=['lastName'])
assert p2.toString() == 'Person(Jack)'

assert p1==p2 // Effect of @EqualsAndHashCode(excludes=['lastName'])
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode(excludes=['lastName'])
```

The `@Canonical` meta-annotation can be used in conjunction with an explicit use one or more of its component annotations, like this:

```groovy
import groovy.transform.Canonical

@Canonical(excludes=['lastName'])
class Person {
    String firstName
    String lastName
}
def p1 = new Person(firstName: 'Jack', lastName: 'Nicholson')
assert p1.toString() == 'Person(Jack)' // Effect of @ToString(excludes=['lastName'])

def p2 = new Person('Jack') // Effect of @TupleConstructor(excludes=['lastName'])
assert p2.toString() == 'Person(Jack)'

assert p1==p2 // Effect of @EqualsAndHashCode(excludes=['lastName'])
assert p1.hashCode()==p2.hashCode() // Effect of @EqualsAndHashCode(excludes=['lastName'])
```

Any applicable annotation attributes from `@Canonical` are passed along to the explicit annotation but attributes already existing in the explicit annotation take precedence.

```
@groovy.transform.InheritConstructors
```

The `@InheritConstructor` AST transformation aims at generating constructors matching super constructors for you. This is in particular useful when overriding exception classes:

```groovy
import groovy.transform.InheritConstructors

@InheritConstructors
class CustomException extends Exception {}

// all those are generated constructors
new CustomException()
new CustomException("A custom message")
new CustomException("A custom message", new RuntimeException())
new CustomException(new RuntimeException())

// Java 7 only
// new CustomException("A custom message", new RuntimeException(), false, true)
```

The `@InheritConstructor` AST transformation supports the following configuration options:

| Attribute              | Default value | Description                                                  | Example                                                      |
| :--------------------- | :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| constructorAnnotations | False         | Whether to carry over annotations from the constructor during copying | `@Retention(RetentionPolicy.RUNTIME) @Target([ElementType.CONSTRUCTOR]) public @interface ConsAnno {} class Base {  @ConsAnno Base() {} } @InheritConstructors(constructorAnnotations=true) class Child extends Base {} assert Child.constructors[0].annotations[0].annotationType().name == 'groovy.transform.Generated' assert Child.constructors[0].annotations[1].annotationType().name == 'ConsAnno'` |
| parameterAnnotations   | False         | Whether to carry over annotations from the constructor parameters when copying the constructor | `@Retention(RetentionPolicy.RUNTIME) @Target([ElementType.PARAMETER]) public @interface ParamAnno {} class Base {  Base(@ParamAnno String name) {} } @InheritConstructors(parameterAnnotations=true) class Child extends Base {} assert Child.constructors[0].parameterAnnotations[0][0].annotationType().name == 'ParamAnno'` |

```
@groovy.lang.Category
```

The `@Category` AST transformation simplifies the creation of Groovy categories. Historically, a Groovy category was written like this:

```groovy
class TripleCategory {
    public static Integer triple(Integer self) {
        3*self
    }
}
use (TripleCategory) {
    assert 9 == 3.triple()
}
```

The `@Category` transformation lets you write the same using an instance-style class, rather than a static class style. This removes the need for having the first argument of each method being the receiver. The category can be written like this:

```groovy
@Category(Integer)
class TripleCategory {
    public Integer triple() { 3*this }
}
use (TripleCategory) {
    assert 9 == 3.triple()
}
```

Note that the mixed in class can be referenced using `this` instead. It’s also worth noting that using instance fields in a category class is inherently unsafe: categories are not stateful (like traits).

```
@groovy.transform.IndexedProperty
```

The `@IndexedProperty` annotation aims at generating indexed getters/setters for properties of list/array types. This is in particular useful if you want to use a Groovy class from Java. While Groovy supports GPath to access properties, this is not available from Java. The `@IndexedProperty` annotation will generate indexed properties of the following form:

```groovy
class SomeBean {
    @IndexedProperty String[] someArray = new String[2]
    @IndexedProperty List someList = []
}

def bean = new SomeBean()
bean.setSomeArray(0, 'value')
bean.setSomeList(0, 123)

assert bean.someArray[0] == 'value'
assert bean.someList == [123]
@groovy.lang.Lazy
```

The `@Lazy` AST transformation implements lazy initialization of fields. For example, the following code:

```groovy
class SomeBean {
    @Lazy LinkedList myField
}
```

will produce the following code:

```groovy
List $myField
List getMyField() {
    if ($myField!=null) { return $myField }
    else {
        $myField = new LinkedList()
        return $myField
    }
}
```

The default value which is used to initialize the field is the default constructor of the declaration type. It is possible to define a default value by using a closure on the right hand side of the property assignment, as in the following example:

```
class SomeBean {
    @Lazy LinkedList myField = { ['a','b','c']}()
}
```

In that case, the generated code looks like the following:

```
List $myField
List getMyField() {
    if ($myField!=null) { return $myField }
    else {
        $myField = { ['a','b','c']}()
        return $myField
    }
}
```

If the field is declared volatile then initialization will be synchronized using the [double-checked locking](http://en.wikipedia.org/wiki/Double-checked_locking) pattern.

Using the `soft=true` parameter, the helper field will use a `SoftReference` instead, providing a simple way to implement caching. In that case, if the garbage collector decides to collect the reference, initialization will occur the next time the field is accessed.

```
@groovy.lang.Newify
```

The `@Newify` AST transformation is used to bring alternative syntaxes to construct objects:

- Using the `Python` style:

```
@Newify([Tree,Leaf])
class TreeBuilder {
    Tree tree = Tree(Leaf('A'),Leaf('B'),Tree(Leaf('C')))
}
```

- or using the `Ruby` style:

```
@Newify([Tree,Leaf])
class TreeBuilder {
    Tree tree = Tree.new(Leaf.new('A'),Leaf.new('B'),Tree.new(Leaf.new('C')))
}
```

The `Ruby` version can be disabled by setting the `auto` flag to `false`.

```
@groovy.transform.Sortable
```

The `@Sortable` AST transformation is used to help write classes that are `Comparable` and easily sorted typically by numerous properties. It is easy to use as shown in the following example where we annotate the `Person` class:

```groovy
import groovy.transform.Sortable

@Sortable class Person {
    String first
    String last
    Integer born
}
```

The generated class has the following properties:

- it implements the `Comparable` interface
- it contains a `compareTo` method with an implementation based on the natural ordering of the `first`, `last` and `born` properties
- it has three methods returning comparators: `comparatorByFirst`, `comparatorByLast` and `comparatorByBorn`.

The generated `compareTo` method will look like this:

```groovy
public int compareTo(java.lang.Object obj) {
    if (this.is(obj)) {
        return 0
    }
    if (!(obj instanceof Person)) {
        return -1
    }
    java.lang.Integer value = this.first <=> obj.first
    if (value != 0) {
        return value
    }
    value = this.last <=> obj.last
    if (value != 0) {
        return value
    }
    value = this.born <=> obj.born
    if (value != 0) {
        return value
    }
    return 0
}
```

As an example of the generated comparators, the `comparatorByFirst` comparator will have a `compare` method that looks like this:

```groovy
public int compare(java.lang.Object arg0, java.lang.Object arg1) {
    if (arg0 == arg1) {
        return 0
    }
    if (arg0 != null && arg1 == null) {
        return -1
    }
    if (arg0 == null && arg1 != null) {
        return 1
    }
    return arg0.first <=> arg1.first
}
```

The `Person` class can be used wherever a `Comparable` is expected and the generated comparators wherever a `Comparator` is expected as shown by these examples:

```groovy
def people = [
    new Person(first: 'Johnny', last: 'Depp', born: 1963),
    new Person(first: 'Keira', last: 'Knightley', born: 1985),
    new Person(first: 'Geoffrey', last: 'Rush', born: 1951),
    new Person(first: 'Orlando', last: 'Bloom', born: 1977)
]

assert people[0] > people[2]
assert people.sort()*.last == ['Rush', 'Depp', 'Knightley', 'Bloom']
assert people.sort(false, Person.comparatorByFirst())*.first == ['Geoffrey', 'Johnny', 'Keira', 'Orlando']
assert people.sort(false, Person.comparatorByLast())*.last == ['Bloom', 'Depp', 'Knightley', 'Rush']
assert people.sort(false, Person.comparatorByBorn())*.last == ['Rush', 'Depp', 'Bloom', 'Knightley']
```

Normally, all properties are used in the generated `compareTo` method in the priority order in which they are defined. You can include or exclude certain properties from the generated `compareTo` method by giving a list of property names in the `includes` or `excludes` annotation attributes. If using `includes`, the order of the property names given will determine the priority of properties when comparing. To illustrate, consider the following `Person` class definition:

```groovy
@Sortable(includes='first,born') class Person {
    String last
    int born
    String first
}
```

It will have two comparator methods `comparatorByFirst` and `comparatorByBorn` and the generated `compareTo` method will look like this:

```groovy
public int compareTo(java.lang.Object obj) {
    if (this.is(obj)) {
        return 0
    }
    if (!(obj instanceof Person)) {
        return -1
    }
    java.lang.Integer value = this.first <=> obj.first
    if (value != 0) {
        return value
    }
    value = this.born <=> obj.born
    if (value != 0) {
        return value
    }
    return 0
}
```

This `Person` class can be used as follows:

```groovy
def people = [
    new Person(first: 'Ben', last: 'Affleck', born: 1972),
    new Person(first: 'Ben', last: 'Stiller', born: 1965)
]

assert people.sort()*.last == ['Stiller', 'Affleck']
```

The behavior of the `@Sortable` AST transformation can be further changed using the following additional parameters:

| Attribute              | Default value | Description                                                  | Example                                                      |
| :--------------------- | :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| allProperties          | True          | Should JavaBean properties (ordered after native properties) be used | `import groovy.transform.* @Canonical(includeFields = true) @Sortable(allProperties = true, includes = 'nameSize') class Player {  String name  int getNameSize() { name.size() } } def finalists = [  new Player('Serena'),  new Player('Venus'),  new Player('CoCo'),  new Player('Mirjana') ] assert finalists.sort()*.name == ['CoCo', 'Venus', 'Serena', 'Mirjana']` |
| allNames               | False         | Should properties with "internal" names be used              | `import groovy.transform.* @Canonical(allNames = true) @Sortable(allNames = false) class Player {  String $country  String name } def finalists = [  new Player('USA', 'Serena'),  new Player('USA', 'Venus'),  new Player('USA', 'CoCo'),  new Player('Croatian', 'Mirjana') ] assert finalists.sort()*.name == ['Mirjana', 'CoCo', 'Serena', 'Venus']` |
| includeSuperProperties | False         | Should super properties also be used (ordered first)         | `class Person {  String name } @Canonical(includeSuperProperties = true) @Sortable(includeSuperProperties = true) class Citizen extends Person {  String country } def people = [  new Citizen('Bob', 'Italy'),  new Citizen('Cathy', 'Hungary'),  new Citizen('Cathy', 'Egypt'),  new Citizen('Bob', 'Germany'),  new Citizen('Alan', 'France') ] assert people.sort()*.name == ['Alan', 'Bob', 'Bob', 'Cathy', 'Cathy'] assert people.sort()*.country == ['France', 'Germany', 'Italy', 'Egypt', 'Hungary']` |

```
@groovy.transform.builder.Builder
```

The `@Builder` AST transformation is used to help write classes that can be created using *fluent* api calls. The transform supports multiple building strategies to cover a range of cases and there are a number of configuration options to customize the building process. If you’re an AST hacker, you can also define your own strategy class. The following table lists the available strategies that are bundled with Groovy and the configuration options each strategy supports.

| Strategy              | Description                                                  | builderClassName           | builderMethodName                | buildMethodName                                        | prefix             | includes/excludes | includeSuperProperties | allNames             |
| --------------------- | ------------------------------------------------------------ | -------------------------- | -------------------------------- | ------------------------------------------------------ | ------------------ | ----------------- | ---------------------- | -------------------- |
| `SimpleStrategy`      | chained setters                                              | n/a                        | n/a                              | n/a                                                    | yes, default "set" | yes               | n/a                    | yes, default `false` |
| `ExternalStrategy`    | explicit builder class, class being built untouched          | n/a                        | n/a                              | yes, default "build"                                   | yes, default ""    | yes               | yes, default `false`   | yes, default `false` |
| `DefaultStrategy`     | creates a nested helper class                                | yes, default **Builder     | yes, default "builder"           | yes, default "build"                                   | yes, default ""    | yes               | yes, default `false`   | yes, default `false` |
| `InitializerStrategy` | creates a nested helper class providing type-safe fluent creation | yes, default **Initializer | yes, default "createInitializer" | yes, default "create" but usually only used internally | yes, default ""    | yes               | yes, default `false`   | yes, default `false` |

SimpleStrategy

To use the `SimpleStrategy`, annotate your Groovy class using the `@Builder` annotation, and specify the strategy as shown in this example:

```groovy
import groovy.transform.builder.*

@Builder(builderStrategy=SimpleStrategy)
class Person {
    String first
    String last
    Integer born
}
```

Then, just call the setters in a chained fashion as shown here:

```groovy
def p1 = new Person().setFirst('Johnny').setLast('Depp').setBorn(1963)
assert "$p1.first $p1.last" == 'Johnny Depp'
```

For each property, a generated setter will be created which looks like this:

```groovy
public Person setFirst(java.lang.String first) {
    this.first = first
    return this
}
```

You can specify a prefix as shown in this example:

```groovy
import groovy.transform.builder.*

@Builder(builderStrategy=SimpleStrategy, prefix="")
class Person {
    String first
    String last
    Integer born
}
```

And calling the chained setters would look like this:

```groovy
def p = new Person().first('Johnny').last('Depp').born(1963)
assert "$p.first $p.last" == 'Johnny Depp'
```

You can use the `SimpleStrategy` in conjunction with `@TupleConstructor`. If your `@Builder` annotation doesn’t have explicit `includes` or `excludes` annotation attributes but your `@TupleConstructor` annotation does, the ones from `@TupleConstructor` will be re-used for `@Builder`. The same applies for any annotation aliases which combine `@TupleConstructor` such as `@Canonical`.

The annotation attribute `useSetters` can be used if you have a setter which you want called as part of the construction process. See the JavaDoc for details.

The annotation attributes `builderClassName`, `buildMethodName`, `builderMethodName`, `forClass` and `includeSuperProperties` are not supported for this strategy.

|      | Groovy already has built-in building mechanisms. Don’t rush to using `@Builder` if the built-in mechanisms meet your needs. Some examples: |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```groovy
def p2 = new Person(first: 'Keira', last: 'Knightley', born: 1985)
def p3 = new Person().with {
    first = 'Geoffrey'
    last = 'Rush'
    born = 1951
}
```

ExternalStrategy

To use the `ExternalStrategy`, create and annotate a Groovy builder class using the `@Builder` annotation, specify the class the builder is for using `forClass` and indicate use of the `ExternalStrategy`. Suppose you have the following class you would like a builder for:

```groovy
class Person {
    String first
    String last
    int born
}
```

you explicitly create and use your builder class as follows:

```groovy
import groovy.transform.builder.*

@Builder(builderStrategy=ExternalStrategy, forClass=Person)
class PersonBuilder { }

def p = new PersonBuilder().first('Johnny').last('Depp').born(1963).build()
assert "$p.first $p.last" == 'Johnny Depp'
```

Note that the (normally empty) builder class you provide will be filled in with appropriate setters and a build method. The generated build method will look something like:

```groovy
public Person build() {
    Person _thePerson = new Person()
    _thePerson.first = first
    _thePerson.last = last
    _thePerson.born = born
    return _thePerson
}
```

The class you are creating the builder for can be any Java or Groovy class following the normal JavaBean conventions, e.g. a no-arg constructor and setters for the properties. Here is an example using a Java class:

```groovy
import groovy.transform.builder.*

@Builder(builderStrategy=ExternalStrategy, forClass=javax.swing.DefaultButtonModel)
class ButtonModelBuilder {}

def model = new ButtonModelBuilder().enabled(true).pressed(true).armed(true).rollover(true).selected(true).build()
assert model.isArmed()
assert model.isPressed()
assert model.isEnabled()
assert model.isSelected()
assert model.isRollover()
```

The generated builder can be customised using the `prefix`, `includes`, `excludes` and `buildMethodName` annotation attributes. Here is an example illustrating various customisations:

```groovy
import groovy.transform.builder.*
import groovy.transform.Canonical

@Canonical
class Person {
    String first
    String last
    int born
}

@Builder(builderStrategy=ExternalStrategy, forClass=Person, includes=['first', 'last'], buildMethodName='create', prefix='with')
class PersonBuilder { }

def p = new PersonBuilder().withFirst('Johnny').withLast('Depp').create()
assert "$p.first $p.last" == 'Johnny Depp'
```

The `builderMethodName` and `builderClassName` annotation attributes for `@Builder` aren’t applicable for this strategy.

You can use the `ExternalStrategy` in conjunction with `@TupleConstructor`. If your `@Builder` annotation doesn’t have explicit `includes` or `excludes` annotation attributes but the `@TupleConstructor` annotation of the class you are creating the builder for does, the ones from `@TupleConstructor` will be re-used for `@Builder`. The same applies for any annotation aliases which combine `@TupleConstructor` such as `@Canonical`.

DefaultStrategy

To use the `DefaultStrategy`, annotate your Groovy class using the `@Builder` annotation as shown in this example:

```groovy
import groovy.transform.builder.Builder

@Builder
class Person {
    String firstName
    String lastName
    int age
}

def person = Person.builder().firstName("Robert").lastName("Lewandowski").age(21).build()
assert person.firstName == "Robert"
assert person.lastName == "Lewandowski"
assert person.age == 21
```

If you want, you can customize various aspects of the building process using the `builderClassName`, `buildMethodName`, `builderMethodName`, `prefix`, `includes` and `excludes` annotation attributes, some of which are used in the example here:

```groovy
import groovy.transform.builder.Builder

@Builder(buildMethodName='make', builderMethodName='maker', prefix='with', excludes='age')
class Person {
    String firstName
    String lastName
    int age
}

def p = Person.maker().withFirstName("Robert").withLastName("Lewandowski").make()
assert "$p.firstName $p.lastName" == "Robert Lewandowski"
```

This strategy also supports annotating static methods and constructors. In this case, the static method or constructor parameters become the properties to use for building purposes and in the case of static methods, the return type of the method becomes the target class being built. If you have more than one `@Builder` annotation used within a class (at either the class, method or constructor positions) then it is up to you to ensure that the generated helper classes and factory methods have unique names (i.e. no more than one can use the default name values). Here is an example highlighting method and constructor usage (and also illustrating the renaming required for unique names).

```groovy
import groovy.transform.builder.*
import groovy.transform.*

@ToString
@Builder
class Person {
  String first, last
  int born

  Person(){}

  @Builder(builderClassName='MovieBuilder', builderMethodName='byRoleBuilder')
  Person(String roleName) {
     if (roleName == 'Jack Sparrow') {
         this.first = 'Johnny'; this.last = 'Depp'; this.born = 1963
     }
  }

  @Builder(builderClassName='NameBuilder', builderMethodName='nameBuilder', prefix='having', buildMethodName='fullName')
  static String join(String first, String last) {
      first + ' ' + last
  }

  @Builder(builderClassName='SplitBuilder', builderMethodName='splitBuilder')
  static Person split(String name, int year) {
      def parts = name.split(' ')
      new Person(first: parts[0], last: parts[1], born: year)
  }
}

assert Person.splitBuilder().name("Johnny Depp").year(1963).build().toString() == 'Person(Johnny, Depp, 1963)'
assert Person.byRoleBuilder().roleName("Jack Sparrow").build().toString() == 'Person(Johnny, Depp, 1963)'
assert Person.nameBuilder().havingFirst('Johnny').havingLast('Depp').fullName() == 'Johnny Depp'
assert Person.builder().first("Johnny").last('Depp').born(1963).build().toString() == 'Person(Johnny, Depp, 1963)'
```

The `forClass` annotation attribute is not supported for this strategy.

InitializerStrategy

To use the `InitializerStrategy`, annotate your Groovy class using the `@Builder` annotation, and specify the strategy as shown in this example:

```groovy
import groovy.transform.builder.*
import groovy.transform.*

@ToString
@Builder(builderStrategy=InitializerStrategy)
class Person {
    String firstName
    String lastName
    int age
}
```

Your class will be locked down to have a single public constructor taking a "fully set" initializer. It will also have a factory method to create the initializer. These are used as follows:

```groovy
@CompileStatic
def firstLastAge() {
    assert new Person(Person.createInitializer().firstName("John").lastName("Smith").age(21)).toString() == 'Person(John, Smith, 21)'
}
firstLastAge()
```

Any attempt to use the initializer which doesn’t involve setting all the properties (though order is not important) will result in a compilation error. If you don’t need this level of strictness, you don’t need to use `@CompileStatic`.

You can use the `InitializerStrategy` in conjunction with `@Canonical` and `@Immutable`. If your `@Builder` annotation doesn’t have explicit `includes` or `excludes` annotation attributes but your `@Canonical` annotation does, the ones from `@Canonical` will be re-used for `@Builder`. Here is an example using `@Builder` with `@Immutable`:

```groovy
import groovy.transform.builder.*
import groovy.transform.*
import static groovy.transform.options.Visibility.PRIVATE

@Builder(builderStrategy=InitializerStrategy)
@Immutable
@VisibilityOptions(PRIVATE)
class Person {
    String first
    String last
    int born
}

def publicCons = Person.constructors
assert publicCons.size() == 1

@CompileStatic
def createFirstLastBorn() {
  def p = new Person(Person.createInitializer().first('Johnny').last('Depp').born(1963))
  assert "$p.first $p.last $p.born" == 'Johnny Depp 1963'
}

createFirstLastBorn()
```

The annotation attribute `useSetters` can be used if you have a setter which you want called as part of the construction process. See the JavaDoc for details.

This strategy also supports annotating static methods and constructors. In this case, the static method or constructor parameters become the properties to use for building purposes and in the case of static methods, the return type of the method becomes the target class being built. If you have more than one `@Builder` annotation used within a class (at either the class, method or constructor positions) then it is up to you to ensure that the generated helper classes and factory methods have unique names (i.e. no more than one can use the default name values). For an example of method and constructor usage but using the `DefaultStrategy` strategy, consult that strategy’s documentation.

The annotation attribute `forClass` is not supported for this strategy.

```
@groovy.transform.AutoImplement
```

The `@AutoImplement` AST transformation supplies dummy implementations for any found abstract methods from superclasses or interfaces. The dummy implementation is the same for all abstract methods found and can be:

- essentially empty (exactly true for void methods and for methods with a return type, returns the default value for that type)
- a statement that throws a specified exception (with optional message)
- some user supplied code

The first example illustrates the default case. Our class is annotated with `@AutoImplement`, has a superclass and a single interface as can be seen here:

```groovy
import groovy.transform.AutoImplement

@AutoImplement
class MyNames extends AbstractList<String> implements Closeable { }
```

A `void close()` method from the `Closeable` interface is supplied and left empty. Implementations are also supplied for the three abstract methods from the super class. The `get`, `addAll` and `size` methods have return types of `String`, `boolean` and `int` respectively with default values `null`, `false` and `0`. We can use our class (and check the expected return type for one of the methods) using the following code:

```groovy
assert new MyNames().size() == 0
```

It is also worthwhile examining the equivalent generated code:

```groovy
class MyNames implements Closeable extends AbstractList<String> {

    String get(int param0) {
        return null
    }

    boolean addAll(Collection<? extends String> param0) {
        return false
    }

    void close() throws Exception {
    }

    int size() {
        return 0
    }

}
```

The second example illustrates the simplest exception case. Our class is annotated with `@AutoImplement`, has a superclass and an annotation attribute indicates that an `IOException` should be thrown if any of our "dummy" methods are called. Here is the class definition:

```groovy
@AutoImplement(exception=IOException)
class MyWriter extends Writer { }
```

We can use the class (and check the expected exception is thrown for one of the methods) using the following code:

```groovy
import static groovy.test.GroovyAssert.shouldFail

shouldFail(IOException) {
  new MyWriter().flush()
}
```

It is also worthwhile examining the equivalent generated code where three void methods have been provided all of which throw the supplied exception:

```groovy
class MyWriter extends Writer {

    void flush() throws IOException {
        throw new IOException()
    }

    void write(char[] param0, int param1, int param2) throws IOException {
        throw new IOException()
    }

    void close() throws Exception {
        throw new IOException()
    }

}
```

The third example illustrates the exception case with a supplied message. Our class is annotated with `@AutoImplement`, implements an interface, and has annotation attributes to indicate that an `UnsupportedOperationException` with `Not supported by MyIterator` as the message should be thrown for any supplied methods. Here is the class definition:

```groovy
@AutoImplement(exception=UnsupportedOperationException, message='Not supported by MyIterator')
class MyIterator implements Iterator<String> { }
```

We can use the class (and check the expected exception is thrown and has the correct message for one of the methods) using the following code:

```groovy
def ex = shouldFail(UnsupportedOperationException) {
     new MyIterator().hasNext()
}
assert ex.message == 'Not supported by MyIterator'
```

It is also worthwhile examining the equivalent generated code where three void methods have been provided all of which throw the supplied exception:

```groovy
class MyIterator implements Iterator<String> {

    boolean hasNext() {
        throw new UnsupportedOperationException('Not supported by MyIterator')
    }

    String next() {
        throw new UnsupportedOperationException('Not supported by MyIterator')
    }

}
```

The fourth example illustrates the case of user supplied code. Our class is annotated with `@AutoImplement`, implements an interface, has an explcitly overriden `hasNext` method, and has an annotation attribute containing the supplied code for any supplied methods. Here is the class definition:

```groovy
@AutoImplement(code = { throw new UnsupportedOperationException('Should never be called but was called on ' + new Date()) })
class EmptyIterator implements Iterator<String> {
    boolean hasNext() { false }
}
```

We can use the class (and check the expected exception is thrown and has a message of the expected form) using the following code:

```groovy
def ex = shouldFail(UnsupportedOperationException) {
     new EmptyIterator().next()
}
assert ex.message.startsWith('Should never be called but was called on ')
```

It is also worthwhile examining the equivalent generated code where the `next` method has been supplied:

```groovy
class EmptyIterator implements java.util.Iterator<String> {

    boolean hasNext() {
        false
    }

    String next() {
        throw new UnsupportedOperationException('Should never be called but was called on ' + new Date())
    }

}
@groovy.transform.NullCheck
```

The `@NullCheck` AST transformation adds null-check guard statements to constructors and methods which cause those methods to fail early when supplied with null arguments. It can be seen as a form of defensive programming. The annotation can be added to individual methods or constructors, or to the class in which case it will apply to all methods/constructors.

```groovy
@NullCheck
String longerOf(String first, String second) {
    first.size() >= second.size() ? first : second
}

assert longerOf('cat', 'canary') == 'canary'
def ex = shouldFail(IllegalArgumentException) {
    longerOf('cat', null)
}
assert ex.message == 'second cannot be null'
```

###### Class design annotations

This category of annotations are aimed at simplifying the implementation of well-known design patterns (delegation, singleton, …) by using a declarative style.

```
@groovy.transform.BaseScript
```

`@BaseScript` is used within scripts to indicate that the script should extend fron a custom script base class rather than `groovy.lang.Script`. See the documentation for [domain specific languages](https://docs.groovy-lang.org/latest/html/documentation/#dsl-basescript) for further details.

```
@groovy.lang.Delegate
```

The `@Delegate` AST transformation aims at implementing the delegation design pattern. In the following class:

```groovy
class Event {
    @Delegate Date when
    String title
}
```

The `when` property is annotated with `@Delegate`, meaning that the `Event` class will delegate calls to `Date` methods to the `when` property. In this case, the generated code looks like this:

```groovy
class Event {
    Date when
    String title
    boolean before(Date other) {
        when.before(other)
    }
    // ...
}
```

Then you can call the `before` method, for example, directly on the `Event` class:

```groovy
def ev = new Event(title:'Groovy keynote', when: Date.parse('yyyy/MM/dd', '2013/09/10'))
def now = new Date()
assert ev.before(now)
```

Instead of annotating a property (or field), you can also annotate a method. In this case, the method can be thought of as a getter or factory method for the delegate. As an example, here is a class which (rather unusually) has a pool of delegates which are accessed in a round-robin fashion:

```groovy
class Test {
    private int robinCount = 0
    private List<List> items = [[0], [1], [2]]

    @Delegate
    List getRoundRobinList() {
        items[robinCount++ % items.size()]
    }

    void checkItems(List<List> testValue) {
        assert items == testValue
    }
}
```

Here is an example usage of that class:

```groovy
def t = new Test()
t << 'fee'
t << 'fi'
t << 'fo'
t << 'fum'
t.checkItems([[0, 'fee', 'fum'], [1, 'fi'], [2, 'fo']])
```

Using a standard list in this round-robin fashion would violate many expected properties of lists, so don’t expect the above class to do anything useful beyond this trivial example.

The behavior of the `@Delegate` AST transformation can be changed using the following parameters:

| Attribute            | Default value                                         | Description                                                  | Example                                                      |
| :------------------- | :---------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| interfaces           | True                                                  | Should the interfaces implemented by the field be implemented by the class too | `interface Greeter { void sayHello() } class MyGreeter implements Greeter { void sayHello() { println 'Hello!'} } class DelegatingGreeter { // no explicit interface    @Delegate MyGreeter greeter = new MyGreeter() } def greeter = new DelegatingGreeter() assert greeter instanceof Greeter // interface was added transparently` |
| deprecated           | false                                                 | If true, also delegates methods annotated with @Deprecated   | `class WithDeprecation {    @Deprecated    void foo() {} } class WithoutDeprecation {    @Deprecated    void bar() {} } class Delegating {    @Delegate(deprecated=true) WithDeprecation with = new WithDeprecation()    @Delegate WithoutDeprecation without = new WithoutDeprecation() } def d = new Delegating() d.foo() // passes thanks to deprecated=true d.bar() // fails because of @Deprecated` |
| methodAnnotations    | False                                                 | Whether to carry over annotations from the methods of the delegate to your delegating method. | `class WithAnnotations {    @Transactional    void method() {    } } class DelegatingWithoutAnnotations {    @Delegate WithAnnotations delegate } class DelegatingWithAnnotations {    @Delegate(methodAnnotations = true) WithAnnotations delegate } def d1 = new DelegatingWithoutAnnotations() def d2 = new DelegatingWithAnnotations() assert d1.class.getDeclaredMethod('method').annotations.length==1 assert d2.class.getDeclaredMethod('method').annotations.length==2` |
| parameterAnnotations | False                                                 | Whether to carry over annotations from the method parameters of the delegate to your delegating method. | `class WithAnnotations {    void method(@NotNull String str) {    } } class DelegatingWithoutAnnotations {    @Delegate WithAnnotations delegate } class DelegatingWithAnnotations {    @Delegate(parameterAnnotations = true) WithAnnotations delegate } def d1 = new DelegatingWithoutAnnotations() def d2 = new DelegatingWithAnnotations() assert d1.class.getDeclaredMethod('method',String).parameterAnnotations[0].length==0 assert d2.class.getDeclaredMethod('method',String).parameterAnnotations[0].length==1` |
| excludes             | Empty array                                           | A list of methods to be excluded from delegation. For more fine-grained control, see also `excludeTypes`. | `class Worker {    void task1() {}    void task2() {} } class Delegating {    @Delegate(excludes=['task2']) Worker worker = new Worker() } def d = new Delegating() d.task1() // passes d.task2() // fails because method is excluded` |
| includes             | Undefined marker array (indicates all methods)        | A list of methods to be included in delegation. For more fine-grained control, see also `includeTypes`. | `class Worker {    void task1() {}    void task2() {} } class Delegating {    @Delegate(includes=['task1']) Worker worker = new Worker() } def d = new Delegating() d.task1() // passes d.task2() // fails because method is not included` |
| excludeTypes         | Empty array                                           | A list of interfaces containing method signatures to be excluded from delegation | `interface AppendStringSelector {    StringBuilder append(String str) } class UpperStringBuilder {    @Delegate(excludeTypes=AppendStringSelector)    StringBuilder sb1 = new StringBuilder()     @Delegate(includeTypes=AppendStringSelector)    StringBuilder sb2 = new StringBuilder()     String toString() { sb1.toString() + sb2.toString().toUpperCase() } } def usb = new UpperStringBuilder() usb.append(3.5d) usb.append('hello') usb.append(true) assert usb.toString() == '3.5trueHELLO'` |
| includeTypes         | Undefined marker array (indicates no list be default) | A list of interfaces containing method signatures to be included in delegation | `interface AppendBooleanSelector {    StringBuilder append(boolean b) } interface AppendFloatSelector {    StringBuilder append(float b) } class NumberBooleanBuilder {    @Delegate(includeTypes=AppendBooleanSelector, interfaces=false)    StringBuilder nums = new StringBuilder()    @Delegate(includeTypes=[AppendFloatSelector], interfaces=false)    StringBuilder bools = new StringBuilder()    String result() { "${nums.toString()} ~ ${bools.toString()}" } } def b = new NumberBooleanBuilder() b.append(true) b.append(3.14f) b.append(false) b.append(0.0f) assert b.result() == "truefalse ~ 3.140.0" b.append(3.5d) // would fail because we didn't include append(double)` |
| allNames             | False                                                 | Should the delegate pattern be also applied to methods with internal names | `class Worker {    void task$() {} } class Delegating {    @Delegate(allNames=true) Worker worker = new Worker() } def d = new Delegating() d.task$() //passes` |

```
@groovy.transform.Immutable
```

The `@Immutable` meta-annotation combines the following annotations:

- [@ToString](https://docs.groovy-lang.org/latest/html/documentation/#xform-ToString)
- [@EqualsAndHashCode](https://docs.groovy-lang.org/latest/html/documentation/#xform-EqualsAndHashCode)
- [@TupleConstructor](https://docs.groovy-lang.org/latest/html/documentation/#xform-TupleConstructor)
- [@MapConstructor](https://docs.groovy-lang.org/latest/html/documentation/#xform-MapConstructor)
- [@ImmutableBase](https://docs.groovy-lang.org/latest/html/documentation/#xform-ImmutableBase)
- [@ImmutableOptions](https://docs.groovy-lang.org/latest/html/documentation/#xform-ImmutableOptions)
- [@PropertyOptions](https://docs.groovy-lang.org/latest/html/documentation/#xform-PropertyOptions)
- [@KnownImmutable](https://docs.groovy-lang.org/latest/html/documentation/#xform-KnownImmutable)

The `@Immutable` meta-annotation simplifies the creation of immutable classes. Immutable classes are useful since they are often easier to reason about and are inherently thread-safe. See [Effective Java, Minimize Mutability](http://www.informit.com/store/effective-java-9780134685991) for all the details about how to achieve immutable classes in Java. The `@Immutable` meta-annotation does most of the things described in *Effective Java* for you automatically. To use the meta-annotation, all you have to do is annotate the class like in the following example:

```groovy
import groovy.transform.Immutable

@Immutable
class Point {
    int x
    int y
}
```

One of the requirements for immutable classes is that there is no way to modify any state information within the class. One requirement to achieve this is to use immutable classes for each property or alternatively perform special coding such as defensive copy in and defensive copy out for any mutable properties within the constructors and property getters. Between `@ImmutableBase`, `@MapConstructor` and `@TupleConstructor` properties are either identified as immutable or the special coding for numerous known cases is handled automatically. Various mechanisms are provided for you to extend the handled property types which are allowed. See `@ImmutableOptions` and `@KnownImmutable` for details.

The results of applying `@Immutable` to a class are pretty similar to those of applying the [@Canonical](https://docs.groovy-lang.org/latest/html/documentation/#xform-Canonical) meta-annotation but the generated class will have extra logic to handle immutability. You will observe this by, for instance, trying to modify a property which will result in a `ReadOnlyPropertyException` being thrown since the backing field for the property will have been automatically made final.

The `@Immutable` meta-annotation supports the configuration options found in the annotations it aggregates. See those annotations for more details.

```
@groovy.transform.ImmutableBase
```

Immutable classes generated with `@ImmutableBase` are automatically made final. Also, the type of each property is checked and various checks are made on the class, for example, public instance fields currently aren’t allowed. It also generates a `copyWith` constructor if desired.

The following annotation attribute is supported:

| Attribute | Default value | Description                                               | Example                                                      |
| :-------- | :------------ | :-------------------------------------------------------- | :----------------------------------------------------------- |
| copyWith  | false         | A boolean whether to generate a `copyWith( Map )` method. | `import groovy.transform.Immutable @Immutable( copyWith=true ) class User {    String  name    Integer age } def bob   = new User( 'bob', 43 ) def alice = bob.copyWith( name:'alice' ) assert alice.name == 'alice' assert alice.age  == 43` |

```
@groovy.transform.PropertyOptions
```

This annotation allows you to specify a custom property handler to be used by transformations during class construction. It is ignored by the main Groovy compiler but is referenced by other transformations like `@TupleConstructor`, `@MapConstructor`, and `@ImmutableBase`. It is frequently used behind the scenes by the `@Immutable` meta-annotation.

```
@groovy.transform.VisibilityOptions
```

This annotation allows you to specify a custom visibility for a construct generated by another transformation. It is ignored by the main Groovy compiler but is referenced by other transformations like `@TupleConstructor`, `@MapConstructor`, and `@NamedVariant`.

```
@groovy.transform.ImmutableOptions
```

Groovy’s immutability support relies on a predefined list of known immutable classes (like `java.net.URI` or `java.lang.String` and fails if you use a type which is not in that list, you are allowed to add to the list of known immutable types thanks to the following annotation attributes of the `@ImmutableOptions` annotation:

| Attribute             | Default value | Description                                          | Example                                                      |
| :-------------------- | :------------ | :--------------------------------------------------- | :----------------------------------------------------------- |
| knownImmutableClasses | Empty list    | A list of classes which are deemed immutable.        | `import groovy.transform.Immutable import groovy.transform.TupleConstructor @TupleConstructor final class Point {    final int x    final int y    public String toString() { "($x,$y)" } } @Immutable(knownImmutableClasses=[Point]) class Triangle {    Point a,b,c }` |
| knownImmutables       | Empty list    | A list of property names which are deemed immutable. | `import groovy.transform.Immutable import groovy.transform.TupleConstructor @TupleConstructor final class Point {    final int x    final int y    public String toString() { "($x,$y)" } } @Immutable(knownImmutables=['a','b','c']) class Triangle {    Point a,b,c }` |

If you deem a type as immutable and it isn’t one of the ones automatically handled, then it is up to you to correctly code that class to ensure immutability.

```
@groovy.transform.KnownImmutable
```

The `@KnownImmutable` annotation isn’t actually one that triggers any AST transformations. It is simply a marker annotation. You can annotate your classes with the annotation (including Java classes) and they will be recognized as acceptable types for members within an immutable class. This saves you having to explicitly use the `knownImmutables` or `knownImmutableClasses` annotation attributes from `@ImmutableOptions`.

```
@groovy.transform.Memoized
```

The `@Memoized` AST transformations simplifies the implementation of caching by allowing the result of method calls to be cached just by annotating the method with `@Memoized`. Let’s imagine the following method:

```groovy
long longComputation(int seed) {
    // slow computation
    Thread.sleep(100*seed)
    System.nanoTime()
}
```

This emulates a long computation, based on the actual parameters of the method. Without `@Memoized`, each method call would take several seconds plus it would return a random result:

```groovy
def x = longComputation(1)
def y = longComputation(1)
assert x!=y
```

Adding `@Memoized` changes the semantics of the method by adding caching, based on the parameters:

```groovy
@Memoized
long longComputation(int seed) {
    // slow computation
    Thread.sleep(100*seed)
    System.nanoTime()
}

def x = longComputation(1) // returns after 100 milliseconds
def y = longComputation(1) // returns immediatly
def z = longComputation(2) // returns after 200 milliseconds
assert x==y
assert x!=z
```

The size of the cache can be configured using two optional parameters:

- *protectedCacheSize*: the number of results which are guaranteed not to be cleared after garbage collection
- *maxCacheSize*: the maximum number of results that can be kept in memory

By default, the size of the cache is unlimited and no cache result is protected from garbage collection. Setting a *protectedCacheSize>0* would create an unlimited cache with some results protected. Setting *maxCacheSize>0* would create a limited cache but without any protection from garbage protection. Setting both would create a limited, protected cache.

```
@groovy.transform.TailRecursive
```

The `@TailRecursive` annotation can be used to automatically transform a recursive call at the end of a method into an equivalent iterative version of the same code. This avoids stack overflow due to too many recursive calls. Below is an example of use when calculating factorial:

```groovy
import groovy.transform.CompileStatic
import groovy.transform.TailRecursive

@CompileStatic
class Factorial {

    @TailRecursive
    static BigInteger factorial( BigInteger i, BigInteger product = 1) {
        if( i == 1) {
            return product
        }
        return factorial(i-1, product*i)
    }
}

assert Factorial.factorial(1) == 1
assert Factorial.factorial(3) == 6
assert Factorial.factorial(5) == 120
assert Factorial.factorial(50000).toString().size() == 213237 // Big number and no Stack Overflow
```

Currently, the annotation will only work for self-recursive method calls, i.e. a single recursive call to the exact same method again. Consider using Closures and `trampoline()` if you have a scenario involving simple mutual recursion. Also note that only non-void methods are currently handled (void calls will result in a compilation error).

|      | Currently, some forms of method overloading can trick the compiler, and some non-tail recursive calls are erroneously treated as tail recursive. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```
@groovy.lang.Singleton
```

The `@Singleton` annotation can be used to implement the singleton design pattern on a class. The singleton instance is defined eagerly by default, using class initialization, or lazily, in which case the field is initialized using double checked locking.

```groovy
@Singleton
class GreetingService {
    String greeting(String name) { "Hello, $name!" }
}
assert GreetingService.instance.greeting('Bob') == 'Hello, Bob!'
```

By default, the singleton is created eagerly when the class is initialized and available through the `instance` property. It is possible to change the name of the singleton using the `property` parameter:

```groovy
@Singleton(property='theOne')
class GreetingService {
    String greeting(String name) { "Hello, $name!" }
}

assert GreetingService.theOne.greeting('Bob') == 'Hello, Bob!'
```

And it is also possible to make initialization lazy using the `lazy` parameter:

```groovy
class Collaborator {
    public static boolean init = false
}
@Singleton(lazy=true,strict=false)
class GreetingService {
    static void init() {}
    GreetingService() {
        Collaborator.init = true
    }
    String greeting(String name) { "Hello, $name!" }
}
GreetingService.init() // make sure class is initialized
assert Collaborator.init == false
GreetingService.instance
assert Collaborator.init == true
assert GreetingService.instance.greeting('Bob') == 'Hello, Bob!'
```

In this example, we also set the `strict` parameter to false, which allows us to define our own constructor.

```
@groovy.lang.Mixin
```

Deprecated. Consider using traits instead.

###### Logging improvements

Groovy provides AST transformation that helps integrating with the most widely used logging frameworks. It’s worth noting that annotating a class with one of those annotations doesn’t prevent you from adding the appropriate logging framework on classpath.

All transformations work in a similar way:

- add static final `log` field corresponding to the logger
- wrap all calls to `log.level()` into the appropriate `log.isLevelEnabled` guard, depending on the underlying framework

Those transformations support two parameters:

- `value` (default `log`) corresponds to the name of the logger field
- `category` (defaults to the class name) is the name of the logger category

```
@groovy.util.logging.Log
```

The first logging AST transformation available is the `@Log` annotation which relies on the JDK logging framework. Writing:

```groovy
@groovy.util.logging.Log
class Greeter {
    void greet() {
        log.info 'Called greeter'
        println 'Hello, world!'
    }
}
```

is equivalent to writing:

```groovy
import java.util.logging.Level
import java.util.logging.Logger

class Greeter {
    private static final Logger log = Logger.getLogger(Greeter.name)
    void greet() {
        if (log.isLoggable(Level.INFO)) {
            log.info 'Called greeter'
        }
        println 'Hello, world!'
    }
}
@groovy.util.logging.Commons
```

Groovy supports the [Apache Commons Logging](http://commons.apache.org/proper/commons-logging/) framework using to the `@Commons` annotation. Writing:

```groovy
@groovy.util.logging.Commons
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}
```

is equivalent to writing:

```groovy
import org.apache.commons.logging.LogFactory
import org.apache.commons.logging.Log

class Greeter {
    private static final Log log = LogFactory.getLog(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}
@groovy.util.logging.Log4j
```

Groovy supports the [Apache Log4j 1.x](http://logging.apache.org/log4j/1.2/) framework using to the `@Log4j` annotation. Writing:

```groovy
@groovy.util.logging.Log4j
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}
```

is equivalent to writing:

```groovy
import org.apache.log4j.Logger

class Greeter {
    private static final Logger log = Logger.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}
@groovy.util.logging.Log4j2
```

Groovy supports the [Apache Log4j 2.x](http://logging.apache.org/log4j/2.x/) framework using to the `@Log4j2` annotation. Writing:

```groovy
@groovy.util.logging.Log4j2
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}
```

is equivalent to writing:

```groovy
import org.apache.logging.log4j.LogManager
import org.apache.logging.log4j.Logger

class Greeter {
    private static final Logger log = LogManager.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}
@groovy.util.logging.Slf4j
```

Groovy supports the [Simple Logging Facade for Java (SLF4J)](http://www.slf4j.org/) framework using to the `@Slf4j` annotation. Writing:

```groovy
@groovy.util.logging.Slf4j
class Greeter {
    void greet() {
        log.debug 'Called greeter'
        println 'Hello, world!'
    }
}
```

is equivalent to writing:

```groovy
import org.slf4j.LoggerFactory
import org.slf4j.Logger

class Greeter {
    private static final Logger log = LoggerFactory.getLogger(Greeter)
    void greet() {
        if (log.isDebugEnabled()) {
            log.debug 'Called greeter'
        }
        println 'Hello, world!'
    }
}
```

###### Declarative concurrency

The Groovy language provides a set of annotations aimed at simplifying common concurrency patterns in a declarative approach.

```
@groovy.transform.Synchronized
```

The `@Synchronized` AST transformations works in a similar way to the `synchronized` keyword but locks on different objects for safer concurrency. It can be applied on any method or static method:

```groovy
import groovy.transform.Synchronized

import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

class Counter {
    int cpt
    @Synchronized
    int incrementAndGet() {
        cpt++
    }
    int get() {
        cpt
    }
}
```

Writing this is equivalent to creating a lock object and wrapping the whole method into a synchronized block:

```groovy
class Counter {
    int cpt
    private final Object $lock = new Object()

    int incrementAndGet() {
        synchronized($lock) {
            cpt++
        }
    }
    int get() {
        cpt
    }

}
```

By default, `@Synchronized` creates a field named `$lock` (or `$LOCK` for a static method) but you can make it use any field you want by specifying the value attribute, like in the following example:

```groovy
import groovy.transform.Synchronized

import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

class Counter {
    int cpt
    private final Object myLock = new Object()

    @Synchronized('myLock')
    int incrementAndGet() {
        cpt++
    }
    int get() {
        cpt
    }
}
@groovy.transform.WithReadLock` and `@groovy.transform.WithWriteLock
```

The `@WithReadLock` AST transformation works in conjunction with the `@WithWriteLock` transformation to provide read/write synchronization using the `ReentrantReadWriteLock` facility that the JDK provides. The annotation can be added to a method or a static method. It will transparently create a `$reentrantLock` final field (or `$REENTRANTLOCK` for a static method) and proper synchronization code will be added. For example, the following code:

```groovy
import groovy.transform.WithReadLock
import groovy.transform.WithWriteLock

class Counters {
    public final Map<String,Integer> map = [:].withDefault { 0 }

    @WithReadLock
    int get(String id) {
        map.get(id)
    }

    @WithWriteLock
    void add(String id, int num) {
        Thread.sleep(200) // emulate long computation
        map.put(id, map.get(id)+num)
    }
}
```

is equivalent to this:

```groovy
import groovy.transform.WithReadLock as WithReadLock
import groovy.transform.WithWriteLock as WithWriteLock

public class Counters {

    private final Map<String, Integer> map
    private final java.util.concurrent.locks.ReentrantReadWriteLock $reentrantlock

    public int get(java.lang.String id) {
        $reentrantlock.readLock().lock()
        try {
            map.get(id)
        }
        finally {
            $reentrantlock.readLock().unlock()
        }
    }

    public void add(java.lang.String id, int num) {
        $reentrantlock.writeLock().lock()
        try {
            java.lang.Thread.sleep(200)
            map.put(id, map.get(id) + num )
        }
        finally {
            $reentrantlock.writeLock().unlock()
        }
    }
}
```

Both `@WithReadLock` and `@WithWriteLock` support specifying an alternative lock object. In that case, the referenced field must be declared by the user, like in the following alternative:

```groovy
import groovy.transform.WithReadLock
import groovy.transform.WithWriteLock

import java.util.concurrent.locks.ReentrantReadWriteLock

class Counters {
    public final Map<String,Integer> map = [:].withDefault { 0 }
    private final ReentrantReadWriteLock customLock = new ReentrantReadWriteLock()

    @WithReadLock('customLock')
    int get(String id) {
        map.get(id)
    }

    @WithWriteLock('customLock')
    void add(String id, int num) {
        Thread.sleep(200) // emulate long computation
        map.put(id, map.get(id)+num)
    }
}
```

For details

- See Javadoc for [groovy.transform.WithReadLock](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/WithReadLock.html)
- See Javadoc for [groovy.transform.WithWriteLock](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/WithWriteLock.html)

###### Easier cloning and externalizing

Groovy provides two annotations aimed at facilitating the implementation of `Cloneable` and `Externalizable` interfaces, respectively named `@AutoClone` and `@AutoExternalize`.

```
@groovy.transform.AutoClone
```

The `@AutoClone` annotation is aimed at implementing the `@java.lang.Cloneable` interface using various strategies, thanks to the `style` parameter:

- the default `AutoCloneStyle.CLONE` strategy calls `super.clone()` first then `clone()` on each cloneable property
- the `AutoCloneStyle.SIMPLE` strategy uses a regular constructor call and copies properties from the source to the clone
- the `AutoCloneStyle.COPY_CONSTRUCTOR` strategy creates and uses a copy constructor
- the `AutoCloneStyle.SERIALIZATION` strategy uses serialization (or externalization) to clone the object

Each of those strategies have pros and cons which are discussed in the Javadoc for [groovy.transform.AutoClone](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/AutoClone.html) and [groovy.transform.AutoCloneStyle](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/AutoCloneStyle.html) .

For example, the following example:

```groovy
import groovy.transform.AutoClone

@AutoClone
class Book {
    String isbn
    String title
    List<String> authors
    Date publicationDate
}
```

is equivalent to this:

```groovy
class Book implements Cloneable {
    String isbn
    String title
    List<String> authors
    Date publicationDate

    public Book clone() throws CloneNotSupportedException {
        Book result = super.clone()
        result.authors = authors instanceof Cloneable ? (List) authors.clone() : authors
        result.publicationDate = publicationDate.clone()
        result
    }
}
```

Note that the String properties aren’t explicitly handled because Strings are immutable and the `clone()` method from `Object` will copy the String references. The same would apply to primitive fields and most of the concrete subclasses of `java.lang.Number`.

In addition to cloning styles, `@AutoClone` supports multiple options:

| Attribute     | Default value | Description                                                  | Example                                                      |
| :------------ | :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| excludes      | Empty list    | A list of property or field names that need to be excluded from cloning. A string consisting of a comma-separated field/property names is also allowed. See [groovy.transform.AutoClone#excludes](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/AutoClone.html#excludes) for details | `import groovy.transform.AutoClone import groovy.transform.AutoCloneStyle @AutoClone(style=AutoCloneStyle.SIMPLE,excludes='authors') class Book {    String isbn    String title    List authors    Date publicationDate }` |
| includeFields | false         | By default, only properties are cloned. Setting this flag to true will also clone fields. | `import groovy.transform.AutoClone import groovy.transform.AutoCloneStyle @AutoClone(style=AutoCloneStyle.SIMPLE,includeFields=true) class Book {    String isbn    String title    List authors    protected Date publicationDate }` |

```
@groovy.transform.AutoExternalize
```

The `@AutoExternalize` AST transformation will assist in the creation of `java.io.Externalizable` classes. It will automatically add the interface to the class and generate the `writeExternal` and `readExternal` methods. For example, this code:

```groovy
import groovy.transform.AutoExternalize

@AutoExternalize
class Book {
    String isbn
    String title
    float price
}
```

will be converted into:

```groovy
class Book implements java.io.Externalizable {
    String isbn
    String title
    float price

    void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(isbn)
        out.writeObject(title)
        out.writeFloat( price )
    }

    public void readExternal(ObjectInput oin) {
        isbn = (String) oin.readObject()
        title = (String) oin.readObject()
        price = oin.readFloat()
    }

}
```

The `@AutoExternalize` annotation supports two parameters which will let you slightly customize its behavior:

| Attribute     | Default value | Description                                                  | Example                                                      |
| :------------ | :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| excludes      | Empty list    | A list of property or field names that need to be excluded from externalizing. A string consisting of a comma-separated field/property names is also allowed. See [groovy.transform.AutoExternalize#excludes](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/AutoExternalize.html#excludes) for details | `import groovy.transform.AutoExternalize @AutoExternalize(excludes='price') class Book {    String isbn    String title    float price }` |
| includeFields | false         | By default, only properties are externalized. Setting this flag to true will also clone fields. | `import groovy.transform.AutoExternalize @AutoExternalize(includeFields=true) class Book {    String isbn    String title    protected float price }` |

###### Safer scripting

The Groovy language makes it easy to execute user scripts at runtime (for example using [groovy.lang.GroovyShell](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/GroovyShell.html)), but how do you make sure that a script won’t eat all CPU (infinite loops) or that concurrent scripts won’t slowly consume all available threads of a thread pool? Groovy provides several annotations which are aimed towards safer scripting, generating code which will for example allow you to interrupt execution automatically.

```
@groovy.transform.ThreadInterrupt
```

One complicated situation in the JVM world is when a thread can’t be stopped. The `Thread#stop` method exists but is deprecated (and isn’t reliable) so your only chance relies in `Thread#interrupt`. Calling the latter will set the `interrupt` flag on the thread, but it will **not** stop the execution of the thread. This is problematic because it’s the responsibility of the code executing in the thread to check the interrupt flag and properly exit. This makes sense when you, as a developer, know that the code you are executing is meant to be run in an independent thread, but in general, you don’t know it. It’s even worse with user scripts, who might not even know what a thread is (think of DSLs).

`@ThreadInterrupt` simplifies this by adding thread interruption checks at critical places in the code:

- loops (for, while)
- first instruction of a method
- first instruction of a closure body

Let’s imagine the following user script:

```groovy
while (true) {
    i++
}
```

This is an obvious infinite loop. If this code executes in its own thread, interrupting wouldn’t help: if you `join` on the thread, then the calling code would be able to continue, but the thread would still be alive, running in background without any ability for you to stop it, slowly causing thread starvation.

One possibility to work around this is to set up your shell this way:

```groovy
def config = new CompilerConfiguration()
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(ThreadInterrupt)
)
def binding = new Binding(i:0)
def shell = new GroovyShell(binding,config)
```

The shell is then configured to automatically apply the `@ThreadInterrupt` AST transformations on all scripts. This allows you to execute user scripts this way:

```groovy
def t = Thread.start {
    shell.evaluate(userCode)
}
t.join(1000) // give at most 1000ms for the script to complete
if (t.alive) {
    t.interrupt()
}
```

The transformation automatically modified user code like this:

```groovy
while (true) {
    if (Thread.currentThread().interrupted) {
        throw new InterruptedException('The current thread has been interrupted.')
    }
    i++
}
```

The check which is introduced inside the loop guarantees that if the `interrupt` flag is set on the current thread, an exception will be thrown, interrupting the execution of the thread.

`@ThreadInterrupt` supports multiple options that will let you further customize the behavior of the transformation:

| Attribute          | Default value                    | Description                                                  | Example                                                      |
| :----------------- | :------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| thrown             | `java.lang.InterruptedException` | Specifies the type of exception which is thrown if the thread is interrupted. | `class BadException extends Exception {    BadException(String message) { super(message) } } def config = new CompilerConfiguration() config.addCompilationCustomizers(        new ASTTransformationCustomizer(thrown:BadException, ThreadInterrupt) ) def binding = new Binding(i:0) def shell = new GroovyShell(this.class.classLoader,binding,config) def userCode = """ try {    while (true) {        i++    } } catch (BadException e) {    i = -1 } """ def t = Thread.start {    shell.evaluate(userCode) } t.join(1000) // give at most 1s for the script to complete assert binding.i > 0 if (t.alive) {    t.interrupt() } Thread.sleep(500) assert binding.i == -1'''` |
| checkOnMethodStart | true                             | Should an interruption check be inserted at the beginning of each method body. See [groovy.transform.ThreadInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ThreadInterrupt.html) for details. | `@ThreadInterrupt(checkOnMethodStart=false)`                 |
| applyToAllClasses  | true                             | Should the transformation be applied on all classes of the same source unit (in the same source file). See [groovy.transform.ThreadInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ThreadInterrupt.html) for details. | `@ThreadInterrupt(applyToAllClasses=false) class A { ... } // interrupt checks added class B { ... } // no interrupt checks` |
| applyToAllMembers  | true                             | Should the transformation be applied on all members of class. See [groovy.transform.ThreadInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ThreadInterrupt.html) for details. | `class A {    @ThreadInterrupt(applyToAllMembers=false)    void method1() { ... } // interrupt checked added    void method2() { ... } // no interrupt checks }` |

```
@groovy.transform.TimedInterrupt
```

The `@TimedInterrupt` AST transformation tries to solve a slightly different problem from [`@groovy.transform.ThreadInterrupt`](https://docs.groovy-lang.org/latest/html/documentation/#xform-ThreadInterrupt): instead of checking the `interrupt` flag of the thread, it will automatically throw an exception if the thread has been running for too long.

|      | This annotation does **not** spawn a monitoring thread. Instead, it works in a similar manner as `@ThreadInterrupt` by placing checks at appropriate places in the code. This means that if you have a thread blocked by I/O, it will **not** be interrupted. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Imagine the following user code:

```groovy
def fib(int n) { n<2?n:fib(n-1)+fib(n-2) }

result = fib(600)
```

The implementation of the famous Fibonacci number computation here is far from optimized. If it is called with a high `n` value, it can take minutes to answer. With `@TimedInterrupt`, you can choose how long a script is allowed to run. The following setup code will allow the user script to run for 1 second at max:

```groovy
def config = new CompilerConfiguration()
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(value:1, TimedInterrupt)
)
def binding = new Binding(result:0)
def shell = new GroovyShell(this.class.classLoader, binding,config)
```

This code is equivalent to annotating a class with `@TimedInterrupt` like this:

```groovy
@TimedInterrupt(value=1, unit=TimeUnit.SECONDS)
class MyClass {
    def fib(int n) {
        n<2?n:fib(n-1)+fib(n-2)
    }
}
```

`@TimedInterrupt` supports multiple options that will let you further customize the behavior of the transformation:

| Attribute          | Default value                           | Description                                                  | Example                                                      |
| :----------------- | :-------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| value              | Long.MAX_VALUE                          | Used in combination with `unit` to specify after how long execution times out. | `@TimedInterrupt(value=500L, unit= TimeUnit.MILLISECONDS, applyToAllClasses = false) class Slow {    def fib(n) { n<2?n:fib(n-1)+fib(n-2) } } def result def t = Thread.start {    result = new Slow().fib(500) } t.join(5000) assert result == null assert !t.alive` |
| unit               | TimeUnit.SECONDS                        | Used in combination with `value` to specify after how long execution times out. | `@TimedInterrupt(value=500L, unit= TimeUnit.MILLISECONDS, applyToAllClasses = false) class Slow {    def fib(n) { n<2?n:fib(n-1)+fib(n-2) } } def result def t = Thread.start {    result = new Slow().fib(500) } t.join(5000) assert result == null assert !t.alive` |
| thrown             | `java.util.concurrent.TimeoutException` | Specifies the type of exception which is thrown if timeout is reached. | `@TimedInterrupt(thrown=TooLongException, applyToAllClasses = false, value=1L) class Slow {    def fib(n) { Thread.sleep(100); n<2?n:fib(n-1)+fib(n-2) } } def result def t = Thread.start {    try {        result = new Slow().fib(50)    } catch (TooLongException e) {        result = -1    } } t.join(5000) assert result == -1` |
| checkOnMethodStart | true                                    | Should an interruption check be inserted at the beginning of each method body. See [groovy.transform.TimedInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/TimedInterrupt.html) for details. | `@TimedInterrupt(checkOnMethodStart=false)`                  |
| applyToAllClasses  | true                                    | Should the transformation be applied on all classes of the same source unit (in the same source file). See [groovy.transform.TimedInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/TimedInterrupt.html) for details. | `@TimedInterrupt(applyToAllClasses=false) class A { ... } // interrupt checks added class B { ... } // no interrupt checks` |
| applyToAllMembers  | true                                    | Should the transformation be applied on all members of class. See [groovy.transform.TimedInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/TimedInterrupt.html) for details. | `class A {    @TimedInterrupt(applyToAllMembers=false)    void method1() { ... } // interrupt checked added    void method2() { ... } // no interrupt checks }` |

|      | `@TimedInterrupt` is currently not compatible with static methods! |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```
@groovy.transform.ConditionalInterrupt
```

The last annotation for safer scripting is the base annotation when you want to interrupt a script using a custom strategy. In particular, this is the annotation of choice if you want to use resource management (limit the number of calls to an API, …). In the following example, user code is using an infinite loop, but `@ConditionalInterrupt` will allow us to check a quota manager and interrupt automatically the script:

```groovy
@ConditionalInterrupt({Quotas.disallow('user')})
class UserCode {
    void doSomething() {
        int i=0
        while (true) {
            println "Consuming resources ${++i}"
        }
    }
}
```

The quota checking is very basic here, but it can be any code:

```groovy
class Quotas {
    static def quotas = [:].withDefault { 10 }
    static boolean disallow(String userName) {
        println "Checking quota for $userName"
        (quotas[userName]--)<0
    }
}
```

We can make sure `@ConditionalInterrupt` works properly using this test code:

```groovy
assert Quotas.quotas['user'] == 10
def t = Thread.start {
    new UserCode().doSomething()
}
t.join(5000)
assert !t.alive
assert Quotas.quotas['user'] < 0
```

Of course, in practice, it is unlikely that `@ConditionalInterrupt` will be itself added by hand on user code. It can be injected in a similar manner as the example shown in the [ThreadInterrupt](https://docs.groovy-lang.org/latest/html/documentation/#xform-ThreadInterrupt) section, using the [org.codehaus.groovy.control.customizers.ASTTransformationCustomizer](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/customizers/ASTTransformationCustomizer.html) :

```groovy
def config = new CompilerConfiguration()
def checkExpression = new ClosureExpression(
        Parameter.EMPTY_ARRAY,
        new ExpressionStatement(
                new MethodCallExpression(new ClassExpression(ClassHelper.make(Quotas)), 'disallow', new ConstantExpression('user'))
        )
)
config.addCompilationCustomizers(
        new ASTTransformationCustomizer(value: checkExpression, ConditionalInterrupt)
)

def shell = new GroovyShell(this.class.classLoader,new Binding(),config)

def userCode = """
        int i=0
        while (true) {
            println "Consuming resources \\${++i}"
        }
"""

assert Quotas.quotas['user'] == 10
def t = Thread.start {
    shell.evaluate(userCode)
}
t.join(5000)
assert !t.alive
assert Quotas.quotas['user'] < 0
```

`@ConditionalInterrupt` supports multiple options that will let you further customize the behavior of the transformation:

| Attribute          | Default value                    | Description                                                  | Example                                                      |
| :----------------- | :------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| value              |                                  | The closure which will be called to check if execution is allowed. If the closure returns false, execution is allowed. If it returns true, then an exception will be thrown. | `@ConditionalInterrupt({ ... })`                             |
| thrown             | `java.lang.InterruptedException` | Specifies the type of exception which is thrown if execution should be aborted. | `config.addCompilationCustomizers(        new ASTTransformationCustomizer(thrown: QuotaExceededException,value: checkExpression, ConditionalInterrupt) ) assert Quotas.quotas['user'] == 10 def t = Thread.start {    try {        shell.evaluate(userCode)    } catch (QuotaExceededException) {        Quotas.quotas['user'] = 'Quota exceeded'    } } t.join(5000) assert !t.alive assert Quotas.quotas['user'] == 'Quota exceeded'` |
| checkOnMethodStart | true                             | Should an interruption check be inserted at the beginning of each method body. See [groovy.transform.ConditionalInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html) for details. | `@ConditionalInterrupt(checkOnMethodStart=false)`            |
| applyToAllClasses  | true                             | Should the transformation be applied on all classes of the same source unit (in the same source file). See [groovy.transform.ConditionalInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html) for details. | `@ConditionalInterrupt(applyToAllClasses=false) class A { ... } // interrupt checks added class B { ... } // no interrupt checks` |
| applyToAllMembers  | true                             | Should the transformation be applied on all members of class. See [groovy.transform.ConditionalInterrupt](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/ConditionalInterrupt.html) for details. | `class A {    @ConditionalInterrupt(applyToAllMembers=false)    void method1() { ... } // interrupt checked added    void method2() { ... } // no interrupt checks }` |

###### Compiler directives

This category of AST transformations groups annotations which have a direct impact on the semantics of the code, rather than focusing on code generation. With that regards, they can be seen as compiler directives that either change the behavior of a program at compile time or runtime.

```
@groovy.transform.Field
```

The `@Field` annotation only makes sense in the context of a script and aims at solving a common scoping error with scripts. The following example will for example fail at runtime:

```groovy
def x

String line() {
    "="*x
}

x=3
assert "===" == line()
x=5
assert "=====" == line()
```

The error that is thrown may be difficult to interpret: groovy.lang.MissingPropertyException: No such property: x. The reason is that scripts are compiled to classes and the script body is itself compiled as a single *run()* method. Methods which are defined in the scripts are independent, so the code above is equivalent to this:

```groovy
class MyScript extends Script {

    String line() {
        "="*x
    }

    public def run() {
        def x
        x=3
        assert "===" == line()
        x=5
        assert "=====" == line()
    }
}
```

So `def x` is effectively interpreted as a local variable, outside of the scope of the `line` method. The `@Field` AST transformation aims at fixing this by changing the scope of the variable to a field of the enclosing script:

```groovy
@Field def x

String line() {
    "="*x
}

x=3
assert "===" == line()
x=5
assert "=====" == line()
```

The resulting, equivalent, code is now:

```groovy
class MyScript extends Script {

    def x

    String line() {
        "="*x
    }

    public def run() {
        x=3
        assert "===" == line()
        x=5
        assert "=====" == line()
    }
}
@groovy.transform.PackageScope
```

By default, Groovy visibility rules imply that if you create a field without specifying a modifier, then the field is interpreted as a property:

```groovy
class Person {
    String name // this is a property
}
```

Should you want to create a package private field instead of a property (private field+getter/setter), then annotate your field with `@PackageScope`:

```groovy
class Person {
    @PackageScope String name // not a property anymore
}
```

The `@PackageScope` annotation can also be used for classes, methods and constructors. In addition, by specifying a list of `PackageScopeTarget` values as the annotation attribute at the class level, all members within that class that don’t have an explicit modifier and match the provided `PackageScopeTarget` will remain package protected. For example to apply to fields within a class use the following annotation:

```groovy
import static groovy.transform.PackageScopeTarget.FIELDS
@PackageScope(FIELDS)
class Person {
  String name     // not a property, package protected
  Date dob        // not a property, package protected
  private int age // explicit modifier, so won't be touched
}
```

The `@PackageScope` annotation is seldom used as part of normal Groovy conventions but is sometimes useful for factory methods that should be visible internally within a package or for methods or constructors provided for testing purposes, or when integrating with third-party libraries which require such visibility conventions.

```
@groovy.transform.AutoFinal
```

The `@AutoFinal` annotation instructs the compiler to automatically insert the final modifier in numerous places within the annotated node. If applied on a method (or constructor), the parameters for that method (or constructor) will be marked as final. If applied on a class definition, the same treatment will occur for all declared methods and constructors within that class.

It is often considered bad practice to reassign parameters of a method or constructor with its body. By adding the final modifier to all parameter declarations you can avoid this practice entirely. Some programmers feel that adding final everywhere increases the amount of boilerplate code and makes the method signatures somewhat noisy. An alternative might instead be to use a code review process or apply a [codenarc](http://codenarc.org/) [rule](https://codenarc.github.io/CodeNarc/codenarc-rules-convention.html#parameterreassignment-rule) to give warnings if that practice is observed but these alternatives might lead to delayed feedback during quality checking rather than within the IDE or during compilation. The `@AutoFinal` annotation aims to maximise compiler/IDE feedback while retaining succinct code with minimum boilerplate noise.

The following example illustrates applying the annotation at the class level:

```groovy
import groovy.transform.AutoFinal

@AutoFinal
class Person {
    private String first, last

    Person(String first, String last) {
        this.first = first
        this.last = last
    }

    String fullName(String separator) {
        "$first$separator$last"
    }

    String greeting(String salutation) {
        "$salutation, $first"
    }
}
```

In this example, the two parameters for the constructor and the single parameter for both the `fullname` and `greeting` methods will be final. Attempts to modify those parameters within the constructor or method bodies will be flagged by the compiler.

The following example illustrates applying the annotation at the method level:

```groovy
class Calc {
    @AutoFinal
    int add(int a, int b) { a + b }

    int mult(int a, int b) { a * b }
}
```

Here, the `add` method will have final parameters but the `mult` method will remain unchanged.

```
@groovy.transform.AnnotationCollector
```

`@AnnotationCollector` allows the creation of meta-annotations, which are described in a [dedicated section](https://docs.groovy-lang.org/latest/html/documentation/#_meta_annotations).

```
@groovy.transform.TypeChecked
```

`@TypeChecked` activates compile-time type checking on your Groovy code. See [section on type checking](https://docs.groovy-lang.org/latest/html/documentation/#static-type-checking) for details.

```
@groovy.transform.CompileStatic
```

`@CompileStatic` activates static compilation on your Groovy code. See [section on type checking](https://docs.groovy-lang.org/latest/html/documentation/#static-type-checking) for details.

```
@groovy.transform.CompileDynamic
```

`@CompileDynamic` disables static compilation on parts of your Groovy code. See [section on type checking](https://docs.groovy-lang.org/latest/html/documentation/#static-type-checking) for details.

```
@groovy.lang.DelegatesTo
```

`@DelegatesTo` is not, technically speaking, an AST transformation. It is aimed at documenting code and helping the compiler in case you are using [type checking](https://docs.groovy-lang.org/latest/html/documentation/#xform-TypeChecked) or [static compilation](https://docs.groovy-lang.org/latest/html/documentation/#xform-CompileStatic). The annotation is described thoroughly in the [DSL section](https://docs.groovy-lang.org/latest/html/documentation/#section-delegatesto) of this guide.

```
@groovy.transform.SelfType
```

`@SelfType` is not an AST transformation but rather a marker interface used with traits. See the [traits documentation](https://docs.groovy-lang.org/latest/html/documentation/#traits-selftype) for further details.

###### Swing patterns

```
@groovy.beans.Bindable
```

`@Bindable` is an AST transformation that transforms a regular property into a bound property (according to the [JavaBeans specification](http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/)). The `@Bindable` annotation can be placed on a property or a class. To convert all properties of a class into bound properties, on can annotate the class like in this example:

```groovy
import groovy.beans.Bindable

@Bindable
class Person {
    String name
    int age
}
```

This is equivalent to writing this:

```groovy
import java.beans.PropertyChangeListener
import java.beans.PropertyChangeSupport

class Person {
    final private PropertyChangeSupport this$propertyChangeSupport

    String name
    int age

    public void addPropertyChangeListener(PropertyChangeListener listener) {
        this$propertyChangeSupport.addPropertyChangeListener(listener)
    }

    public void addPropertyChangeListener(String name, PropertyChangeListener listener) {
        this$propertyChangeSupport.addPropertyChangeListener(name, listener)
    }

    public void removePropertyChangeListener(PropertyChangeListener listener) {
        this$propertyChangeSupport.removePropertyChangeListener(listener)
    }

    public void removePropertyChangeListener(String name, PropertyChangeListener listener) {
        this$propertyChangeSupport.removePropertyChangeListener(name, listener)
    }

    public void firePropertyChange(String name, Object oldValue, Object newValue) {
        this$propertyChangeSupport.firePropertyChange(name, oldValue, newValue)
    }

    public PropertyChangeListener[] getPropertyChangeListeners() {
        return this$propertyChangeSupport.getPropertyChangeListeners()
    }

    public PropertyChangeListener[] getPropertyChangeListeners(String name) {
        return this$propertyChangeSupport.getPropertyChangeListeners(name)
    }
}
```

`@Bindable` therefore removes a lot of boilerplate from your class, dramatically increasing readability. If the annotation is put on a single property, only that property is bound:

```groovy
import groovy.beans.Bindable

class Person {
    String name
    @Bindable int age
}
@groovy.beans.ListenerList
```

The `@ListenerList` AST transformation generates code for adding, removing and getting the list of listeners to a class, just by annotating a collection property:

```groovy
import java.awt.event.ActionListener
import groovy.beans.ListenerList

class Component {
    @ListenerList
    List<ActionListener> listeners;
}
```

The transform will generate the appropriate add/remove methods based on the generic type of the list. In addition, it will also create `fireXXX` methods based on the public methods declared on the class:

```groovy
import java.awt.event.ActionEvent
import java.awt.event.ActionListener as ActionListener
import groovy.beans.ListenerList as ListenerList

public class Component {

    @ListenerList
    private List<ActionListener> listeners

    public void addActionListener(ActionListener listener) {
        if ( listener == null) {
            return
        }
        if ( listeners == null) {
            listeners = []
        }
        listeners.add(listener)
    }

    public void removeActionListener(ActionListener listener) {
        if ( listener == null) {
            return
        }
        if ( listeners == null) {
            listeners = []
        }
        listeners.remove(listener)
    }

    public ActionListener[] getActionListeners() {
        Object __result = []
        if ( listeners != null) {
            __result.addAll(listeners)
        }
        return (( __result ) as ActionListener[])
    }

    public void fireActionPerformed(ActionEvent param0) {
        if ( listeners != null) {
            ArrayList<ActionListener> __list = new ArrayList<ActionListener>(listeners)
            for (def listener : __list ) {
                listener.actionPerformed(param0)
            }
        }
    }
}
```

`@Bindable` supports multiple options that will let you further customize the behavior of the transformation:

| Attribute   | Default value     | Description                                                  | Example                                                      |
| :---------- | :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| name        | Generic type name | By default, the suffix which will be appended to add/remove/… methods is the simple class name of the generic type of the list. | `class Component {    @ListenerList(name='item')    List listeners; }` |
| synchronize | false             | If set to true, generated methods will be synchronized       | `class Component {    @ListenerList(synchronize = true)    List listeners; }` |

```
@groovy.beans.Vetoable
```

The `@Vetoable` annotation works in a similar manner to `@Bindable` but generates constrained property according to the JavaBeans specification, instead of bound properties. The annotation can be placed on a class, meaning that all properties will be converted to constrained properties, or on a single property. For example, annotating this class with `@Vetoable`:

```groovy
import groovy.beans.Vetoable

import java.beans.PropertyVetoException
import java.beans.VetoableChangeListener

@Vetoable
class Person {
    String name
    int age
}
```

is equivalent to writing this:

```groovy
public class Person {

    private String name
    private int age
    final private java.beans.VetoableChangeSupport this$vetoableChangeSupport

    public void addVetoableChangeListener(VetoableChangeListener listener) {
        this$vetoableChangeSupport.addVetoableChangeListener(listener)
    }

    public void addVetoableChangeListener(String name, VetoableChangeListener listener) {
        this$vetoableChangeSupport.addVetoableChangeListener(name, listener)
    }

    public void removeVetoableChangeListener(VetoableChangeListener listener) {
        this$vetoableChangeSupport.removeVetoableChangeListener(listener)
    }

    public void removeVetoableChangeListener(String name, VetoableChangeListener listener) {
        this$vetoableChangeSupport.removeVetoableChangeListener(name, listener)
    }

    public void fireVetoableChange(String name, Object oldValue, Object newValue) throws PropertyVetoException {
        this$vetoableChangeSupport.fireVetoableChange(name, oldValue, newValue)
    }

    public VetoableChangeListener[] getVetoableChangeListeners() {
        return this$vetoableChangeSupport.getVetoableChangeListeners()
    }

    public VetoableChangeListener[] getVetoableChangeListeners(String name) {
        return this$vetoableChangeSupport.getVetoableChangeListeners(name)
    }

    public void setName(String value) throws PropertyVetoException {
        this.fireVetoableChange('name', name, value)
        name = value
    }

    public void setAge(int value) throws PropertyVetoException {
        this.fireVetoableChange('age', age, value)
        age = value
    }
}
```

If the annotation is put on a single property, only that property is made vetoable:

```groovy
import groovy.beans.Vetoable

class Person {
    String name
    @Vetoable int age
}
```

###### Test assistance

```
@groovy.test.NotYetImplemented
```

`@NotYetImplemented` is used to invert the result of a JUnit 3/4 test case. It is in particular useful if a feature is not yet implemented but the test is. In that case, it is expected that the test fails. Marking it with `@NotYetImplemented` will inverse the result of the test, like in this example:

```groovy
import groovy.test.GroovyTestCase
import groovy.test.NotYetImplemented

class Maths {
    static int fib(int n) {
        // todo: implement later
    }
}

class MathsTest extends GroovyTestCase {
    @NotYetImplemented
    void testFib() {
        def dataTable = [
                1:1,
                2:1,
                3:2,
                4:3,
                5:5,
                6:8,
                7:13
        ]
        dataTable.each { i, r ->
            assert Maths.fib(i) == r
        }
    }
}
```

Another advantage of using this technique is that you can write test cases for bugs before knowing how to fix them. If some time in the future, a modification in the code fixes a bug by side effect, you’ll be notified because a test which was expected to fail passed.

```
@groovy.transform.ASTTest
```

`@ASTTest` is a special AST transformation meant to help debugging other AST transformations or the Groovy compiler itself. It will let the developer "explore" the AST during compilation and perform assertions on the AST rather than on the result of compilation. This means that this AST transformations gives access to the AST before the bytecode is produced. `@ASTTest` can be placed on any annotable node and requires two parameters:

- *phase*: sets at which phase at which `@ASTTest` will be triggered. The test code will work on the AST tree at the end of this phase.
- *value*: the code which will be executed once the phase is reached, on the annotated node

|      | Compile phase has to be chosen from one of [org.codehaus.groovy.control.CompilePhase](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/CompilePhase.html) . However, since it is not possible to annotate a node twice with the same annotation, you will not be able to use `@ASTTest` on the same node at two distinct compile phases. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

`value` is a closure expression which has access to a special variable `node` corresponding to the annotated node, and a helper `lookup` method which will be discussed [here](https://docs.groovy-lang.org/latest/html/documentation/#asttest-lookup). For example, you can annotate a class node like this:

```groovy
import groovy.transform.ASTTest
import org.codehaus.groovy.ast.ClassNode
import static org.codehaus.groovy.control.CompilePhase.*

@ASTTest(phase=CONVERSION, value={   
    assert node instanceof ClassNode 
    assert node.name == 'Person'     
})
class Person {

}
```

|      | we’re checking the state of the Abstract Syntax Tree after the CONVERSION phase |
| ---- | ------------------------------------------------------------ |
|      | node refers to the AST node which is annotated by @ASTTest   |
|      | it can be used to perform assertions at compile time         |

One interesting feature of `@ASTTest` is that if an assertion fails, then **compilation will fail**. Now imagine that we want to check the behavior of an AST transformation at compile time. We will take `@PackageScope` here, and we will want to verify that a property annotated with `@PackageScope` becomes a package private field. For this, we have to know at which phase the transform runs, which can be found in [org.codehaus.groovy.transform.PackageScopeASTTransformation](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/PackageScopeASTTransformation.html) : semantic analysis. Then a test can be written like this:

```groovy
import groovy.transform.ASTTest
import groovy.transform.PackageScope

import static org.codehaus.groovy.control.CompilePhase.*

@ASTTest(phase=SEMANTIC_ANALYSIS, value= {
    def nameNode = node.properties.find { it.name == 'name' }
    def ageNode = node.properties.find { it.name == 'age' }
    assert nameNode
    assert ageNode == null // shouldn't be a property anymore
    def ageField = node.getDeclaredField 'age'
    assert ageField.modifiers == 0
})
class Person {
    String name
    @PackageScope int age
}
```

The `@ASTTest` annotation can only be placed wherever the grammar allows it. Sometimes, you would like to test the contents of an AST node which is not annotable. In this case, `@ASTTest` provides a convenient `lookup` method which will search the AST for nodes which are labelled with a special token:

```groovy
def list = lookup('anchor') 
Statement stmt = list[0] 
```

|      | returns the list of AST nodes which label is 'anchor'        |
| ---- | ------------------------------------------------------------ |
|      | it is always necessary to choose which element to process since lookup always returns a list |

Imagine, for example, that you want to test the declared type of a for loop variable. Then you can do it like this:

```groovy
import groovy.transform.ASTTest
import groovy.transform.PackageScope
import org.codehaus.groovy.ast.ClassHelper
import org.codehaus.groovy.ast.expr.DeclarationExpression
import org.codehaus.groovy.ast.stmt.ForStatement

import static org.codehaus.groovy.control.CompilePhase.*

class Something {
    @ASTTest(phase=SEMANTIC_ANALYSIS, value= {
        def forLoop = lookup('anchor')[0]
        assert forLoop instanceof ForStatement
        def decl = forLoop.collectionExpression.expressions[0]
        assert decl instanceof DeclarationExpression
        assert decl.variableExpression.name == 'i'
        assert decl.variableExpression.originType == ClassHelper.int_TYPE
    })
    void someMethod() {
        int x = 1;
        int y = 10;
        anchor: for (int i=0; i<x+y; i++) {
            println "$i"
        }
    }
}
```

`@ASTTest` also exposes those variables inside the test closure:

- `node` corresponds to the annotated node, as usual
- `compilationUnit` gives access to the current `org.codehaus.groovy.control.CompilationUnit`
- `compilePhase` returns the current compile phase (`org.codehaus.groovy.control.CompilePhase`)

The latter is interesting if you don’t specify the `phase` attribute. In that case, the closure will be executed after each compile phase after (and including) `SEMANTIC_ANALYSIS`. The context of the transformation is kept after each phase, giving you a chance to check what changed between two phases.

As an example, here is how you could dump the list of AST transformations registered on a class node:

```groovy
import groovy.transform.ASTTest
import groovy.transform.CompileStatic
import groovy.transform.Immutable
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.control.CompilePhase

@ASTTest(value={
    System.err.println "Compile phase: $compilePhase"
    ClassNode cn = node
    System.err.println "Global AST xforms: ${compilationUnit?.ASTTransformationsContext?.globalTransformNames}"
    CompilePhase.values().each {
        def transforms = cn.getTransforms(it)
        if (transforms) {
            System.err.println "Ast xforms for phase $it:"
            transforms.each { map ->
                System.err.println(map)
            }
        }
    }
})
@CompileStatic
@Immutable
class Foo {
}
```

And here is how you can memorize variables for testing between two phases:

```groovy
import groovy.transform.ASTTest
import groovy.transform.ToString
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.control.CompilePhase

@ASTTest(value={
    if (compilePhase==CompilePhase.INSTRUCTION_SELECTION) {             
        println "toString() was added at phase: ${added}"
        assert added == CompilePhase.CANONICALIZATION                   
    } else {
        if (node.getDeclaredMethods('toString') && added==null) {       
            added = compilePhase                                        
        }
    }
})
@ToString
class Foo {
    String name
}
```

|      | if the current compile phase is instruction selection        |
| ---- | ------------------------------------------------------------ |
|      | then we want to make sure `toString` was added at `CANONICALIZATION` |
|      | otherwise, if `toString` exists and that the variable from the context, `added` is null |
|      | then it means that this compile phase is the one where `toString` was added |

###### Grape handling

```
@groovy.lang.Grab
@groovy.lang.GrabConfig
@groovy.lang.GrabExclude
@groovy.lang.GrabResolver
@groovy.lang.Grapes
```

`Grape` is a dependency management engine embedded into Groovy, relying on several annotations which are described thoroughly in this [section of the guide](https://docs.groovy-lang.org/latest/html/documentation/#section-grape).

##### Developing AST transformations

There are two kinds of transformations: global and local transformations.

- [Global transformations](https://docs.groovy-lang.org/latest/html/documentation/#transforms-global) are applied to by the compiler on the code being compiled, wherever the transformation apply. Compiled classes that implement global transformations are in a JAR added to the classpath of the compiler and contain service locator file `META-INF/services/org.codehaus.groovy.transform.ASTTransformation` with a line with the name of the transformation class. The transformation class must have a no-args constructor and implement the `org.codehaus.groovy.transform.ASTTransformation` interface. It will be run against **every source in the compilation**, so be sure to not create transformations which scan all the AST in an expansive and time-consuming manner, to keep the compiler fast.
- [Local transformations](https://docs.groovy-lang.org/latest/html/documentation/#transforms-local) are transformations applied locally by annotating code elements you want to transform. For this, we reuse the annotation notation, and those annotations should implement `org.codehaus.groovy.transform.ASTTransformation`. The compiler will discover them and apply the transformation on these code elements.

###### Compilation phases guide

Groovy AST transformations must be performed in one of the nine defined compilation phases ([org.codehaus.groovy.control.CompilePhase](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/CompilePhase.html)).

Global transformations may be applied in any phase, but local transformations may only be applied in the semantic analysis phase or later. Briefly, the compiler phases are:

- *Initialization*: source files are opened and environment configured
- *Parsing*: the grammar is used to to produce tree of tokens representing the source code
- *Conversion*: An abstract syntax tree (AST) is created from token trees.
- *Semantic Analysis*: Performs consistency and validity checks that the grammar can’t check for, and resolves classes.
- *Canonicalization*: Complete building the AST
- *Instruction Selection*: instruction set is chosen, for example Java 6 or Java 7 bytecode level
- *Class Generation*: creates the bytecode of the class in memory
- *Output*: write the binary output to the file system
- *Finalization*: Perform any last cleanup

Generally speaking, there is more type information available later in the phases. If your transformation is concerned with reading the AST, then a later phase where information is more plentiful might be a good choice. If your transformation is concerned with writing AST, then an earlier phase where the tree is more sparse might be more convenient.

###### Local transformations

Local AST transformations are relative to the context they are applied to. In most cases, the context is defined by an annotation that will define the scope of the transform. For example, annotating a field would mean that the transformation *applies to* the field, while annotating the class would mean that the transformation *applies to* the whole class.

As a naive and simple example, consider wanting to write a `@WithLogging` transformation that would add console messages at the start and end of a method invocation. So the following "Hello World" example would actually print "Hello World" along with a start and stop message:

Poor man’s aspect oriented programming

```groovy
@WithLogging
def greet() {
    println "Hello World"
}

greet()
```

A local AST transformation is an easy way to do this. It requires two things:

- a definition of the `@WithLogging` annotation
- an implementation of [org.codehaus.groovy.transform.ASTTransformation](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/ASTTransformation.html) that adds the logging expressions to the method

An `ASTTransformation` is a callback that gives you access to the [org.codehaus.groovy.control.SourceUnit](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/SourceUnit.html), through which you can get a reference to the [org.codehaus.groovy.ast.ModuleNode](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/ast/ModuleNode.html) (AST).

The AST (Abstract Syntax Tree) is a tree structure consisting mostly of [org.codehaus.groovy.ast.expr.Expression](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/ast/expr/Expression.html) (expressions) or [org.codehaus.groovy.ast.expr.Statement](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/ast/expr/Statement.html) (statements). An easy way to learn about the AST is to explore it in a debugger. Once you have the AST, you can analyze it to find out information about the code or rewrite it to add new functionality.

The local transformation annotation is the simple part. Here is the `@WithLogging` one:

```groovy
import org.codehaus.groovy.transform.GroovyASTTransformationClass

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.METHOD])
@GroovyASTTransformationClass(["gep.WithLoggingASTTransformation"])
public @interface WithLogging {
}
```

The annotation retention can be `SOURCE` because you won’t need the annotation past that. The element type here is `METHOD`, the `@WithLogging` because the annotation applies to methods.

But the most important part is the `@GroovyASTTransformationClass` annotation. This links the `@WithLogging` annotation to the `ASTTransformation` class you will write. `gep.WithLoggingASTTransformation` is the fully qualified class name of the `ASTTransformation` we are going to write. This line wires the annotation to the transformation.

With this in place, the Groovy compiler is going to invoke `gep.WithLoggingASTTransformation` every time an `@WithLogging` is found in a source unit. Any breakpoint set within `LoggingASTTransformation` will now be hit within the IDE when running the sample script.

The `ASTTransformation` class is a little more complex. Here is the very simple, and very naive, transformation to add a method start and stop message for `@WithLogging`:

```groovy
@CompileStatic                                                                  
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)                  
class WithLoggingASTTransformation implements ASTTransformation {               

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {                        
        MethodNode method = (MethodNode) nodes[1]                               

        def startMessage = createPrintlnAst("Starting $method.name")            
        def endMessage = createPrintlnAst("Ending $method.name")                

        def existingStatements = ((BlockStatement)method.code).statements       
        existingStatements.add(0, startMessage)                                 
        existingStatements.add(endMessage)                                      

    }

    private static Statement createPrintlnAst(String message) {                 
        new ExpressionStatement(
            new MethodCallExpression(
                new VariableExpression("this"),
                new ConstantExpression("println"),
                new ArgumentListExpression(
                    new ConstantExpression(message)
                )
            )
        )
    }
}
```

|      | even if not mandatory, if you write an AST transformation in Groovy, it is highly recommended to use `CompileStatic` because it will improve performance of the compiler. |
| ---- | ------------------------------------------------------------ |
|      | annotate with [org.codehaus.groovy.transform.GroovyASTTransformation](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/GroovyASTTransformation.html) to tell at which compilation phase the transform needs to run. Here, it’s at the *semantic analysis* phase. |
|      | implement the `ASTTransformation` interface                  |
|      | which only has a single `visit` method                       |
|      | the `nodes` parameter is a 2 AST node array, for which the first one is the annotation node (`@WithLogging`) and the second one is the annotated node (the method node) |
|      | create a statement that will print a message when we enter the method |
|      | create a statement that will print a message when we exit the method |
|      | get the method body, which in this case is a `BlockStatement` |
|      | add the enter method message before the first statement of existing code |
|      | append the exit method message after the last statement of existing code |
|      | creates an `ExpressionStatement` wrapping a `MethodCallExpression` corresponding to `this.println("message")` |

It is important to notice that for the brevity of this example, we didn’t make the necessary checks, such as checking that the annotated node is really a `MethodNode`, or that the method body is an instance of `BlockStatement`. This exercise is left to the reader.

Note the creation of the new println statements in the `createPrintlnAst(String)` method. Creating AST for code is not always simple. In this case we need to construct a new method call, passing in the receiver/variable, the name of the method, and an argument list. When creating AST, it might be helpful to write the code you’re trying to create in a Groovy file and then inspect the AST of that code in the debugger to learn what to create. Then write a function like `createPrintlnAst` using what you learned through the debugger.

In the end:

```groovy
@WithLogging
def greet() {
    println "Hello World"
}

greet()
```

Produces:

```
Starting greet
Hello World
Ending greet
```

|      | It is important to note that an AST transformation participates directly in the compilation process. A common error by beginners is to have the AST transformation code in the same source tree as a class that uses the transformation. Being in the same source tree in general means that they are compiled at the same time. Since the transformation itself is going to be compiled in phases and that each compile phase processes all files of the same source unit before going to the next one, there’s a direct consequence: the transformation will not be compiled before the class that uses it! In conclusion, AST transformations need to be precompiled before you can use them. In general, it is as easy as having them in a separate source tree. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Global transformations

Global AST transformation are similar to local one with a major difference: they do not need an annotation, meaning that they are applied *globally*, that is to say on each class being compiled. It is therefore very important to limit their use to last resort, because it can have a significant impact on the compiler performance.

Following the example of the [local AST transformation](https://docs.groovy-lang.org/latest/html/documentation/#transform-local), imagine that we would like to trace all methods, and not only those which are annotated with `@WithLogging`. Basically, we need this code to behave the same as the one annotated with `@WithLogging` before:

```groovy
def greet() {
    println "Hello World"
}

greet()
```

To make this work, there are two steps:

1. create the `org.codehaus.groovy.transform.ASTTransformation` descriptor inside the `META-INF/services` directory
2. create the `ASTTransformation` implementation

The descriptor file is required and must be found on classpath. It will contain a single line:

META-INF/services/org.codehaus.groovy.transform.ASTTransformation

```groovy
gep.WithLoggingASTTransformation
```

The code for the transformation looks similar to the local case, but instead of using the `ASTNode[]` parameter, we need to use the `SourceUnit` instead:

gep/WithLoggingASTTransformation.groovy

```groovy
@CompileStatic                                                                  
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)                  
class WithLoggingASTTransformation implements ASTTransformation {               

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {                        
        def methods = sourceUnit.AST.methods                                    
        methods.each { method ->                                                
            def startMessage = createPrintlnAst("Starting $method.name")        
            def endMessage = createPrintlnAst("Ending $method.name")            

            def existingStatements = ((BlockStatement)method.code).statements   
            existingStatements.add(0, startMessage)                             
            existingStatements.add(endMessage)                                  
        }
    }

    private static Statement createPrintlnAst(String message) {                 
        new ExpressionStatement(
            new MethodCallExpression(
                new VariableExpression("this"),
                new ConstantExpression("println"),
                new ArgumentListExpression(
                    new ConstantExpression(message)
                )
            )
        )
    }
}
```

|      | even if not mandatory, if you write an AST transformation in Groovy, it is highly recommended to use `CompileStatic` because it will improve performance of the compiler. |
| ---- | ------------------------------------------------------------ |
|      | annotate with [org.codehaus.groovy.transform.GroovyASTTransformation](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/GroovyASTTransformation.html) to tell at which compilation phase the transform needs to run. Here, it’s at the *semantic analysis* phase. |
|      | implement the `ASTTransformation` interface                  |
|      | which only has a single `visit` method                       |
|      | the `sourceUnit` parameter gives access to the source being compiled, so we get the AST of the current source and retrieve the list of methods from this file |
|      | we iterate on each method from the source file               |
|      | create a statement that will print a message when we enter the method |
|      | create a statement that will print a message when we exit the method |
|      | get the method body, which in this case is a `BlockStatement` |
|      | add the enter method message before the first statement of existing code |
|      | append the exit method message after the last statement of existing code |
|      | creates an `ExpressionStatement` wrapping a `MethodCallExpression` corresponding to `this.println("message")` |

###### AST API guide

AbstractASTTransformation

While you have seen that you can directly implement the `ASTTransformation` interface, in almost all cases you will not do this but extend the [org.codehaus.groovy.transform.AbstractASTTransformation](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/transform/AbstractASTTransformation.html) class. This class provides several utility methods that make AST transformations easier to write. Almost all AST transformations included in Groovy extend this class.

ClassCodeExpressionTransformer

It is a common use case to be able to transform an expression into another. Groovy provides a class which makes it very easy to do this: [org.codehaus.groovy.ast.ClassCodeExpressionTransformer](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/ast/ClassCodeExpressionTransformer.html)

To illustrate this, let’s create a `@Shout` transformation that will transform all `String` constants in method call arguments into their uppercase version. For example:

```groovy
@Shout
def greet() {
    println "Hello World"
}

greet()
```

should print:

```
HELLO WORLD
```

Then the code for the transformation can use the `ClassCodeExpressionTransformer` to make this easier:

```groovy
@CompileStatic
@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)
class ShoutASTTransformation implements ASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit sourceUnit) {
        ClassCodeExpressionTransformer trn = new ClassCodeExpressionTransformer() {         
            private boolean inArgList = false
            @Override
            protected SourceUnit getSourceUnit() {
                sourceUnit                                                                  
            }

            @Override
            Expression transform(final Expression exp) {
                if (exp instanceof ArgumentListExpression) {
                    inArgList = true
                } else if (inArgList &&
                    exp instanceof ConstantExpression && exp.value instanceof String) {
                    return new ConstantExpression(exp.value.toUpperCase())                  
                }
                def trn = super.transform(exp)
                inArgList = false
                trn
            }
        }
        trn.visitMethod((MethodNode)nodes[1])                                               
    }
}
```

|      | Internally the transformation creates a `ClassCodeExpressionTransformer` |
| ---- | ------------------------------------------------------------ |
|      | The transformer needs to return the source unit              |
|      | if a constant expression of type string is detected inside an argument list, transform it into its upper case version |
|      | call the transformer on the method being annotated           |

AST Nodes

|      | Writing an AST transformation requires a deep knowledge of the internal Groovy API. In particular it requires knowledge about the AST classes. Since those classes are internal, there are chances that the API will change in the future, meaning that your transformations *could* break. Despite that warning, the AST has been very stable over time and such a thing rarely happens. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Classes of the Abstract Syntax Tree belong to the `org.codehaus.groovy.ast` package. It is recommended to the reader to use the Groovy Console, in particular the AST browser tool, to gain knowledge about those classes. However, a good resource for learning is the [AST Builder](https://github.com/apache/groovy/tree/master/src/test/org/codehaus/groovy/ast/builder) test suite.

###### Macros

Introduction

Until version 2.5.0, when developing AST transformations, developers should have a deep knowledge about how the AST (Abstract Syntax Tree) was built by the compiler in order to know how to add new expressions or statements during compile time.

Although the use of `org.codehaus.groovy.ast.tool.GeneralUtils` static methods could mitigate the burden of creating expressions and statements, it’s still a low-level way of writing those AST nodes directly. We needed something to abstract us from writing the AST directly and that’s exactly what Groovy macros were made for. They allow you to directly add code during compilation, without having to translate the code you had in mind to the `org.codehaus.groovy.ast.*` node related classes.

Statements and expressions

Let’s see an example, lets create a local AST transformation: `@AddMessageMethod`. When applied to a given class it will add a new method called `getMessage` to that class. The method will return "42". The annotation is pretty straight forward:

```groovy
@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.TYPE])
@GroovyASTTransformationClass(["metaprogramming.AddMethodASTTransformation"])
@interface AddMethod { }
```

What would the AST transformation look like without the use of a macro ? Something like this:

```groovy
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddMethodASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]

        ReturnStatement code =
                new ReturnStatement(                              
                        new ConstantExpression("42"))             

        MethodNode methodNode =
                new MethodNode(
                        "getMessage",
                        ACC_PUBLIC,
                        ClassHelper.make(String),
                        [] as Parameter[],
                        [] as ClassNode[],
                        code)                                     

        classNode.addMethod(methodNode)                           
    }
}
```

|      | Create a return statement                    |
| ---- | -------------------------------------------- |
|      | Create a constant expression "42"            |
|      | Adding the code to the new method            |
|      | Adding the new method to the annotated class |

If you’re not used to the AST API, that definitely doesn’t look like the code you had in mind. Now look how the previous code simplifies with the use of macros.

```groovy
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddMethodWithMacrosASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]

        ReturnStatement simplestCode = macro { return "42" }   

        MethodNode methodNode =
                new MethodNode(
                        "getMessage",
                        ACC_PUBLIC,
                        ClassHelper.make(String),
                        [] as Parameter[],
                        [] as ClassNode[],
                        simplestCode)                          

        classNode.addMethod(methodNode)                        
    }
}
```

|      | Much simpler. You wanted to add a return statement that returned "42" and that’s exactly what you can read inside the `macro` utility method. Your plain code will be translated for you to a `org.codehaus.groovy.ast.stmt.ReturnStatement` |
| ---- | ------------------------------------------------------------ |
|      | Adding the return statement to the new method                |
|      | Adding the new code to the annotated class                   |

Although the `macro` method is used in this example to create a **statement** the `macro` method could also be used to create **expressions** as well, it depends on which `macro` signature you use:

- `macro(Closure)`: Create a given statement with the code inside the closure.
- `macro(Boolean,Closure)`: if **true** wrap expressions inside the closure inside an statement, if **false** then return an expression
- `macro(CompilePhase, Closure)`: Create a given statement with the code inside the closure in a specific compile phase
- `macro(CompilePhase, Boolean, Closure)`: Create an statement or an expression (true == statement, false == expression) in a specific compilation phase.

|      | All these signatures can be found at `org.codehaus.groovy.macro.runtime.MacroGroovyMethods` |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Sometimes we could be only interested in creating a given expression, not the whole statement, in order to do that we should use any of the `macro` invocations with a boolean parameter:

```groovy
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class AddGetTwoASTTransformation extends AbstractASTTransformation {

    BinaryExpression onePlusOne() {
        return macro(false) { 1 + 1 }                                      
    }

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = nodes[1]
        BinaryExpression expression = onePlusOne()                         
        ReturnStatement returnStatement = GeneralUtils.returnS(expression) 

        MethodNode methodNode =
                new MethodNode("getTwo",
                        ACC_PUBLIC,
                        ClassHelper.Integer_TYPE,
                        [] as Parameter[],
                        [] as ClassNode[],
                        returnStatement                                    
                )

        classNode.addMethod(methodNode)                                    
    }
}
```

|      | We’re telling macro not to wrap the expression in a statement, we’re only interested in the expression |
| ---- | ------------------------------------------------------------ |
|      | Assigning the expression                                     |
|      | Creating a `ReturnStatement` using a method from `GeneralUtils` and returning the expression |
|      | Adding the code to the new method                            |
|      | Adding the method to the class                               |

Variable substitution

Macros are great but we can’t create anything useful or reusable if our macros couldn’t receive parameters or resolve surrounding variables.

In the following example we’re creating an AST transformation `@MD5` that when applied to a given String field will add a method returning the MD5 value of that field.

```groovy
@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.FIELD])
@GroovyASTTransformationClass(["metaprogramming.MD5ASTTransformation"])
@interface MD5 { }
```

And the transformation:

```groovy
@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
class MD5ASTTransformation extends AbstractASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        FieldNode fieldNode = nodes[1]
        ClassNode classNode = fieldNode.declaringClass
        String capitalizedName = fieldNode.name.capitalize()
        MethodNode methodNode = new MethodNode(
                "get${capitalizedName}MD5",
                ACC_PUBLIC,
                ClassHelper.STRING_TYPE,
                [] as Parameter[],
                [] as ClassNode[],
                buildMD5MethodCode(fieldNode))

        classNode.addMethod(methodNode)
    }

    BlockStatement buildMD5MethodCode(FieldNode fieldNode) {
        VariableExpression fieldVar = GeneralUtils.varX(fieldNode.name) 

        return macro(CompilePhase.SEMANTIC_ANALYSIS, true) {            
            return java.security.MessageDigest
                    .getInstance('MD5')
                    .digest($v { fieldVar }.getBytes())                 
                    .encodeHex()
                    .toString()
        }
    }
}
```

|      | We need a reference to a variable expression                 |
| ---- | ------------------------------------------------------------ |
|      | If using a class outside the standard packages we should add any needed imports or use the qualified name. When using the qualified named of a given static method you need to make sure it’s resolved in the proper compile phase. In this particular case we’re instructing the macro to resolve it at the SEMANTIC_ANALYSIS phase, which is the first compile phase with type information. |
|      | In order to substitute any `expression` inside the macro we need to use the `$v` method. `$v` receives a closure as an argument, and the closure is only allowed to substitute expressions, meaning classes inheriting `org.codehaus.groovy.ast.expr.Expression`. |

MacroClass

As we mentioned earlier, the `macro` method is only capable of producing `statements` and `expressions`. But what if we want to produce other types of nodes, such as a method, a field and so on?

`org.codehaus.groovy.macro.transform.MacroClass` can be used to create **classes** (ClassNode instances) in our transformations the same way we created statements and expressions with the `macro` method before.

The next example is a local transformation `@Statistics`. When applied to a given class, it will add two methods **getMethodCount()** and **getFieldCount()** which return how many methods and fields within the class respectively. Here is the marker annotation.

```groovy
@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.TYPE])
@GroovyASTTransformationClass(["metaprogramming.StatisticsASTTransformation"])
@interface Statistics {}
```

And the AST transformation:

```groovy
@CompileStatic
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class StatisticsASTTransformation extends AbstractASTTransformation {

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]
        ClassNode templateClass = buildTemplateClass(classNode)  

        templateClass.methods.each { MethodNode node ->          
            classNode.addMethod(node)
        }
    }

    @CompileDynamic
    ClassNode buildTemplateClass(ClassNode reference) {          
        def methodCount = constX(reference.methods.size())       
        def fieldCount = constX(reference.fields.size())         

        return new MacroClass() {
            class Statistics {
                java.lang.Integer getMethodCount() {             
                    return $v { methodCount }
                }

                java.lang.Integer getFieldCount() {              
                    return $v { fieldCount }
                }
            }
        }
    }
}
```

|      | Creating a template class                                    |
| ---- | ------------------------------------------------------------ |
|      | Adding template class methods to the annotated class         |
|      | Passing the reference class                                  |
|      | Extracting reference class method count value expression     |
|      | Extracting reference class field count value expression      |
|      | Building the **getMethodCount()** method using reference’s method count value expression |
|      | Building the **getFieldCount()** method using reference’s field count value expression |

Basically we’ve created the **Statistics** class as a template to avoid writing low level AST API, then we copied methods created in the template class to their final destination.

|      | Types inside the `MacroClass` implementation should be resolved inside, that’s why we had to write `java.lang.Integer` instead of simply writing `Integer`. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

|      | Notice that we’re using `@CompileDynamic`. That’s because the way we use `MacroClass` is like we were actually implementing it. So if you were using `@CompileStatic` it will complain because an implementation of an abstract class can’t be another different class. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

@Macro methods

You have seen that by using `macro` you can save yourself a lot of work but you might wonder where that method came from. You didn’t declare it or static import it. You can think of it as a special global method (or if you prefer, a method on every `Object`). This is much like how the `println` extension method is defined. But unlike `println` which becomes a method selected for execution later in the compilation process, `macro` expansion is done early in the compilation process. The declaration of `macro` as one of the available methods for this early expansion is done by annotating a `macro` method definition with the `@Macro` annotation and making that method available using a similar mechanism for extension modules. Such methods are known as *macro* methods and the good news is you can define your own.

To define your own macro method, create a class in a similar way to an extension module and add a method such as:

```groovy
public class ExampleMacroMethods {

    @Macro
    public static Expression safe(MacroContext macroContext, MethodCallExpression callExpression) {
        return ternaryX(
                notNullX(callExpression.getObjectExpression()),
                callExpression,
                constX(null)
        );
    }
    ...
}
```

Now you would register this as an extension module using a `org.codehaus.groovy.runtime.ExtensionModule` file within the `META-INF/groovy` directory.

Now, assuming that the class and meta info file are on your classpath, you can use the macro method in the following way:

```groovy
def nullObject = null
assert null == safe(safe(nullObject.hashcode()).toString())
```

###### Testing AST transformations

Separating source trees

This section is about good practices with regards to testing AST transformations. Previous sections highlighted the fact that to be able to execute an AST transformation, it has to be precompiled. It might sound obvious but a lot of people get caught on this, trying to use an AST transformation in the same source tree as where it is defined.

The first tip for testing AST transformation is therefore to separate test sources from the sources of the transform. Again, this is nothing but best practices, but you must make sure that your build too does actually compile them separately. This is the case by default with both [Apache Maven](http://maven.apache.org/) and [Gradle](http://gradle.org/).

Debugging AST transformations

It is very handy to be able to put a breakpoint in an AST transformation, so that you can debug your code in the IDE. However, you might be surprised to see that your IDE doesn’t stop on the breakpoint. The reason is actually simple: if your IDE uses the Groovy compiler to compile the unit tests for your AST transformation, then the compilation is triggered from the IDE, but the process which will compile the files doesn’t have debugging options. It’s only when the test case is executed that the debugging options are set on the virtual machine. In short: it is too late, the class has been compiled already, and your transformation is already applied.

A very easy workaround is to use the `GroovyTestCase` class which provides an `assertScript` method. This means that instead of writing this in a test case:

```groovy
static class Subject {
    @MyTransformToDebug
    void methodToBeTested() {}
}

void testMyTransform() {
    def c = new Subject()
    c.methodToBeTested()
}
```

You should write:

```groovy
void testMyTransformWithBreakpoint() {
    assertScript '''
        import metaprogramming.MyTransformToDebug

        class Subject {
            @MyTransformToDebug
            void methodToBeTested() {}
        }
        def c = new Subject()
        c.methodToBeTested()
    '''
}
```

The difference is that when you use `assertScript`, the code in the `assertScript` block is compiled **when the unit test is executed**. That is to say that this time, the `Subject` class will be compiled with debugging active, and the breakpoint is going to be hit.

ASTMatcher

Sometimes you may want to make assertions over AST nodes; perhaps to filter the nodes, or to make sure a given transformation has built the expected AST node.

**Filtering nodes**

For instance if you would like to apply a given transformation only to a specific set of AST nodes, you could use **ASTMatcher** to filter these nodes. The following example shows how to transform a given expression to another. Using **ASTMatcher** it looks for a specific expression `1 + 1` and it transforms it to `3`. That’s why we called it the `@Joking` example.

First we create the `@Joking` annotation that only can be applied to methods:

```groovy
@Retention(RetentionPolicy.SOURCE)
@Target([ElementType.METHOD])
@GroovyASTTransformationClass(["metaprogramming.JokingASTTransformation"])
@interface Joking { }
```

Then the transformation, that only applies an instance of `org.codehaus.groovy.ast.ClassCodeExpressionTransformer` to all the expressions within the method code block.

```groovy
@CompileStatic
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class JokingASTTransformation extends AbstractASTTransformation {
    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        MethodNode methodNode = (MethodNode) nodes[1]

        methodNode
            .getCode()
            .visit(new ConvertOnePlusOneToThree(source))  
    }
}
```

|      | Get the method’s code statement and apply the expression transformer |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

And this is when the **ASTMatcher** is used to apply the transformation only to those expressions matching the expression `1 + 1`.

```groovy
class ConvertOnePlusOneToThree extends ClassCodeExpressionTransformer {
    SourceUnit sourceUnit

    ConvertOnePlusOneToThree(SourceUnit sourceUnit) {
        this.sourceUnit = sourceUnit
    }

    @Override
    Expression transform(Expression exp) {
        Expression ref = macro { 1 + 1 }     

        if (ASTMatcher.matches(ref, exp)) {  
            return macro { 3 }               
        }

        return super.transform(exp)
    }
}
```

|      | Builds the expression used as reference pattern              |
| ---- | ------------------------------------------------------------ |
|      | Checks the current expression evaluated matches the reference expression |
|      | If it matches then replaces the current expression with the expression built with `macro` |

Then you could test the implementation as follows:

```groovy
package metaprogramming

class Something {
    @Joking
    Integer getResult() {
        return 1 + 1
    }
}

assert new Something().result == 3
```

**Unit testing AST transforms**

Normally we test AST transformations just checking that the final use of the transformation does what we expect. But it would be great if we could have an easy way to check, for example, that the nodes the transformation adds are what we expected from the beginning.

The following transformation adds a new method `giveMeTwo` to an annotated class.

```groovy
@GroovyASTTransformation(phase = CompilePhase.INSTRUCTION_SELECTION)
class TwiceASTTransformation extends AbstractASTTransformation {

    static final String VAR_X = 'x'

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode classNode = (ClassNode) nodes[1]
        MethodNode giveMeTwo = getTemplateClass(sumExpression)
            .getDeclaredMethods('giveMeTwo')
            .first()

        classNode.addMethod(giveMeTwo)                  
    }

    BinaryExpression getSumExpression() {               
        return macro {
            $v{ varX(VAR_X) } +
            $v{ varX(VAR_X) }
        }
    }

    ClassNode getTemplateClass(Expression expression) { 
        return new MacroClass() {
            class Template {
                java.lang.Integer giveMeTwo(java.lang.Integer x) {
                    return $v { expression }
                }
            }
        }
    }
}
```

|      | Adding the method to the annotated class                     |
| ---- | ------------------------------------------------------------ |
|      | Building a binary expression. The binary expression uses the same variable expression in both sides of the `+` token (check `varX` method at **org.codehaus.groovy.ast.tool.GeneralUtils**). |
|      | Builds a new **ClassNode** with a method called `giveMeTwo` which returns the result of an expression passed as parameter. |

Now instead of creating a test executing the transformation over a given sample code. I would like to check that the construction of the binary expression is done properly:

```groovy
void testTestingSumExpression() {
    use(ASTMatcher) {                 
        TwiceASTTransformation sample = new TwiceASTTransformation()
        Expression referenceNode = macro {
            a + a                     
        }.withConstraints {           
            placeholder 'a'           
        }

        assert sample
            .sumExpression
            .matches(referenceNode)   
    }
}
```

|      | Using ASTMatcher as a category                    |
| ---- | ------------------------------------------------- |
|      | Build a template node                             |
|      | Apply some constraints to that template node      |
|      | Tells compiler that `a` is a placeholder.         |
|      | Asserts reference node and current node are equal |

Of course you can/should always check the actual execution:

```groovy
void testASTBehavior() {
    assertScript '''
    package metaprogramming

    @Twice
    class AAA {

    }

    assert new AAA().giveMeTwo(1) == 2
    '''
}
```

ASTTest

Last but not least, testing an AST transformation is also about testing the state of the AST **during compilation**. Groovy provides a tool named `@ASTTest` for this: it is an annotation that will let you add assertions on an abstract syntax tree. Please check the [documentation for ASTTest](https://docs.groovy-lang.org/latest/html/documentation/#xform-ASTTest) for more details.

###### External references

If you are interested in a step-by-step tutorial about writing AST transformations, you can follow [this workshop](http://melix.github.io/ast-workshop/).

### 3.5. Dependency management with Grape

#### 3.5.1. Quick start

##### Add a Dependency

Grape is a JAR dependency manager embedded into Groovy. Grape lets you quickly add maven repository dependencies to your classpath, making scripting even easier. The simplest use is as simple as adding an annotation to your script:

```groovy
@Grab(group='org.springframework', module='spring-orm', version='3.2.5.RELEASE')
import org.springframework.jdbc.core.JdbcTemplate
```

`@Grab` also supports a shorthand notation:

```groovy
@Grab('org.springframework:spring-orm:3.2.5.RELEASE')
import org.springframework.jdbc.core.JdbcTemplate
```

Note that we are using an annotated import here, which is the recommended way. You can also search for dependencies on [mvnrepository.com](http://mvnrepository.com/) and it will provide you the `@Grab` annotation form of the `pom.xml` entry.

##### Specify Additional Repositories

Not all dependencies are in maven central. You can add new ones like this:

```groovy
@GrabResolver(name='restlet', root='http://maven.restlet.org/')
@Grab(group='org.restlet', module='org.restlet', version='1.1.6')
```

##### Maven Classifiers

Some maven dependencies need classifiers in order to be able to resolve. You can fix that like this:

```groovy
@Grab(group='net.sf.json-lib', module='json-lib', version='2.2.3', classifier='jdk15')
```

##### Excluding Transitive Dependencies

Sometimes you will want to exclude transitive dependencies as you might be already using a slightly different but compatible version of some artifact. You can do this as follows:

```groovy
@Grab('net.sourceforge.htmlunit:htmlunit:2.8')
@GrabExclude('xml-apis:xml-apis')
```

##### JDBC Drivers

Because of the way JDBC drivers are loaded, you’ll need to configure Grape to attach JDBC driver dependencies to the system class loader. I.e:

```groovy
@GrabConfig(systemClassLoader=true)
@Grab(group='mysql', module='mysql-connector-java', version='5.1.6')
```

##### Using Grape From the Groovy Shell

From groovysh use the method call variant:

```groovy
groovy.grape.Grape.grab(group:'org.springframework', module:'spring', version:'2.5.6')
```

##### Proxy settings

If you are behind a firewall and/or need to use Groovy/Grape through a proxy server, you can specify those settings on the command like via the `http.proxyHost` and `http.proxyPort` system properties:

```
groovy -Dhttp.proxyHost=yourproxy -Dhttp.proxyPort=8080 yourscript.groovy
```

Or you can make this system wide by adding these properties to your JAVA_OPTS environment variable:

```
JAVA_OPTS = -Dhttp.proxyHost=yourproxy -Dhttp.proxyPort=8080
```

##### Logging

If you want to see what Grape is doing set the system property `groovy.grape.report.downloads` to `true` (e.g. add `-Dgroovy.grape.report.downloads=true` to invocation or JAVA_OPTS) and Grape will print the following infos to System.error:

- Starting resolve of a dependency
- Starting download of an artifact
- Retrying download of an artifact
- Download size and time for downloaded artifacts

To log with even more verbosity, increase the Ivy log level (defaults to `-1`). For example `-Divy.message.logger.level=4`.

#### 3.5.2. Detail

Grape (The *Groovy Adaptable Packaging Engine* or *Groovy Advanced Packaging Engine*) is the infrastructure enabling the grab() calls in Groovy, a set of classes leveraging [Ivy](http://ant.apache.org/ivy/) to allow for a repository driven module system for Groovy. This allows a developer to write a script with an essentially arbitrary library requirement, and ship just the script. Grape will, at runtime, download as needed and link the named libraries and all dependencies forming a transitive closure when the script is run from existing repositories such as JCenter, Ibiblio and java.net.

Grape follows the Ivy conventions for module version identification, with naming change.

- `group` - Which module group the module comes from. Translates directly to a Maven groupId or an Ivy Organization. Any group matching `/groovy[x][\..*]^/` is reserved and may have special meaning to the groovy endorsed modules.
- `module` - The name of the module to load. Translated directly to a Maven artifactId or an Ivy artifact.
- `version` - The version of the module to use. Either a literal version `1.1-RC3' or an Ivy Range `[2.2.1,)' meaning 2.2.1 or any greater version).
- `classifier` - The optional classifier to use (for example, *jdk15*)

The downloaded modules will be stored according to Ivy’s standard mechanism with a cache root of `~/.groovy/grapes`

#### 3.5.3. Usage

##### Annotation

One or more `groovy.lang.Grab` annotations can be added at any place that annotations are accepted to tell the compiler that this code relies on the specific library. This will have the effect of adding the library to the classloader of the groovy compiler. This annotation is detected and evaluated before any other resolution of classes in the script, so imported classes can be properly resolved by a `@Grab` annotation.

```groovy
import com.jidesoft.swing.JideSplitButton
@Grab(group='com.jidesoft', module='jide-oss', version='[2.2.1,2.3.0)')
public class TestClassAnnotation {
    public static String testMethod () {
        return JideSplitButton.class.name
    }
}
```

An appropriate `grab(…)` call will be added to the static initializer of the class of the containing class (or script class in the case of an annotated script element).

##### Multiple Grape Annotations

In early versions of Groovy, if you wanted to use a Grab annotation multiple times on the same node you had to use the `@Grapes` annotation, e.g.:

```groovy
@Grapes([
   @Grab(group='commons-primitives', module='commons-primitives', version='1.0'),
   @Grab(group='org.ccil.cowan.tagsoup', module='tagsoup', version='0.9.7')])
class Example {
// ...
}
```

Otherwise you’d encounter the following error:

```
Cannot specify duplicate annotation on the same member
```

But in recent versions, @Grapes is purely optional.

Technical notes:

- Originally, Groovy stored the Grab annotations for access at runtime and duplicates aren’t allowed in the bytecode. In current versions, @Grab has only SOURCE retention, so the multiple occurrences aren’t an issue.
- Future versions of Grape may support using the Grapes annotation to provide a level of structuring, e.g. allowing a GrabExclude or GrabResolver annotation to apply to only a subset of the Grab annotations.

##### Method call

Typically a call to grab will occur early in the script or in class initialization. This is to insure that the libraries are made available to the ClassLoader before the groovy code relies on the code. A couple of typical calls may appear as follows:

```groovy
import groovy.grape.Grape
// random maven library
Grape.grab(group:'com.jidesoft', module:'jide-oss', version:'[2.2.0,)')
Grape.grab([group:'org.apache.ivy', module:'ivy', version:'2.0.0-beta1', conf:['default', 'optional']],
     [group:'org.apache.ant', module:'ant', version:'1.7.0'])
```

- Multiple calls to grab in the same context with the same parameters should be idempotent. However, if the same code is called with a different `ClassLoader` context then resolution may be re-run.
- If the `args` map passed into the `grab` call has an attribute `noExceptions` that evaluates true no exceptions will be thrown.
- `grab` requires that a `RootLoader` or `GroovyClassLoader` be specified or be in the `ClassLoader` chain of the calling class. By default failure to have such a `ClassLoader` available will result in module resolution and an exception being thrown
  - The ClassLoader passed in via the `classLoader:` argument and it’s parent classloaders.
  - The ClassLoader of the object passed in as the `referenceObject:` argument, and it’s parent classloaders.
  - The ClassLoader of the class issuing the call to `grab`

###### grab(HashMap) Parameters

- `group:` - <String> - Which module group the module comes from. Translates directly to a Maven groupId. Any group matching `/groovy(|\..|x|x\..)/` is reserved and may have special meaning to the groovy endorsed modules.
- `module:` - <String> - The name of the module to load. Translated directly to a Maven artifactId.
- `version:` - <String> and possibly <Range> - The version of the module to use. Either a literal version `1.1-RC3' or an Ivy Range `[2.2.1,)' meaning 2.2.1 or any greater version).
- `classifier:` - <String> - The Maven classifier to resolve by.
- `conf:` - <String>, default `default' - The configuration or scope of the module to download. The default conf is `default:` which maps to the maven `runtime` and `master` scopes.
- `force:`- <boolean>, defaults true - Used to indicate that this revision must be used in case of conflicts, independently of
- conflicts manager
- `changing:` - <boolean>, default false - Whether the artifact can change without it’s version designation changing.
- `transitive:` - <boolean>, default true - Whether to resolve other dependencies this module has or not.

There are two principal variants of `grab`, one with a single Map and one with an arguments Map and multiple dependencies map. A call to the single map grab is the same as calling grab with the same map passed in twice, so grab arguments and dependencies can be mixed in the same map, and grab can be called as a single method with named parameters.

There are synonyms for these parameters. Submitting more than one is a runtime exception.

- `group:`, `groupId:`, `organisation:`, `organization:`, `org:`
- `module:`, `artifactId:`, `artifact:`
- `version:`, `revision:`, `rev:`
- `conf:`, `scope:`, `configuration:`

###### Arguments Map arguments

- `classLoader:` - <GroovyClassLaoder> or <RootClassLoader> - The ClassLoader to add resolved Jars to
- `refObject:` - <Object> - The closest parent ClassLoader for the object’s class will be treated as though it were passed in as `classLoader:`
- `validate:` - <boolean>, default false - Should poms or ivy files be validated (true), or should we trust the cache (false).
- `noExceptions:` - <boolean>, default false - If ClassLoader resolution or repository querying fails, should we throw an exception (false) or fail silently (true).

##### Command Line Tool

Grape added a command line executable `grape' that allows for the inspection and management of the local grape cache.

```
grape install [-hv] <group> <module> [<version>] [<classifier>]
```

This installs the specified groovy module or maven artifact. If a version is specified that specific version will be installed, otherwise the most recent version will be used (as if `*' we passed in).

```
grape list
```

Lists locally installed modules (with their full maven name in the case of groovy modules) and versions.

```
grape resolve [-adhisv] (<groupId> <artifactId> <version>)+
```

This returns the file locations of the jars representing the artifacts for the specified module(s) and the respective transitive dependencies. You may optionally pass in -ant, -dos, or -shell to get the dependencies expressed in a format applicable for an ant script, windows batch file, or unix shell script respectively. -ivy may be passed to see the dependencies expressed in an ivy like format.

```
grape uninstall [-hv] <group> <module> <version>
```

This uninstalls a particular grape: it non-transitively removes the respective jar file from the grape cache.

##### Advanced configuration

###### Repository Directory

If you need to change the directory grape uses for downloading libraries you can specify the grape.root system property to change the default (which is ~/.groovy/grapes)

```
groovy -Dgrape.root=/repo/grapes yourscript.groovy
```

###### Customize Ivy settings

You can customize the ivy settings that Grape uses by creating a ~/.groovy/grapeConfig.xml file. If no such file exists, [here](https://github.com/apache/groovy/blob/master/src/resources/groovy/grape/defaultGrapeConfig.xml) are the default settings used by Grape.

For more information on how to customize these settings, please refer to the [Ivy documentation](https://ant.apache.org/ivy/history/latest-milestone/index.html).

##### More Examples

Using Apache Commons Collections:

```groovy
// create and use a primitive array list
@Grab(group='commons-primitives', module='commons-primitives', version='1.0')
import org.apache.commons.collections.primitives.ArrayIntList

def createEmptyInts() { new ArrayIntList() }

def ints = createEmptyInts()
ints.add(0, 42)
assert ints.size() == 1
assert ints.get(0) == 42
```

Using TagSoup:

```groovy
// find the PDF links of the Java specifications
@Grab(group='org.ccil.cowan.tagsoup', module='tagsoup', version='1.2.1')
def getHtml() {
    def parser = new XmlParser(new org.ccil.cowan.tagsoup.Parser())
    parser.parse("https://docs.oracle.com/javase/specs/")
}
html.body.'**'.a.@href.grep(~/.*\.pdf/).each{ println it }
```

Using Google Collections:

```groovy
import com.google.common.collect.HashBiMap
@Grab(group='com.google.code.google-collections', module='google-collect', version='snapshot-20080530')
def getFruit() { [grape:'purple', lemon:'yellow', orange:'orange'] as HashBiMap }
assert fruit.lemon == 'yellow'
assert fruit.inverse().yellow == 'lemon'
```

Launching a Jetty server to serve Groovy templates:

```groovy
@Grab('org.eclipse.jetty.aggregate:jetty-server:8.1.19.v20160209')
@Grab('org.eclipse.jetty.aggregate:jetty-servlet:8.1.19.v20160209')
@Grab('javax.servlet:javax.servlet-api:3.0.1')
import org.eclipse.jetty.server.Server
import org.eclipse.jetty.servlet.ServletContextHandler
import groovy.servlet.TemplateServlet

def runServer(duration) {
    def server = new Server(8080)
    def context = new ServletContextHandler(server, "/", ServletContextHandler.SESSIONS)
    context.resourceBase = "."
    context.addServlet(TemplateServlet, "*.gsp")
    server.start()
    sleep duration
    server.stop()
}

runServer(10000)
```

Grape will download Jetty and its dependencies on first launch of this script, and cache them. We create a new Jetty Server on port 8080, then expose Groovy’s TemplateServlet at the root of the context — Groovy comes with its own powerful template engine mechanism. We start the server and let it run for a certain duration. Each time someone will hit http://localhost:8080/somepage.gsp, it will display the somepage.gsp template to the user — those template pages should be situated in the same directory as this server script.

### 3.6. Testing Guide

#### 3.6.1. Introduction

The Groovy programming language comes with great support for writing tests. In addition to the language features and test integration with state-of-the-art testing libraries and frameworks, the Groovy ecosystem has born a rich set of testing libraries and frameworks.

This chapter will start with language specific testing features and continue with a closer look at JUnit integration, Spock for specifications, and Geb for functional tests. Finally, we’ll do an overview of other testing libraries known to be working with Groovy.

#### 3.6.2. Language Features

Besides integrated support for JUnit, the Groovy programming language comes with features that have proven to be very valuable for test-driven development. This section gives insight on them.

##### Power Assertions

Writing tests means formulating assumptions by using assertions. In Java this can be done by using the `assert` keyword that has been added in J2SE 1.4. In Java, `assert` statements can be enabled via the JVM parameters `-ea` (or `-enableassertions`) and `-da` (or `-disableassertions`). Assertion statements in Java are disabled by default.

Groovy comes with a rather *powerful variant* of `assert` also known as *power assertion statement*. Groovy’s power `assert` differs from the Java version in its output given the boolean expression validates to `false`:

```groovy
def x = 1
assert x == 2

// Output:             
//
// Assertion failed:
// assert x == 2
//        | |
//        1 false
```

|      | This section shows the std-err output |
| ---- | ------------------------------------- |
|      |                                       |

The `java.lang.AssertionError` that is thrown whenever the assertion can not be validated successfully, contains an extended version of the original exception message. The power assertion output shows evaluation results from the outer to the inner expression.

The power assertion statements true power unleashes in complex Boolean statements, or statements with collections or other `toString`-enabled classes:

```groovy
def x = [1,2,3,4,5]
assert (x << 6) == [6,7,8,9,10]

// Output:
//
// Assertion failed:
// assert (x << 6) == [6,7,8,9,10]
//         | |     |
//         | |     false
//         | [1, 2, 3, 4, 5, 6]
//         [1, 2, 3, 4, 5, 6]
```

Another important difference from Java is that in Groovy assertions are *enabled by default*. It has been a language design decision to remove the possibility to deactivate assertions. Or, as Bertrand Meyer stated, `it makes no sense to take off your swim ring if you put your feet into real water`.

One thing to be aware of are methods with side-effects inside Boolean expressions in power assertion statements. As the internal error message construction mechanism does only store references to instances under target, it happens that the error message text is invalid at rendering time in case of side-effecting methods involved:

```groovy
assert [[1,2,3,3,3,3,4]].first().unique() == [1,2,3]

// Output:
//
// Assertion failed:
// assert [[1,2,3,3,3,3,4]].first().unique() == [1,2,3]
//                          |       |        |
//                          |       |        false
//                          |       [1, 2, 3, 4]
//                          [1, 2, 3, 4]           
```

|      | The error message shows the actual state of the collection, not the state before the `unique` method was applied |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

|      | If you choose to provide a custom assertion error message this can be done by using the Java syntax `assert expression1 : expression2` where `expression1` is the Boolean expression and `expression2` is the custom error message. Be aware though that this will disable the power assert and will fully fallback to custom error messages on assertion errors. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Mocking and Stubbing

Groovy has excellent built-in support for a range of mocking and stubbing alternatives. When using Java, dynamic mocking frameworks are very popular. A key reason for this is that it is hard work creating custom hand-crafted mocks using Java. Such frameworks can be used easily with Groovy if you choose but creating custom mocks is much easier in Groovy. You can often get away with simple maps or closures to build your custom mocks.

The following sections show ways to create mocks and stubs with Groovy language features only.

###### Map Coercion

By using maps or expandos, we can incorporate desired behaviour of a collaborator very easily as shown here:

```groovy
class TranslationService {
    String convert(String key) {
        return "test"
    }
}

def service = [convert: { String key -> 'some text' }] as TranslationService
assert 'some text' == service.convert('key.text')
```

The `as` operator can be used to coerce a map to a particular class. The given map keys are interpreted as method names and the values, being `groovy.lang.Closure` blocks, are interpreted as method code blocks.

|      | Be aware that map coercion can get into the way if you deal with custom `java.util.Map` descendant classes in combination with the `as` operator. The map coercion mechanism is targeted directly at certain collection classes, it doesn’t take custom classes into account. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Closure Coercion

The 'as' operator can be used with closures in a neat way which is great for developer testing in simple scenarios. We haven’t found this technique to be so powerful that we want to do away with dynamic mocking, but it can be very useful in simple cases none-the-less.

Classes or interfaces holding a single method, including SAM (single abstract method) classes, can be used to coerce a closure block to be an object of the given type. Be aware that for doing this, Groovy internally create a proxy object descending for the given class. So the object will not be a direct instance of the given class. This important if, for example, the generated proxy object’s meta-class is altered afterwards.

Let’s have an example on coercing a closure to be of a specific type:

```groovy
def service = { String key -> 'some text' } as TranslationService
assert 'some text' == service.convert('key.text')
```

Groovy supports a feature called implicit SAM coercion. This means that the `as` operator is not necessary in situations where the runtime can infer the target SAM type. This type of coercion might be useful in tests to mock entire SAM classes:

```groovy
abstract class BaseService {
    abstract void doSomething()
}

BaseService service = { -> println 'doing something' }
service.doSomething()
```

###### MockFor and StubFor

The Groovy mocking and stubbing classes can be found in the `groovy.mock.interceptor` package.

The `MockFor` class supports (typically unit) testing of classes in isolation by allowing a *strictly ordered* expectation of the behavior of collaborators to be defined. A typical test scenario involves a class under test and one or more collaborators. In such a scenario it is often desirable to just test the business logic of the class under test. One strategy for doing that is to replace the collaborator instances with simplified mock objects to help isolate out the logic in the test target. MockFor allows such mocks to be created using meta-programming. The desired behavior of collaborators is defined as a behavior specification. The behavior is enforced and checked automatically.

Let’s assume our target classes looked like this:

```groovy
class Person {
    String first, last
}

class Family {
    Person father, mother
    def nameOfMother() { "$mother.first $mother.last" }
}
```

With `MockFor`, a mock expectation is always sequence dependent and its use automatically ends with a call to `verify`:

```groovy
def mock = new MockFor(Person)      
mock.demand.getFirst{ 'dummy' }
mock.demand.getLast{ 'name' }
mock.use {                          
    def mary = new Person(first:'Mary', last:'Smith')
    def f = new Family(mother:mary)
    assert f.nameOfMother() == 'dummy name'
}
mock.expect.verify()                
```

|      | a new mock is created by a new instance of `MockFor`         |
| ---- | ------------------------------------------------------------ |
|      | a `Closure` is passed to `use` which enables the mocking functionality |
|      | a call to `verify` checks whether the sequence and number of method calls is as expected |

The `StubFor` class supports (typically unit) testing of classes in isolation by allowing a *loosely-ordered* expectation of the behavior of collaborators to be defined. A typical test scenario involves a class under test and one or more collaborators. In such a scenario it is often desirable to just test the business logic of the CUT. One strategy for doing that is to replace the collaborator instances with simplified stub objects to help isolate out the logic in the target class. `StubFor` allows such stubs to be created using meta-programming. The desired behavior of collaborators is defined as a behavior specification.

In contrast to `MockFor` the stub expectation checked with `verify` is sequence independent and its use is optional:

```groovy
def stub = new StubFor(Person)      
stub.demand.with {                  
    getLast{ 'name' }
    getFirst{ 'dummy' }
}
stub.use {                          
    def john = new Person(first:'John', last:'Smith')
    def f = new Family(father:john)
    assert f.father.first == 'dummy'
    assert f.father.last == 'name'
}
stub.expect.verify()                
```

|      | a new stub is created by a new instance of `StubFor`         |
| ---- | ------------------------------------------------------------ |
|      | the `with` method is used for delegating all calls inside the closure to the `StubFor` instance |
|      | a `Closure` is passed to `use` which enables the stubbing functionality |
|      | a call to `verify` (optional) checks whether the number of method calls is as expected |

`MockFor` and `StubFor` can not be used to test statically compiled classes e.g for Java classes or Groovy classes that make use of `@CompileStatic`. To stub and/or mock these classes you can use Spock or one of the Java mocking libraries.

###### Expando Meta-Class (EMC)

Groovy includes a special `MetaClass` the so-called `ExpandoMetaClass` (EMC). It allows to dynamically add methods, constructors, properties and static methods using a neat closure syntax.

Every `java.lang.Class` is supplied with a special `metaClass` property that will give a reference to an `ExpandoMetaClass` instance. The expando meta-class is not restricted to custom classes, it can be used for JDK classes like for example `java.lang.String` as well:

```groovy
String.metaClass.swapCase = {->
    def sb = new StringBuffer()
    delegate.each {
        sb << (Character.isUpperCase(it as char) ? Character.toLowerCase(it as char) :
            Character.toUpperCase(it as char))
    }
    sb.toString()
}

def s = "heLLo, worLD!"
assert s.swapCase() == 'HEllO, WORld!'
```

The `ExpandoMetaClass` is a rather good candidate for mocking functionality as it allows for more advanced stuff like mocking static methods

```groovy
class Book {
    String title
}

Book.metaClass.static.create << { String title -> new Book(title:title) }

def b = Book.create("The Stand")
assert b.title == 'The Stand'
```

or even constructors

```groovy
Book.metaClass.constructor << { String title -> new Book(title:title) }

def b = new Book("The Stand")
assert b.title == 'The Stand'
```

|      | Mocking constructors might seem like a hack that’s better not even to be considered but even there might be valid use cases. An example can be found in Grails where domain class constructors are added at run-time with the help of `ExpandoMetaClass`. This lets the domain object register itself in the Spring application context and allows for injection of services or other beans controlled by the dependency-injection container. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

If you want to change the `metaClass` property on a per test method level you need to remove the changes that were done to the meta-class, otherwise those changes would be persistent across test method calls. Changes are removed by replacing the meta-class in the `GroovyMetaClassRegistry`:

```groovy
GroovySystem.metaClassRegistry.setMetaClass(java.lang.String, null)
```

Another alternative is to register a `MetaClassRegistryChangeEventListener`, track the changed classes and remove the changes in the cleanup method of your chosen testing runtime. A good example can be found [in the Grails web development framework](https://github.com/grails/grails-core/blob/master/grails-bootstrap/src/main/groovy/grails/build/support/MetaClassRegistryCleaner.java).

Besides using the `ExpandoMetaClass` on a class-level, there is also support for using the meta-class on a per-object level:

```groovy
def b = new Book(title: "The Stand")
b.metaClass.getTitle {-> 'My Title' }

assert b.title == 'My Title'
```

In this case the meta-class change is related to the instance only. Depending on the test scenario this might be a better fit than the global meta-class change.

##### GDK Methods

The following section gives a brief overview on GDK methods that can be leveraged in test case scenarios, for example for test data generation.

###### Iterable#combinations

The `combinations` method that is added on `java.lang.Iterable` compliant classes can be used to get a list of combinations from a list containing two or more sub-lists:

```groovy
void testCombinations() {
    def combinations = [[2, 3],[4, 5, 6]].combinations()
    assert combinations == [[2, 4], [3, 4], [2, 5], [3, 5], [2, 6], [3, 6]]
}
```

The method could be used in test case scenarios to generate all possible argument combinations for a specific method call.

###### Iterable#eachCombination

The `eachCombination` method that is added on `java.lang.Iterable` can be used to apply a function (or in this case a `groovy.lang.Closure`) to each if the combinations that has been built by the `combinations` method:

`eachCombination` is a GDK method that is added to all classes conforming to the `java.lang.Iterable` interface. It applies a function on each combination of the input lists:

```groovy
void testEachCombination() {
    [[2, 3],[4, 5, 6]].eachCombination { println it[0] + it[1] }
}
```

The method could be used in the testing context to call methods with each of the generated combinations.

##### Tool Support

###### Test Code Coverage

Code coverage is a useful measure of the effectiveness of (unit) tests. A program with high code coverage has a lower chance to hold critical bugs than a program with no or low coverage. To get code coverage metrics, the generated byte-code usually needs to be instrumented before the tests are executed. One tool with Groovy support for this task is [Cobertura](http://cobertura.github.io/cobertura/).

Various frameworks and build tools come with Cobertura integration. For Grails, there is the [code coverage plugin](http://grails.org/plugin/code-coverage) based on Cobertura, for Gradle there is the [gradle-cobertura plugin](https://github.com/eriwen/gradle-cobertura-plugin), to name only two of them.

The following code listing shows an example on how to enable Cobertura test coverage reports in a Gradle build script from a Groovy project:

```groovy
def pluginVersion = '<plugin version>'
def groovyVersion = '<groovy version>'
def junitVersion = '<junit version>'

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.eriwen:gradle-cobertura-plugin:${pluginVersion}'
    }
}

apply plugin: 'groovy'
apply plugin: 'cobertura'

repositories {
    mavenCentral()
}

dependencies {
    compile "org.codehaus.groovy:groovy-all:${groovyVersion}"
    testCompile "junit:junit:${junitVersion}"
}

cobertura {
    format = 'html'
    includes = ['**/*.java', '**/*.groovy']
    excludes = ['com/thirdparty/**/*.*']
}
```

Several output formats can be chosen for Cobertura coverage reports and test code coverage reports can be added to continuous integration build tasks.

#### 3.6.3. Testing with JUnit

Groovy simplifies JUnit testing in the following ways:

- You use the same overall practices as you would when testing with Java but you can adopt much of Groovy’s concise syntax in your tests making them succinct. You can even use the capabilities for writing testing domain specific languages (DSLs) if you feel so inclined.
- There are numerous helper classes that simplify many testing activities. The details differ in some cases depending on the version of JUnit you are using. We’ll cover those details shortly.
- Groovy’s PowerAssert mechanism is wonderful to use in your tests
- Groovy deems that tests are so important you should be able to run them as easily as scripts or classes. This is why Groovy includes an automatic test runner when using the `groovy` command or the GroovyConsole. This gives you some additional options over and above running your tests

In the following sections we will have a closer look at JUnit 3, 4 and 5 Groovy integration.

##### JUnit 3

Maybe one of the most prominent Groovy classes supporting JUnit 3 tests is the `GroovyTestCase` class. Being derived from `junit.framework.TestCase` it offers a bunch of additional methods that make testing in Groovy a breeze.

|      | Although `GroovyTestCase` inherits from `TestCase` doesn’t mean you can’t use JUnit 4 features in your project. In fact, the most recent Groovy versions come with a bundled JUnit 4 and that comes with a backwards compatible `TestCase` implementation. There have been some discussion on the Groovy mailing-list on whether to use `GroovyTestCase` or JUnit 4 with the result that it is mostly a matter of taste, but with `GroovyTestCase` you get a bunch of methods for free that make certain types of tests easier to write. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

In this section, we will have a look at some of the methods provided by `GroovyTestCase`. A full list of these can be found in the JavaDoc documentation for [groovy.test.GroovyTestCase](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/test/GroovyTestCase.html) , don’t forget it is inherited from `junit.framework.TestCase` which inherits all the `assert*` methods.

###### Assertion Methods

`GroovyTestCase` is inherited from `junit.framework.TestCase` therefore it inherits a large number of assertion methods being available to be called in every test method:

```groovy
class MyTestCase extends GroovyTestCase {

    void testAssertions() {
        assertTrue(1 == 1)
        assertEquals("test", "test")

        def x = "42"
        assertNotNull "x must not be null", x
        assertNull null

        assertSame x, x
    }

}
```

As can be seen above, in contrast to Java it is possible to leave out the parenthesis in most situations which leads to even more readability of JUnit assertion method call expressions.

An interesting assertion method that is added by `GroovyTestCase` is `assertScript`. It ensures that the given Groovy code string succeeds without any exception:

```groovy
void testScriptAssertions() {
    assertScript '''
        def x = 1
        def y = 2

        assert x + y == 3
    '''
}
```

###### shouldFail Methods

`shouldFail` can be used to check whether the given code block fails or not. In case it fails, the assertion does hold, otherwise the assertion fails:

```groovy
void testInvalidIndexAccess1() {
    def numbers = [1,2,3,4]
    shouldFail {
        numbers.get(4)
    }
}
```

The example above uses the basic `shouldFail` method interface that takes a `groovy.lang.Closure` as a single argument. The `Closure` instance holds the code that is supposed to be breaking during run-time.

If we wanted to assert `shouldFail` on a specific `java.lang.Exception` type we could have done so by using the `shouldFail` implementation that takes the `Exception` class as first argument and the `Closure` as second argument:

```groovy
void testInvalidIndexAccess2() {
    def numbers = [1,2,3,4]
    shouldFail IndexOutOfBoundsException, {
        numbers.get(4)
    }
}
```

If anything other than `IndexOutOfBoundsException` (or a descendant class of it) is thrown, the test case will fail.

A pretty nice feature of `shouldFail` hasn’t been visible so far: it returns the exception message. This is really useful if you want to assert on the exception error message:

```groovy
void testInvalidIndexAccess3() {
    def numbers = [1,2,3,4]
    def msg = shouldFail IndexOutOfBoundsException, {
        numbers.get(4)
    }
    assert msg.contains('Index: 4, Size: 4') ||
        msg.contains('Index 4 out-of-bounds for length 4') ||
        msg.contains('Index 4 out of bounds for length 4')
}
```

###### notYetImplemented Method

The `notYetImplemented` method has been greatly influenced by HtmlUnit. It allows to write a test method but mark it as not yet implemented. As long as the test method fails and is marked with `notYetImplemented` the test goes green:

```groovy
void testNotYetImplemented1() {
    if (notYetImplemented()) return   

    assert 1 == 2                     
}
```

|      | a call to `notYetImplemented` is necessary for `GroovyTestCase` to get the current method stack. |
| ---- | ------------------------------------------------------------ |
|      | as long as the test evaluates to `false` the test execution will be successful. |

An alternative to the `notYetImplemented` method is the `@NotYetImplemented` annotation. It allows for annotating a method as not yet implemented, with the exact same behavior as `GroovyTestCase#notYetImplemented` but without the need for the `notYetImplemented` method call:

```groovy
@NotYetImplemented
void testNotYetImplemented2() {
    assert 1 == 2
}
```

##### JUnit 4

Groovy can be used to write JUnit 4 test cases without any restrictions. The `groovy.test.GroovyAssert` holds various static methods that can be used as replacement for the `GroovyTestCase` methods in JUnit 4 tests:

```groovy
import org.junit.Test

import static groovy.test.GroovyAssert.shouldFail

class JUnit4ExampleTests {

    @Test
    void indexOutOfBoundsAccess() {
        def numbers = [1,2,3,4]
        shouldFail {
            numbers.get(4)
        }
    }

}
```

As can be seen in the example above, the static methods found in `GroovyAssert` are imported at the beginning of the class definition thus `shouldFail` can be used the same way it can be used in a `GroovyTestCase`.

|      | `groovy.test.GroovyAssert` descends from `org.junit.Assert` that means it inherits all JUnit assertion methods. However, with the introduction of the power assertion statement, it turned out to be *good practice to rely on assertion statements* instead of using the JUnit assertion methods with the improved message being the main reason. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

It is worth mentioning that `GroovyAssert.shouldFail` is not absolutely identical to `GroovyTestCase.shouldFail`. While `GroovyTestCase.shouldFail` returns the exception message, `GroovyAssert.shouldFail` returns the exception itself. It takes a few more keystrokes to get the message, but in return you can access other properties and methods of the exception:

```groovy
@Test
void shouldFailReturn() {
    def e = shouldFail {
        throw new RuntimeException('foo',
                                   new RuntimeException('bar'))
    }
    assert e instanceof RuntimeException
    assert e.message == 'foo'
    assert e.cause.message == 'bar'
}
```

##### JUnit 5

Much of the approach and helper classes described under JUnit4 apply when using JUnit5 however JUnit5 uses some slightly different class annotations when writing your tests. See the [JUnit5](http://junit.org/) documentation for more details.

Create your test classes as per normal JUnit5 guidelines as shown in this example:

```groovy
class MyTest {
  @Test
  void streamSum() {
    assertTrue(Stream.of(1, 2, 3)
      .mapToInt(i -> i)
      .sum() > 5, () -> "Sum should be greater than 5")
  }

  @RepeatedTest(value=2, name = "{displayName} {currentRepetition}/{totalRepetitions}")
  void streamSumRepeated() {
    assert Stream.of(1, 2, 3).mapToInt(i -> i).sum() == 6
  }

  private boolean isPalindrome(s) { s == s.reverse()  }

  @ParameterizedTest                                                              
  @ValueSource(strings = [ "racecar", "radar", "able was I ere I saw elba" ])
  void palindromes(String candidate) {
    assert isPalindrome(candidate)
  }

  @TestFactory
  def dynamicTestCollection() {[
    dynamicTest("Add test") { -> assert 1 + 1 == 2 },
    dynamicTest("Multiply Test", () -> { assert 2 * 3 == 6 })
  ]}
}
```

|      | This test requires the additional `org.junit.jupiter:junit-jupiter-params` dependency if not already in your project. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

You can run the tests in your IDE or build tool if it supports and is configured for JUnit5. If you run the above test in the GroovyConsole or via the `groovy` command, you will see a short text summary of the result of running the test:

```
JUnit5 launcher: passed=8, failed=0, skipped=0, time=246ms
```

More detailed information is available at the `FINE` logging level. You can configure your logging to display such information or do it programmatically as follows:

```groovy
@BeforeAll
static void init() {
  def logger = Logger.getLogger(LoggingListener.name)
  logger.level = Level.FINE
  logger.addHandler(new ConsoleHandler(level: Level.FINE))
}
```

#### 3.6.4. Testing with Spock

Spock is a testing and specification framework for Java and Groovy applications. What makes it stand out from the crowd is its beautiful and highly expressive specification DSL. In practice, Spock specifications are written as Groovy classes. Although written in Groovy they can be used to test Java classes. Spock can be used for unit, integration or BDD (behavior-driven-development) testing, it doesn’t put itself into a specific category of testing frameworks or libraries.

|      | Beside these awesome features Spock is a good example on how to leverage advanced Groovy programming language features in third party libraries, for example, by using Groovy AST transformations. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

|      | This section should not serve as detailed guide on how to use Spock, it should rather give an impression what Spock is about and how it can be leveraged for unit, integration, functional or any other type of testing. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The next section we will have an first look at the anatomy of a Spock specification. It should give a pretty good feeling on what Spock is up to.

##### Specifications

Spock lets you write specifications that describe features (properties, aspects) exhibited by a system of interest. The "system" can be anything between a single class and an entire application, a more advanced term for it is *system under specification*. The *feature description* starts from a specific snapshot of the system and its collaborators, this snapshot is called the *feature’s fixture*.

Spock specification classes are derived from `spock.lang.Specification`. A concrete specification class might consist of fields, fixture methods, features methods and helper methods.

Let’s have a look at a simple specification with a single feature method for an imaginary `Stack` class:

```groovy
class StackSpec extends Specification {

    def "adding an element leads to size increase"() {  
        setup: "a new stack instance is created"        
            def stack = new Stack()

        when:                                           
            stack.push 42

        then:                                           
            stack.size() == 1
    }
}
```

|      | Feature method, is by convention named with a String literal. |
| ---- | ------------------------------------------------------------ |
|      | Setup block, here is where any setup work for this feature needs to be done. |
|      | When block describes a stimulus, a certain action under target by this feature specification. |
|      | Then block any expressions that can be used to validate the result of the code that was triggered by the when block. |

Spock feature specifications are defined as methods inside a `spock.lang.Specification` class. They describe the feature by using a String literal instead of a method name.

A feature method holds multiple blocks, in our example we used `setup`, `when` and `then`. The `setup` block is special in that it is optional and allows to configure local variables visible inside the feature method. The `when` block defines the stimulus and is a companion of the `then` block which describes the response to the stimulus.

Note that the `setup` method in the `StackSpec` above additionally has a description String. Description Strings are optional and can be added after block labels (like `setup`, `when`, `then`).

##### More Spock

Spock provides much more features like data tables or advanced mocking capabilities. Feel free to consult the [Spock GitHub page](https://github.com/spockframework/spock) for more documentation and download information.

#### 3.6.5. Functional Tests with Geb

Geb is a functional web testing and scraper library that integrates with JUnit and Spock. It is based upon the Selenium web drivers and, like Spock, provides a Groovy DSL to write functional tests for web applications.

Geb has great features that make it a good fit for a functional testing library:

- DOM access via a JQuery-like `$` function
- implements the *page pattern*
- support for modularization of certain web components (e.g. menu-bars, etc.) with *modules*
- integration with JavaScript via the JS variable

|      | This section should not serve as detailed guide on how to use Geb, it should rather give an impression what Geb is about and how it can be leveraged functional testing. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The next section will give an example on how Geb can be used to write a functional test for a simple web page with a single search field.

##### A Geb Script

Although Geb can be used standalone in a Groovy script, in many scenarios it’s used in combination with other testing frameworks. Geb comes with various base classes that can be used in JUnit 3, 4, TestNG or Spock tests. The base classes are part of additional Geb modules that need to be added as a dependency.

For example, the following `@Grab` dependencies can be used to run Geb with the Selenium Firefox driver in JUnit4 tests. The module that is needed for JUnit 3/4 support is `geb-junit4`:

```groovy
@Grab('org.gebish:geb-core:0.9.2')
@Grab('org.gebish:geb-junit4:0.9.2')
@Grab('org.seleniumhq.selenium:selenium-firefox-driver:2.26.0')
@Grab('org.seleniumhq.selenium:selenium-support:2.26.0')
```

The central class in Geb is the `geb.Browser` class. As its name implies it is used to browse pages and access DOM elements:

```groovy
import geb.Browser
import org.openqa.selenium.firefox.FirefoxDriver

def browser = new Browser(driver: new FirefoxDriver(), baseUrl: 'http://myhost:8080/myapp')  
browser.drive {
    go "/login"                        

    $("#username").text = 'John'       
    $("#password").text = 'Doe'

    $("#loginButton").click()

    assert title == "My Application - Dashboard"
}
```

|      | A new `Browser` instance is created. In this case it uses the Selenium `FirefoxDriver` and sets the `baseUrl`. |
| ---- | ------------------------------------------------------------ |
|      | `go` is used to navigate to an URL or relative URI           |
|      | `$` together with CSS selectors is used to access the `username` and `password` DOM fields. |

The `Browser` class comes with a `drive` method that delegates all method/property calls to the current `browser` instance. The `Browser` configuration must not be done inline, it can also be externalized in a `GebConfig.groovy` configuration file for example. In practice, the usage of the `Browser` class is mostly hidden by Geb test base classes. They delegate all missing properties and method calls to the current `browser` instance that exists in the background:

```groovy
class SearchTests extends geb.junit4.GebTest {

    @Test
    void executeSeach() {
        go 'http://somehost/mayapp/search'              
        $('#searchField').text = 'John Doe'             
        $('#searchButton').click()                      

        assert $('.searchResult a').first().text() == 'Mr. John Doe' 
    }
}
```

|      | `Browser#go` takes a relative or absolute link and calls the page. |
| ---- | ------------------------------------------------------------ |
|      | `Browser#$` is used to access DOM content. Any CSS selectors supported by the underlying Selenium drivers are allowed |
|      | `click` is used to click a button.                           |
|      | `$` is used to get the first link out of the `searchResult` block |

The example above shows a simple Geb web test with the JUnit 4 base class `geb.junit4.GebTest`. Note that in this case the `Browser` configuration is externalized. `GebTest` delegates methods like `go` and `$` to the underlying `browser` instance.

##### More Geb

In the previous section we only scratched the surface of the available Geb features. More information on Geb can be found at the [project homepage](http://gebish.org/).

### 3.7. Processing JSON

Groovy comes with integrated support for converting between Groovy objects and JSON. The classes dedicated to JSON serialisation and parsing are found in the `groovy.json` package.

#### 3.7.1. JsonSlurper

`JsonSlurper` is a class that parses JSON text or reader content into Groovy data structures (objects) such as maps, lists and primitive types like `Integer`, `Double`, `Boolean` and `String`.

The class comes with a bunch of overloaded `parse` methods plus some special methods such as `parseText`, `parseFile` and others. For the next example we will use the `parseText` method. It parses a JSON `String` and recursively converts it to a list or map of objects. The other `parse*` methods are similar in that they return a JSON `String` but for different parameter types.

```groovy
def jsonSlurper = new JsonSlurper()
def object = jsonSlurper.parseText('{ "name": "John Doe" } /* some comment */')

assert object instanceof Map
assert object.name == 'John Doe'
```

Notice the result is a plain map and can be handled like a normal Groovy object instance. `JsonSlurper` parses the given JSON as defined by the [ECMA-404 JSON Interchange Standard](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf) plus support for JavaScript comments and dates.

In addition to maps `JsonSlurper` supports JSON arrays which are converted to lists.

```groovy
def jsonSlurper = new JsonSlurper()
def object = jsonSlurper.parseText('{ "myList": [4, 8, 15, 16, 23, 42] }')

assert object instanceof Map
assert object.myList instanceof List
assert object.myList == [4, 8, 15, 16, 23, 42]
```

The JSON standard supports the following primitive data types: string, number, object, `true`, `false` and `null`. `JsonSlurper` converts these JSON types into corresponding Groovy types.

```groovy
def jsonSlurper = new JsonSlurper()
def object = jsonSlurper.parseText '''
    { "simple": 123,
      "fraction": 123.66,
      "exponential": 123e12
    }'''

assert object instanceof Map
assert object.simple.class == Integer
assert object.fraction.class == BigDecimal
assert object.exponential.class == BigDecimal
```

As `JsonSlurper` is returning pure Groovy object instances without any special JSON classes in the back, its usage is transparent. In fact, `JsonSlurper` results conform to GPath expressions. GPath is a powerful expression language that is supported by multiple slurpers for different data formats (`XmlSlurper` for XML being one example).

|      | For more details please have a look at the section on [GPath expressions](https://docs.groovy-lang.org/latest/html/documentation/#gpath_expressions). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The following table gives an overview of the JSON types and the corresponding Groovy data types:

| JSON   | Groovy                                                       |
| :----- | :----------------------------------------------------------- |
| string | `java.lang.String`                                           |
| number | `java.lang.BigDecimal` or `java.lang.Integer`                |
| object | `java.util.LinkedHashMap`                                    |
| array  | `java.util.ArrayList`                                        |
| true   | `true`                                                       |
| false  | `false`                                                      |
| null   | `null`                                                       |
| date   | `java.util.Date` based on the `yyyy-MM-dd’T’HH:mm:ssZ` date format |

|      | Whenever a value in JSON is `null`, `JsonSlurper` supplements it with the Groovy `null` value. This is in contrast to other JSON parsers that represent a `null` value with a library-provided singleton object. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Parser Variants

`JsonSlurper` comes with a couple of parser implementations. Each parser fits different requirements, it could well be that for certain scenarios the `JsonSlurper` default parser is not the best bet for all situations. Here is an overview of the shipped parser implementations:

- The `JsonParserCharArray` parser basically takes a JSON string and operates on the underlying character array. During value conversion it copies character sub-arrays (a mechanism known as "chopping") and operates on them.
- The `JsonFastParser` is a special variant of the `JsonParserCharArray` and is the fastest parser. However, it is not the default parser for a reason. `JsonFastParser` is a so-called index-overlay parser. During parsing of the given JSON `String` it tries as hard as possible to avoid creating new char arrays or `String` instances. It keeps pointers to the underlying original character array only. In addition, it defers object creation as late as possible. If parsed maps are put into long-term caches care must be taken as the map objects might not be created and still consist of pointer to the original char buffer only. However, `JsonFastParser` comes with a special chop mode which dices up the char buffer early to keep a small copy of the original buffer. Recommendation is to use the `JsonFastParser` for JSON buffers under 2MB and keeping the long-term cache restriction in mind.
- The `JsonParserLax` is a special variant of the `JsonParserCharArray` parser. It has similar performance characteristics as `JsonFastParser` but differs in that it isn’t exclusively relying on the ECMA-404 JSON grammar. For example it allows for comments, no quote strings etc.
- The `JsonParserUsingCharacterSource` is a special parser for very large files. It uses a technique called "character windowing" to parse large JSON files (large means files over 2MB size in this case) with constant performance characteristics.

The default parser implementation for `JsonSlurper` is `JsonParserCharArray`. The `JsonParserType` enumeration contains constants for the parser implementations described above:

| Implementation                   | Constant                          |
| :------------------------------- | :-------------------------------- |
| `JsonParserCharArray`            | `JsonParserType#CHAR_BUFFER`      |
| `JsonFastParser`                 | `JsonParserType#INDEX_OVERLAY`    |
| `JsonParserLax`                  | `JsonParserType#LAX`              |
| `JsonParserUsingCharacterSource` | `JsonParserType#CHARACTER_SOURCE` |

Changing the parser implementation is as easy as setting the `JsonParserType` with a call to `JsonSlurper#setType()`.

```groovy
def jsonSlurper = new JsonSlurper(type: JsonParserType.INDEX_OVERLAY)
def object = jsonSlurper.parseText('{ "myList": [4, 8, 15, 16, 23, 42] }')

assert object instanceof Map
assert object.myList instanceof List
assert object.myList == [4, 8, 15, 16, 23, 42]
```

#### 3.7.2. JsonOutput

`JsonOutput` is responsible for serialising Groovy objects into JSON strings. It can be seen as companion object to [JsonSlurper](https://docs.groovy-lang.org/latest/html/documentation/json-userguide.html#json_jsonslurper), being a JSON parser.

`JsonOutput` comes with overloaded, static `toJson` methods. Each `toJson` implementation takes a different parameter type. The static methods can either be used directly or by importing the methods with a static import statement.

The result of a `toJson` call is a `String` containing the JSON code.

```groovy
def json = JsonOutput.toJson([name: 'John Doe', age: 42])

assert json == '{"name":"John Doe","age":42}'
```

`JsonOutput` does not only support primitive, maps or list data types to be serialized to JSON, it goes further and even has support for serialising POGOs, that is, plain-old Groovy objects.

```groovy
class Person { String name }

def json = JsonOutput.toJson([ new Person(name: 'John'), new Person(name: 'Max') ])

assert json == '[{"name":"John"},{"name":"Max"}]'
```

##### Customizing Output

If you need control over the serialized output you can use a `JsonGenerator`. The `JsonGenerator.Options` builder can be used to create a customized generator. One or more options can be set on this builder in order to alter the resulting output. When you are done setting the options simply call the `build()` method in order to get a fully configured instance that will generate output based on the options selected.

```groovy
class Person {
    String name
    String title
    int age
    String password
    Date dob
    URL favoriteUrl
}

Person person = new Person(name: 'John', title: null, age: 21, password: 'secret',
                            dob: Date.parse('yyyy-MM-dd', '1984-12-15'),
                            favoriteUrl: new URL('http://groovy-lang.org/'))

def generator = new JsonGenerator.Options()
    .excludeNulls()
    .dateFormat('yyyy@MM')
    .excludeFieldsByName('age', 'password')
    .excludeFieldsByType(URL)
    .build()

assert generator.toJson(person) == '{"dob":"1984@12","name":"John"}'
```

A closure can be used to transform a type. These closure converters are registered for a given type and will be called any time that type or a subtype is encountered. The first parameter to the closure is an object matching the type for which the converter is registered and this parameter is required. The closure may take an optional second `String` parameter and this will be set to the key name if one is available.

```groovy
class Person {
    String name
    URL favoriteUrl
}

Person person = new Person(name: 'John', favoriteUrl: new URL('http://groovy-lang.org/json.html#_jsonoutput'))

def generator = new JsonGenerator.Options()
    .addConverter(URL) { URL u, String key ->
        if (key == 'favoriteUrl') {
            u.getHost()
        } else {
            u
        }
    }
    .build()

assert generator.toJson(person) == '{"favoriteUrl":"groovy-lang.org","name":"John"}'

// No key available when generating a JSON Array
def list = [new URL('http://groovy-lang.org/json.html#_jsonoutput')]
assert generator.toJson(list) == '["http://groovy-lang.org/json.html#_jsonoutput"]'

// First parameter to the converter must match the type for which it is registered
shouldFail(IllegalArgumentException) {
    new JsonGenerator.Options()
        .addConverter(Date) { Calendar cal -> }
}
```

###### Formatted Output

As we saw in previous examples, the JSON output is not pretty printed per default. However, the `prettyPrint` method in `JsonOutput` comes to rescue for this task.

```groovy
def json = JsonOutput.toJson([name: 'John Doe', age: 42])

assert json == '{"name":"John Doe","age":42}'

assert JsonOutput.prettyPrint(json) == '''\
{
    "name": "John Doe",
    "age": 42
}'''.stripIndent()
```

`prettyPrint` takes a `String` as single parameter; therefore, it can be applied on arbitrary JSON `String` instances, not only the result of `JsonOutput.toJson`.

##### Builders

Another way to create JSON from Groovy is to use `JsonBuilder` or `StreamingJsonBuilder`. Both builders provide a DSL which allows to formulate an object graph which is then converted to JSON.

|      | For more details on builders, have a look at the builders chapter which covers both [JsonBuilder](https://docs.groovy-lang.org/latest/html/documentation/#_jsonbuilder) and [StreamingJsonBuilder](https://docs.groovy-lang.org/latest/html/documentation/#_streamingjsonbuilder). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

### 3.8. Interacting with a SQL database

Groovy’s `groovy-sql` module provides a higher-level abstraction over Java’s JDBC technology. JDBC itself provides a lower-level but fairly comprehensive API which provides uniform access to a whole variety of supported relational database systems. We’ll use HSQLDB in our examples here but you can alternatively use Oracle, SQL Server, MySQL and a host of others. The most frequently used class within the `groovy-sql` module is the `groovy.sql.Sql` class which raises the JDBC abstractions up one level. We’ll cover that first.

#### 3.8.1. Connecting to the database

Connecting to a database with Groovy’s `Sql` class requires four pieces of information:

- The database uniform resource locator (URL)
- Username
- Password
- The driver class name (which can be derived automatically in some situations)

For our HSQLDB database, the values will be something like that shown in the following table:

| Property | Value                    |
| :------- | :----------------------- |
| url      | `jdbc:hsqldb:mem:yourdb` |
| user     | sa (or your *username*)  |
| password | *yourPassword*           |
| driver   | `org.hsqldb.jdbcDriver`  |

Consult the documentation for the JDBC driver that you plan to use to determine the correct values for your situation.

The `Sql` class has a `newInstance` factory method which takes these parameters. You would typically use it as follows:

Connecting to HSQLDB

```groovy
import groovy.sql.Sql

def url = 'jdbc:hsqldb:mem:yourDB'
def user = 'sa'
def password = ''
def driver = 'org.hsqldb.jdbcDriver'
def sql = Sql.newInstance(url, user, password, driver)

// use 'sql' instance ...

sql.close()
```

If you don’t want to have to handle resource handling yourself (i.e. call `close()` manually) then you can use the `withInstance` variation as shown here:

Connecting to HSQLDB (`withInstance` variation)

```groovy
Sql.withInstance(url, user, password, driver) { sql ->
  // use 'sql' instance ...
}
```

##### Connecting with a DataSource

It is often preferred to use a DataSource. You may have one available to you from a connection pool. Here we’ll use the one provided as part of the HSQLDB driver jar as shown here:

Connecting to HSQLDB with a DataSource

```groovy
import groovy.sql.Sql
import org.hsqldb.jdbc.JDBCDataSource

def dataSource = new JDBCDataSource(
    database: 'jdbc:hsqldb:mem:yourDB', user: 'sa', password: '')
def sql = new Sql(dataSource)

// use then close 'sql' instance ...
```

If you have your own connection pooling, the details will be different, e.g. for Apache Commons DBCP:

Connecting to HSQLDB with a DataSource using Apache Commons DBCP

```groovy
@Grab('commons-dbcp:commons-dbcp:1.4')
import groovy.sql.Sql
import org.apache.commons.dbcp.BasicDataSource

def ds = new BasicDataSource(driverClassName: "org.hsqldb.jdbcDriver",
    url: 'jdbc:hsqldb:mem:yourDB', username: 'sa', password: '')
def sql = new Sql(ds)
// use then close 'sql' instance ...
```

##### Connecting using @Grab

The previous examples assume that the necessary database driver jar is already on your classpath. For a self-contained script you can add `@Grab` statements to the top of the script to automatically download the necessary jar as shown here:

Connecting to HSQLDB using @Grab

```groovy
@Grab('org.hsqldb:hsqldb:2.3.3')
@GrabConfig(systemClassLoader=true)
// create, use, and then close sql instance ...
```

The `@GrabConfig` statement is necessary to make sure the system classloader is used. This ensures that the driver classes and system classes like `java.sql.DriverManager` are in the same classloader.

#### 3.8.2. Executing SQL

You can execute arbitrary SQL commands using the `execute()` method. Let’s have a look at using it to create a table.

##### Creating tables

The simplest way to execute SQL is to call the `execute()` method passing the SQL you wish to execute as a String as shown here:

Creating a table

```groovy
// ... create 'sql' instance
sql.execute '''
  CREATE TABLE Author (
    id          INTEGER GENERATED BY DEFAULT AS IDENTITY,
    firstname   VARCHAR(64),
    lastname    VARCHAR(64)
  );
'''
// close 'sql' instance ...
```

There is a variant of this method which takes a GString and another with a list of parameters. There are also other variants with similar names: `executeInsert` and `executeUpdate`. We’ll see examples of these variants in other examples in this section.

#### 3.8.3. Basic CRUD operations

The basic operations on a database are Create, Read, Update and Delete (the so-called CRUD operations). We’ll examine each of these in turn.

##### Creating/Inserting data

You can use the same `execute()` statement we saw earlier but to insert a row by using a SQL insert statement as follows:

Inserting a row

```groovy
sql.execute "INSERT INTO Author (firstname, lastname) VALUES ('Dierk', 'Koenig')"
```

You can use a special `executeInsert` method instead of `execute`. This will return a list of all keys generated. Both the `execute` and `executeInsert` methods allow you to place '?' placeholders into your SQL string and supply a list of parameters. In this case a PreparedStatement is used which avoids any risk of SQL injection. The following example illustrates `executeInsert` using placeholders and parameters:

Inserting a row using executeInsert with placeholders and parameters

```groovy
def insertSql = 'INSERT INTO Author (firstname, lastname) VALUES (?,?)'
def params = ['Jon', 'Skeet']
def keys = sql.executeInsert insertSql, params
assert keys[0] == [1]
```

In addition, both the `execute` and `executeInsert` methods allow you to use GStrings. Any '$' placeholders within the SQL are assumed to be placeholders. An escaping mechanism exists if you want to supply part of the GString with a variable in a position which isn’t where normal placeholders go within SQL. See the GroovyDoc for more details. Also, `executeInsert` allows you to supply a list of key column names, when multiple keys are returned and you are only interested in some of them. Here is a fragment illustrating key name specification and GStrings:

Inserting a row using executeInsert with a GString and specifying key names

```groovy
def first = 'Guillaume'
def last = 'Laforge'
def myKeyNames = ['ID']
def myKeys = sql.executeInsert """
  INSERT INTO Author (firstname, lastname)
  VALUES (${first}, ${last})
""", myKeyNames
assert myKeys[0] == [ID: 2]
```

##### Reading rows

Reading rows of data from the database is accomplished using one of several available methods: `query`, `eachRow`, `firstRow` and `rows`.

Use the `query` method if you want to iterate through the `ResultSet` returned by the underlying JDBC API as shown here:

Reading data using `query`

```groovy
def expected = ['Dierk Koenig', 'Jon Skeet', 'Guillaume Laforge']

def rowNum = 0
sql.query('SELECT firstname, lastname FROM Author') { resultSet ->
  while (resultSet.next()) {
    def first = resultSet.getString(1)
    def last = resultSet.getString('lastname')
    assert expected[rowNum++] == "$first $last"
  }
}
```

Use the `eachRow` method if you want a slightly higher-level abstraction which provides a Groovy friendly map-like abstraction for the `ResultSet` as shown here:

Reading data using `eachRow`

```groovy
rowNum = 0
sql.eachRow('SELECT firstname, lastname FROM Author') { row ->
  def first = row[0]
  def last = row.lastname
  assert expected[rowNum++] == "$first $last"
}
```

Note that you can use Groovy list-style and map-style notations when accessing the row of data.

Use the `firstRow` method if you for similar functionality as `eachRow` but returning only one row of data as shown here:

Reading data using `firstRow`

```groovy
def first = sql.firstRow('SELECT lastname, firstname FROM Author')
assert first.values().sort().join(',') == 'Dierk,Koenig'
```

Use the `rows` method if you want to process a list of map-like data structures as shown here:

Reading data using `rows`

```groovy
List authors = sql.rows('SELECT firstname, lastname FROM Author')
assert authors.size() == 3
assert authors.collect { "$it.FIRSTNAME ${it[-1]}" } == expected
```

Note that the map-like abstraction has case-insensitive keys (hence we can use 'FIRSTNAME' or 'firstname' as the key) and also that -ve indices (a standard Groovy feature) works when using an index value (to count column numbers from the right).

You can also use any of the above methods to return scalar values, though typically `firstRow` is all that is required in such cases. An example returning the count of rows is shown here:

Reading scalar values

```groovy
assert sql.firstRow('SELECT COUNT(*) AS num FROM Author').num == 3
```

##### Updating rows

Updating rows can again be done using the `execute()` method. Just use a SQL update statement as the argument to the method. You can insert an author with just a lastname and then update the row to also have a firstname as follows:

Updating a row

```groovy
sql.execute "INSERT INTO Author (lastname) VALUES ('Thorvaldsson')"
sql.execute "UPDATE Author SET firstname='Erik' where lastname='Thorvaldsson'"
```

There is also a special `executeUpdate` variant which returns the number of rows updated as a result of executing the SQL. For example, you can change the lastname of an author as follows:

Using executeUpdate

```groovy
def updateSql = "UPDATE Author SET lastname='Pragt' where lastname='Thorvaldsson'"
def updateCount = sql.executeUpdate updateSql
assert updateCount == 1

def row = sql.firstRow "SELECT * FROM Author where firstname = 'Erik'"
assert "${row.firstname} ${row.lastname}" == 'Erik Pragt'
```

##### Deleting rows

The `execute` method is also used for deleting rows as this example shows:

Deleting rows

```groovy
assert sql.firstRow('SELECT COUNT(*) as num FROM Author').num == 3
sql.execute "DELETE FROM Author WHERE lastname = 'Skeet'"
assert sql.firstRow('SELECT COUNT(*) as num FROM Author').num == 2
```

#### 3.8.4. Advanced SQL operations

##### Working with transactions

The easiest way to perform database operations within a transaction is to include the database operation within a `withTransaction` closure as shown in the following example:

A successful transaction

```groovy
assert sql.firstRow('SELECT COUNT(*) as num FROM Author').num == 0
sql.withTransaction {
  sql.execute "INSERT INTO Author (firstname, lastname) VALUES ('Dierk', 'Koenig')"
  sql.execute "INSERT INTO Author (firstname, lastname) VALUES ('Jon', 'Skeet')"
}
assert sql.firstRow('SELECT COUNT(*) as num FROM Author').num == 2
```

Here the database starts empty and has two rows after successful completion of the operation. Outside the scope of the transaction, the database is never seen as having just one row.

If something goes wrong, any earlier operations within the `withTransaction` block are rolled back. We can see that in operation in the following example where we use database metadata (more details coming up shortly) to find the maximum allowable size of the `firstname` column and then attempt to enter a firstname one larger than that maximum value as shown here:

A failed transaction will cause a rollback

```groovy
def maxFirstnameLength
def metaClosure = { meta -> maxFirstnameLength = meta.getPrecision(1) }
def rowClosure = {}
def rowCountBefore = sql.firstRow('SELECT COUNT(*) as num FROM Author').num
try {
  sql.withTransaction {
    sql.execute "INSERT INTO Author (firstname) VALUES ('Dierk')"
    sql.eachRow "SELECT firstname FROM Author WHERE firstname = 'Dierk'", metaClosure, rowClosure
    sql.execute "INSERT INTO Author (firstname) VALUES (?)", 'X' * (maxFirstnameLength + 1)
  }
} catch(ignore) { println ignore.message }
def rowCountAfter = sql.firstRow('SELECT COUNT(*) as num FROM Author').num
assert rowCountBefore == rowCountAfter
```

Even though the first sql execute succeeds initially, it will be rolled back and the number of rows will remain the same.

##### Using batches

When dealing with large volumes of data, particularly when inserting such data, it can be more efficient to chunk the data into batches. This is done using the `withBatch` statement as shown in the following example:

Batching SQL statements

```groovy
sql.withBatch(3) { stmt ->
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Dierk', 'Koenig')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Paul', 'King')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Guillaume', 'Laforge')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Hamlet', 'D''Arcy')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Cedric', 'Champeau')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Erik', 'Pragt')"
  stmt.addBatch "INSERT INTO Author (firstname, lastname) VALUES ('Jon', 'Skeet')"
}
```

After executing these statements, there will be 7 new rows in the database. In fact, they will have been added in batches even though you can’t easily tell that after that fact. If you want to confirm what is going on under the covers, you can add a little bit of extra logging into your program. Add the following lines before the `withBatch` statement:

Logging additional SQL information

```groovy
import java.util.logging.*

// next line will add fine logging
Logger.getLogger('groovy.sql').level = Level.FINE
// also adjust logging.properties file in JRE_HOME/lib to have:
// java.util.logging.ConsoleHandler.level = FINE
```

With this extra logging turned on, and the changes made as per the above comment for the logging.properties file, you should see output such as:

SQL logging output with batching enable

```
FINE: Successfully executed batch with 3 command(s)
Apr 19, 2015 8:38:42 PM groovy.sql.BatchingStatementWrapper processResult

FINE: Successfully executed batch with 3 command(s)
Apr 19, 2015 8:38:42 PM groovy.sql.BatchingStatementWrapper processResult

FINE: Successfully executed batch with 1 command(s)
Apr 19, 2015 8:38:42 PM groovy.sql.Sql getStatement
```

We should also note, that any combination of SQL statements can be added to the batch. They don’t all have to be inserting a new row to the same table.

We noted earlier that to avoid SQL injection, we encourage you to use prepared statements, this is achieved using the variants of methods which take GStrings or a list of extra parameters. Prepared statements can be used in combination with batches as shown in the following example:

Batching prepared statements

```groovy
def qry = 'INSERT INTO Author (firstname, lastname) VALUES (?,?)'
sql.withBatch(3, qry) { ps ->
  ps.addBatch('Dierk', 'Koenig')
  ps.addBatch('Paul', 'King')
  ps.addBatch('Guillaume', 'Laforge')
  ps.addBatch('Hamlet', "D'Arcy")
  ps.addBatch('Cedric', 'Champeau')
  ps.addBatch('Erik', 'Pragt')
  ps.addBatch('Jon', 'Skeet')
}
```

This provides a much safer option if the data could come from a user such as via a script or a web form. Of course, given that a prepared statement is being used, you are limited to a batch of the same SQL operation (insert in our example) to the one table.

##### Performing pagination

When presenting large tables of data to a user, it is often convenient to present information a page at a time. Many of Groovy’s SQL retrieval methods have extra parameters which can be used to select a particular page of interest. The starting position and page size are specified as integers as shown in the following example using `rows`:

Retrieving pages of data

```groovy
def qry = 'SELECT * FROM Author'
assert sql.rows(qry, 1, 3)*.firstname == ['Dierk', 'Paul', 'Guillaume']
assert sql.rows(qry, 4, 3)*.firstname == ['Hamlet', 'Cedric', 'Erik']
assert sql.rows(qry, 7, 3)*.firstname == ['Jon']
```

##### Fetching metadata

JDBC metadata can be retrieved in numerous ways. Perhaps the most basic approach is to extract the metadata from any row as shown in the following example which examines the tablename, column names and column type names:

Using row metadata

```groovy
sql.eachRow("SELECT * FROM Author WHERE firstname = 'Dierk'") { row ->
  def md = row.getMetaData()
  assert md.getTableName(1) == 'AUTHOR'
  assert (1..md.columnCount).collect{ md.getColumnName(it) } == ['ID', 'FIRSTNAME', 'LASTNAME']
  assert (1..md.columnCount).collect{ md.getColumnTypeName(it) } == ['INTEGER', 'VARCHAR', 'VARCHAR']
}
```

And another slight variant to the previous example, this time also looking at the column label:

Also using row metadata

```groovy
sql.eachRow("SELECT firstname AS first FROM Author WHERE firstname = 'Dierk'") { row ->
  def md = row.getMetaData()
  assert md.getColumnName(1) == 'FIRSTNAME'
  assert md.getColumnLabel(1) == 'FIRST'
}
```

Accessing metadata is quite common, so Groovy also provides variants to many of its methods that let you supply a closure that will be called once with the row metadata in addition to the normal row closure which is called for each row. The following example illustrates the two closure variant for `eachRow`:

Using row and metadata closures

```groovy
def metaClosure = { meta -> assert meta.getColumnName(1) == 'FIRSTNAME' }
def rowClosure = { row -> assert row.FIRSTNAME == 'Dierk' }
sql.eachRow("SELECT firstname FROM Author WHERE firstname = 'Dierk'", metaClosure, rowClosure)
```

Note that our SQL query will only return one row, so we could have equally used `firstRow` for the previous example.

Finally, JDBC also provides metadata per connection (not just for rows). You can also access such metadata from Groovy as shown in this example:

Using connection metadata

```groovy
def md = sql.connection.metaData
assert md.driverName == 'HSQL Database Engine Driver'
assert md.databaseProductVersion == '2.3.3'
assert ['JDBCMajorVersion', 'JDBCMinorVersion'].collect{ md[it] } == [4, 0]
assert md.stringFunctions.tokenize(',').contains('CONCAT')
def rs = md.getTables(null, null, 'AUTH%', null)
assert rs.next()
assert rs.getString('TABLE_NAME') == 'AUTHOR'
```

Consult the JavaDoc for your driver to find out what metadata information is available for you to access.

##### Named and named-ordinal parameters

Groovy supports some additional alternative placeholder syntax variants. The GString variants are typically preferred over these alternatives but the alternatives are useful for Java integration purposes and sometimes in templating scenarios where GStrings might already be in heavy use as part of a template. The named parameter variants are much like the String plus list of parameter variants but instead of having a list of `?` placeholders followed by a list of parameters, you have one or more placeholders having the form `:propName` or `?.propName` and a single map, named arguments or a domain object as the parameter. The map or domain object should have a property named `propName` corresponding to each supplied placeholder.

Here is an example using the colon form:

Named parameters (colon form)

```groovy
sql.execute "INSERT INTO Author (firstname, lastname) VALUES (:first, :last)", first: 'Dierk', last: 'Koenig'
```

And another example using the question mark form:

Named parameters (question mark form)

```groovy
sql.execute "INSERT INTO Author (firstname, lastname) VALUES (?.first, ?.last)", first: 'Jon', last: 'Skeet'
```

If the information you need to supply is spread across multiple maps or domain objects you can use the question mark form with an additional ordinal index as shown here:

Named-ordinal parameters

```groovy
class Rockstar { String first, last }
def pogo = new Rockstar(first: 'Paul', last: 'McCartney')
def map = [lion: 'King']
sql.execute "INSERT INTO Author (firstname, lastname) VALUES (?1.first, ?2.lion)", pogo, map
```

##### Stored procedures

The exact syntax for creating a stored procedure or function varies slightly between different databases. For the HSQLDB database we are using, we can create a stored function which returns the initials of all authors in a table as follows:

Creating a stored function

```groovy
sql.execute """
  CREATE FUNCTION SELECT_AUTHOR_INITIALS()
  RETURNS TABLE (firstInitial VARCHAR(1), lastInitial VARCHAR(1))
  READS SQL DATA
  RETURN TABLE (
    SELECT LEFT(Author.firstname, 1) as firstInitial, LEFT(Author.lastname, 1) as lastInitial
    FROM Author
  )
"""
```

We can use a SQL `CALL` statement to invoke the function using Groovy’s normal SQL retrieval methods. Here is an example using `eachRow`.

Creating a stored procedure or function

```groovy
def result = []
sql.eachRow('CALL SELECT_AUTHOR_INITIALS()') {
  result << "$it.firstInitial$it.lastInitial"
}
assert result == ['DK', 'JS', 'GL']
```

Here is the code for creating another stored function, this one taking the lastname as a parameter:

Creating a stored function with a parameter

```groovy
sql.execute """
  CREATE FUNCTION FULL_NAME (p_lastname VARCHAR(64))
  RETURNS VARCHAR(100)
  READS SQL DATA
  BEGIN ATOMIC
    DECLARE ans VARCHAR(100);
    SELECT CONCAT(firstname, ' ', lastname) INTO ans
    FROM Author WHERE lastname = p_lastname;
    RETURN ans;
  END
"""
```

We can use the placeholder syntax to specify where the parameter belongs and note the special placeholder position to indicate the result:

Using a stored function with a parameter

```groovy
def result = sql.firstRow("{? = call FULL_NAME(?)}", ['Koenig'])
assert result[0] == 'Dierk Koenig'
```

Finally, here is a stored procedure with input and output parameters:

Creating a stored procedure with input and output parameters

```groovy
sql.execute """
  CREATE PROCEDURE CONCAT_NAME (OUT fullname VARCHAR(100),
    IN first VARCHAR(50), IN last VARCHAR(50))
  BEGIN ATOMIC
    SET fullname = CONCAT(first, ' ', last);
  END
"""
```

To use the `CONCAT_NAME` stored procedure parameter, we make use of a special `call` method. Any input parameters are simply provided as parameters to the method call. For output parameters, the resulting type must be specified as shown here:

Using a stored procedure with input and output parameters

```groovy
sql.call("{call CONCAT_NAME(?, ?, ?)}", [Sql.VARCHAR, 'Dierk', 'Koenig']) {
  fullname -> assert fullname == 'Dierk Koenig'
}
```

Creating a stored procedure with an input/output parameter

```groovy
sql.execute """
  CREATE PROCEDURE CHECK_ID_POSITIVE_IN_OUT ( INOUT p_err VARCHAR(64), IN pparam INTEGER, OUT re VARCHAR(15))
  BEGIN ATOMIC
    IF pparam > 0 THEN
      set p_err = p_err || '_OK';
      set re = 'RET_OK';
    ELSE
      set p_err = p_err || '_ERROR';
      set re = 'RET_ERROR';
    END IF;
  END;
"""
```

Using a stored procedure with an input/output parameter

```groovy
def scall = "{call CHECK_ID_POSITIVE_IN_OUT(?, ?, ?)}"
sql.call scall, [Sql.inout(Sql.VARCHAR("MESSAGE")), 1, Sql.VARCHAR], {
  res, p_err -> assert res == 'MESSAGE_OK' && p_err == 'RET_OK'
}
```

#### 3.8.5. Using DataSets

(TBD)

### 3.9. Processing XML

#### 3.9.1. Parsing XML

##### XmlParser and XmlSlurper

The most commonly used approach for parsing XML with Groovy is to use one of:

- `groovy.xml.XmlParser`
- `groovy.xml.XmlSlurper`

Both have the same approach to parse an xml. Both come with a bunch of overloaded parse methods plus some special methods such as `parseText`, parseFile and others. For the next example we will use the `parseText` method. It parses a XML `String` and recursively converts it to a list or map of objects.

XmlSlurper

```groovy
def text = '''
    <list>
        <technology>
            <name>Groovy</name>
        </technology>
    </list>
'''

def list = new XmlSlurper().parseText(text) 

assert list instanceof groovy.xml.slurpersupport.GPathResult 
assert list.technology.name == 'Groovy' 
```

|      | Parsing the XML an returning the root node as a GPathResult |
| ---- | ----------------------------------------------------------- |
|      | Checking we’re using a GPathResult                          |
|      | Traversing the tree in a GPath style                        |

XmlParser

```groovy
def text = '''
    <list>
        <technology>
            <name>Groovy</name>
        </technology>
    </list>
'''

def list = new XmlParser().parseText(text) 

assert list instanceof groovy.util.Node 
assert list.technology.name.text() == 'Groovy' 
```

|      | Parsing the XML an returning the root node as a Node |
| ---- | ---------------------------------------------------- |
|      | Checking we’re using a Node                          |
|      | Traversing the tree in a GPath style                 |

Let’s see the **similarities** between `XMLParser` and `XMLSlurper` first:

- Both are based on `SAX` so they both are low memory footprint
- Both can update/transform the XML

But they have key **differences**:

- `XmlSlurper` evaluates the structure lazily. So if you update the xml you’ll have to evaluate the whole tree again.
- `XmlSlurper` returns `GPathResult` instances when parsing XML
- `XmlParser` returns `Node` objects when parsing XML

When to use one or the another?

|      | There is a discussion at [StackOverflow](http://stackoverflow.com/questions/7558019/groovy-xmlslurper-vs-xmlparser). The conclusions written here are based partially on this entry. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

- **If you want to transform an existing document to another** then `XmlSlurper` will be the choice
- **If you want to update and read at the same time** then `XmlParser` is the choice.

The rationale behind this is that every time you create a node with `XmlSlurper` it won’t be available until you parse the document again with another `XmlSlurper` instance. Need to read just a few nodes XmlSlurper is for you ".

- **If you just have to read a few nodes** `XmlSlurper` should be your choice, since it will not have to create a complete structure in memory"

In general both classes perform similar way. Even the way of using GPath expressions with them are the same (both use `breadthFirst()` and `depthFirst()` expressions). So I guess it depends on the write/read frequency.

##### DOMCategory

There is another way of parsing XML documents with Groovy with the used of `groovy.xml.dom.DOMCategory` which is a category class which adds GPath style operations to Java’s DOM classes.

|      | Java has in-built support for DOM processing of XML using classes representing the various parts of XML documents, e.g. `Document`, `Element`, `NodeList`, `Attr` etc. For more information about these classes, refer to the respective JavaDocs. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Having a XML like the following:

```groovy
static def CAR_RECORDS = '''
<records>
  <car name='HSV Maloo' make='Holden' year='2006'>
    <country>Australia</country>
    <record type='speed'>Production Pickup Truck with speed of 271kph</record>
  </car>
  <car name='P50' make='Peel' year='1962'>
    <country>Isle of Man</country>
    <record type='size'>Smallest Street-Legal Car at 99cm wide and 59 kg in weight</record>
  </car>
  <car name='Royale' make='Bugatti' year='1931'>
    <country>France</country>
    <record type='price'>Most Valuable Car at $15 million</record>
  </car>
</records>
'''
```

You can parse it using `groovy.xml.DOMBuilder` and `groovy.xml.dom.DOMCategory`.

```groovy
def reader = new StringReader(CAR_RECORDS)
def doc = DOMBuilder.parse(reader) 
def records = doc.documentElement

use(DOMCategory) { 
    assert records.car.size() == 3
}
```

|      | Parsing the XML                                              |
| ---- | ------------------------------------------------------------ |
|      | Creating `DOMCategory` scope to be able to use helper method calls |

#### 3.9.2. GPath

The most common way of querying XML in Groovy is using `GPath`:

*GPath is a path expression language integrated into Groovy which allows parts of nested structured data to be identified. In this sense, it has similar aims and scope as XPath does for XML. The two main places where you use GPath expressions is when dealing with nested POJOs or when dealing with XML*

It is similar to [XPath](http://en.wikipedia.org/wiki/XPath) expressions and you can use it not only with XML but also with POJO classes. As an example, you can specify a path to an object or element of interest:

- `a.b.c` → for XML, yields all the `` elements inside `` inside ``
- `a.b.c` → all POJOs, yields the `` properties for all the `` properties of `` (sort of like a.getB().getC() in JavaBeans)

For XML, you can also specify attributes, e.g.:

- `a["@href"]` → the href attribute of all the a elements
- `a.'@href'` → an alternative way of expressing this
- `a.@href` → an alternative way of expressing this when using XmlSlurper

Let’s illustrate this with an example:

```groovy
static final String books = '''
    <response version-api="2.0">
        <value>
            <books>
                <book available="20" id="1">
                    <title>Don Quixote</title>
                    <author id="1">Miguel de Cervantes</author>
                </book>
                <book available="14" id="2">
                    <title>Catcher in the Rye</title>
                   <author id="2">JD Salinger</author>
               </book>
               <book available="13" id="3">
                   <title>Alice in Wonderland</title>
                   <author id="3">Lewis Carroll</author>
               </book>
               <book available="5" id="4">
                   <title>Don Quixote</title>
                   <author id="4">Miguel de Cervantes</author>
               </book>
           </books>
       </value>
    </response>
'''
```

##### Simply traversing the tree

First thing we could do is to get a value using POJO’s notation. Let’s get the first book’s author’s name

Getting node value

```groovy
def response = new XmlSlurper().parseText(books)
def authorResult = response.value.books.book[0].author

assert authorResult.text() == 'Miguel de Cervantes'
```

First we parse the document with `XmlSlurper` and the we have to consider the returning value as the root of the XML document, so in this case is "response".

That’s why we start traversing the document from response and then `value.books.book[0].author`. Note that in `XPath` the node arrays starts in [1] instead of [0], but because `GPath` is Java-based it begins at index 0.

In the end we’ll have the instance of the `author` node and because we wanted the text inside that node we should be calling the `text()` method. The `author` node is an instance of `GPathResult` type and `text()` a method giving us the content of that node as a String.

When using `GPath` with an xml parsed with `XmlSlurper` we’ll have as a result a `GPathResult` object. `GPathResult` has many other convenient methods to convert the text inside a node to any other type such as:

- `toInteger()`
- `toFloat()`
- `toBigInteger()`
- …

All these methods try to convert a `String` to the appropriate type.

If we were using a XML parsed with `XmlParser` we could be dealing with instances of type `Node`. But still all the actions applied to `GPathResult` in these examples could be applied to a Node as well. Creators of both parsers took into account `GPath` compatibility.

Next step is to get the some values from a given node’s attribute. In the following sample we want to get the first book’s author’s id. We’ll be using two different approaches. Let’s see the code first:

Getting an attribute’s value

```groovy
def response = new XmlSlurper().parseText(books)

def book = response.value.books.book[0] 
def bookAuthorId1 = book.@id 
def bookAuthorId2 = book['@id'] 

assert bookAuthorId1 == '1' 
assert bookAuthorId1.toInteger() == 1 
assert bookAuthorId1 == bookAuthorId2
```

|      | Getting the first book node                                  |
| ---- | ------------------------------------------------------------ |
|      | Getting the book’s id attribute `@id`                        |
|      | Getting the book’s id attribute with `map notation` `['@id']` |
|      | Getting the value as a String                                |
|      | Getting the value of the attribute as an `Integer`           |

As you can see there are two types of notations to get attributes, the

- *direct notation* with `@nameoftheattribute`
- *map notation* using `['@nameoftheattribute']`

Both of them are equally valid.

##### Flexible navigation with children (*), depthFirst (**) and breadthFirst

If you ever have used XPath, you may have used expressions like:

- `/following-sibling::othernode` : Look for a node "othernode" in the same level
- `//` : Look everywhere

More or less we have their counterparts in GPath with the shortcuts `*` (aka `children()`) and `**` (aka `depthFirst()`).

The first example shows a simple use of `*`, which only iterates over the direct children of the node.

Using *

```groovy
def response = new XmlSlurper().parseText(books)

// .'*' could be replaced by .children()
def catcherInTheRye = response.value.books.'*'.find { node ->
    // node.@id == 2 could be expressed as node['@id'] == 2
    node.name() == 'book' && node.@id == '2'
}

assert catcherInTheRye.title.text() == 'Catcher in the Rye'
```

This test searches for any child nodes of the "books" node matching the given condition. In a bit more detail, the expression says: *Look for any node with a tag name equal to 'book' having an id with a value of '2' directly under the 'books' node*.

This operation roughly corresponds to the `breadthFirst()` method, except that it only stops at **one level** instead of continuing to the inner levels.

What if we would like to look for a given value without having to know exactly where it is. Let’s say that the only thing we know is the id of the author "Lewis Carroll" . How are we going to be able to find that book? Using `**` is the solution:

Using **

```groovy
def response = new XmlSlurper().parseText(books)

// .'**' could be replaced by .depthFirst()
def bookId = response.'**'.find { book ->
    book.author.text() == 'Lewis Carroll'
}.@id

assert bookId == 3
```

`**` is the same as looking for something *everywhere in the tree from this point down*. In this case, we’ve used the method `find(Closure cl)` to find just the first occurrence.

What if we want to collect all book’s titles? That’s easy, just use `findAll`:

```groovy
def response = new XmlSlurper().parseText(books)

def titles = response.'**'.findAll { node -> node.name() == 'title' }*.text()

assert titles.size() == 4
```

In the last two examples, `**` is used as a shortcut for the `depthFirst()` method. It goes as far down the tree as it can while navigating down the tree from a given node. The `breadthFirst()` method finishes off all nodes on a given level before traversing down to the next level.

The following example shows the difference between these two methods:

depthFirst() vs .breadthFirst

```groovy
def response = new XmlSlurper().parseText(books)
def nodeName = { node -> node.name() }
def withId2or3 = { node -> node.@id in [2, 3] }

assert ['book', 'author', 'book', 'author'] ==
        response.value.books.depthFirst().findAll(withId2or3).collect(nodeName)
assert ['book', 'book', 'author', 'author'] ==
        response.value.books.breadthFirst().findAll(withId2or3).collect(nodeName)
```

In this example, we search for any nodes with an id attribute with value 2 or 3. There are both `book` and `author` nodes that match that criteria. The different traversal orders will find the same nodes in each case but in different orders corresponding to how the tree was traversed.

It is worth mentioning again that there are some useful methods converting a node’s value to an integer, float, etc. Those methods could be convenient when doing comparisons like this:

helpers

```groovy
def response = new XmlSlurper().parseText(books)

def titles = response.value.books.book.findAll { book ->
    /* You can use toInteger() over the GPathResult object */
    book.@id.toInteger() > 2
}*.title

assert titles.size() == 2
```

In this case the number 2 has been hardcoded but imagine that value could have come from any other source (database… etc.).

#### 3.9.3. Creating XML

The most commonly used approach for creating XML with Groovy is to use a builder, i.e. one of:

- `groovy.xml.MarkupBuilder`
- `groovy.xml.StreamingMarkupBuilder`

##### MarkupBuilder

Here is an example of using Groovy’s MarkupBuilder to create a new XML file:

Creating Xml with MarkupBuilder

```groovy
def writer = new StringWriter()
def xml = new MarkupBuilder(writer) 

xml.records() { 
    car(name: 'HSV Maloo', make: 'Holden', year: 2006) {
        country('Australia')
        record(type: 'speed', 'Production Pickup Truck with speed of 271kph')
    }
    car(name: 'Royale', make: 'Bugatti', year: 1931) {
        country('France')
        record(type: 'price', 'Most Valuable Car at $15 million')
    }
}

def records = new XmlSlurper().parseText(writer.toString()) 

assert records.car.first().name.text() == 'HSV Maloo'
assert records.car.last().name.text() == 'Royale'
```

|      | Create an instance of `MarkupBuilder`                        |
| ---- | ------------------------------------------------------------ |
|      | Start creating the XML tree                                  |
|      | Create an instance of `XmlSlurper` to traverse and test the generated XML |

Let’s take a look a little bit closer:

Creating XML elements

```groovy
def xmlString = "<movie>the godfather</movie>" 

def xmlWriter = new StringWriter() 
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup.movie("the godfather") 

assert xmlString == xmlWriter.toString() 
```

|      | We’re creating a reference string to compare against         |
| ---- | ------------------------------------------------------------ |
|      | The `xmlWriter` instance is used by `MarkupBuilder` to convert the xml representation to a String instance eventually |
|      | The `xmlMarkup.movie(…)` call will create a XML node with a tag called `movie` and with content `the godfather`. |

Creating XML elements with attributes

```groovy
def xmlString = "<movie id='2'>the godfather</movie>"

def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup.movie(id: "2", "the godfather") 

assert xmlString == xmlWriter.toString()
```

|      | This time in order to create both attributes and node content you can create as many map entries as you like and finally add a value to set the node’s content |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

|      | The value could be any `Object`, the value will be serialized to its `String` representation. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Creating XML nested elements

```groovy
def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup.movie(id: 2) { 
    name("the godfather")
}

def movie = new XmlSlurper().parseText(xmlWriter.toString())

assert movie.@id == 2
assert movie.name.text() == 'the godfather'
```

|      | A closure represents the children elements of a given node. Notice this time instead of using a String for the attribute we’re using a number. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Sometimes you may want to use a specific namespace in your xml documents:

Namespace aware

```groovy
def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup
        .'x:movies'('xmlns:x': 'http://www.groovy-lang.org') { 
    'x:movie'(id: 1, 'the godfather')
    'x:movie'(id: 2, 'ronin')
}

def movies =
        new XmlSlurper() 
                .parseText(xmlWriter.toString())
                .declareNamespace(x: 'http://www.groovy-lang.org')

assert movies.'x:movie'.last().@id == 2
assert movies.'x:movie'.last().text() == 'ronin'
```

|      | Creating a node with a given namespace `xmlns:x`             |
| ---- | ------------------------------------------------------------ |
|      | Creating a `XmlSlurper` registering the namespace to be able to test the XML we just created |

What about having some more meaningful example. We may want to generate more elements, to have some logic when creating our XML:

Mix code

```groovy
def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)

xmlMarkup
        .'x:movies'('xmlns:x': 'http://www.groovy-lang.org') {
    (1..3).each { n -> 
        'x:movie'(id: n, "the godfather $n")
        if (n % 2 == 0) { 
            'x:movie'(id: n, "the godfather $n (Extended)")
        }
    }
}

def movies =
        new XmlSlurper()
                .parseText(xmlWriter.toString())
                .declareNamespace(x: 'http://www.groovy-lang.org')

assert movies.'x:movie'.size() == 4
assert movies.'x:movie'*.text().every { name -> name.startsWith('the') }
```

|      | Generating elements from a range                 |
| ---- | ------------------------------------------------ |
|      | Using a conditional for creating a given element |

Of course the instance of a builder can be passed as a parameter to refactor/modularize your code:

Mix code

```groovy
def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter)


Closure<MarkupBuilder> buildMovieList = { MarkupBuilder builder ->
    (1..3).each { n ->
        builder.'x:movie'(id: n, "the godfather $n")
        if (n % 2 == 0) {
            builder.'x:movie'(id: n, "the godfather $n (Extended)")
        }
    }

    return builder
}

xmlMarkup.'x:movies'('xmlns:x': 'http://www.groovy-lang.org') {
    buildMovieList(xmlMarkup) 
}

def movies =
        new XmlSlurper()
                .parseText(xmlWriter.toString())
                .declareNamespace(x: 'http://www.groovy-lang.org')

assert movies.'x:movie'.size() == 4
assert movies.'x:movie'*.text().every { name -> name.startsWith('the') }
```

|      | In this case we’ve created a Closure to handle the creation of a list of movies |
| ---- | ------------------------------------------------------------ |
|      | Just using the `buildMovieList` function when necessary      |

##### StreamingMarkupBuilder

The class `groovy.xml.StreamingMarkupBuilder` is a builder class for creating XML markup. This implementation uses a `groovy.xml.streamingmarkupsupport.StreamingMarkupWriter` to handle output.

Using StreamingMarkupBuilder

```groovy
def xml = new StreamingMarkupBuilder().bind { 
    records {
        car(name: 'HSV Maloo', make: 'Holden', year: 2006) { 
            country('Australia')
            record(type: 'speed', 'Production Pickup Truck with speed of 271kph')
        }
        car(name: 'P50', make: 'Peel', year: 1962) {
            country('Isle of Man')
            record(type: 'size', 'Smallest Street-Legal Car at 99cm wide and 59 kg in weight')
        }
        car(name: 'Royale', make: 'Bugatti', year: 1931) {
            country('France')
            record(type: 'price', 'Most Valuable Car at $15 million')
        }
    }
}

def records = new XmlSlurper().parseText(xml.toString()) 

assert records.car.size() == 3
assert records.car.find { it.@name == 'P50' }.country.text() == 'Isle of Man'
```

|      | Note that `StreamingMarkupBuilder.bind` returns a `Writable` instance that may be used to stream the markup to a Writer |
| ---- | ------------------------------------------------------------ |
|      | We’re capturing the output in a String to parse it again an check the structure of the generated XML with `XmlSlurper`. |

##### MarkupBuilderHelper

The `groovy.xml.MarkupBuilderHelper` is, as its name reflects, a helper for `groovy.xml.MarkupBuilder`.

This helper normally can be accessed from within an instance of class `groovy.xml.MarkupBuilder` or an instance of `groovy.xml.StreamingMarkupBuilder`.

This helper could be handy in situations when you may want to:

- Produce a comment in the output
- Produce an XML processing instruction in the output
- Produce an XML declaration in the output
- Print data in the body of the current tag, escaping XML entities
- Print data in the body of the current tag

In both `MarkupBuilder` and `StreamingMarkupBuilder` this helper is accessed by the property `mkp`:

Using MarkupBuilder’s 'mkp'

```groovy
def xmlWriter = new StringWriter()
def xmlMarkup = new MarkupBuilder(xmlWriter).rules {
    mkp.comment('THIS IS THE MAIN RULE') 
    rule(sentence: mkp.yield('3 > n')) 
}


assert xmlWriter.toString().contains('3 &gt; n')
assert xmlWriter.toString().contains('<!-- THIS IS THE MAIN RULE -->')
```

|      | Using `mkp` to create a comment in the XML |
| ---- | ------------------------------------------ |
|      | Using `mkp` to generate an escaped value   |
|      | Checking both assumptions were true        |

Here is another example to show the use of `mkp` property accessible from within the `bind` method scope when using `StreamingMarkupBuilder`:

Using StreamingMarkupBuilder’s 'mkp'

```groovy
def xml = new StreamingMarkupBuilder().bind {
    records {
        car(name: mkp.yield('3 < 5')) 
        car(name: mkp.yieldUnescaped('1 < 3')) 
    }
}

assert xml.toString().contains('3 &lt; 5')
assert xml.toString().contains('1 < 3')
```

|      | If we want to generate a escaped value for the name attribute with `mkp.yield` |
| ---- | ------------------------------------------------------------ |
|      | Checking the values later on with `XmlSlurper`               |

##### DOMToGroovy

Suppose we have an existing XML document and we want to automate generation of the markup without having to type it all in? We just need to use `org.codehaus.groovy.tools.xml.DOMToGroovy` as shown in the following example:

Building MarkupBuilder from DOMToGroovy

```groovy
def songs = """
    <songs>
      <song>
        <title>Here I go</title>
        <band>Whitesnake</band>
      </song>
    </songs>
"""

def builder =
        javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder()

def inputStream = new ByteArrayInputStream(songs.bytes)
def document = builder.parse(inputStream)
def output = new StringWriter()
def converter = new DomToGroovy(new PrintWriter(output)) 

converter.print(document) 

String xmlRecovered =
        new GroovyShell()
                .evaluate("""
           def writer = new StringWriter()
           def builder = new groovy.xml.MarkupBuilder(writer)
           builder.${output}

           return writer.toString()
        """) 

assert new XmlSlurper().parseText(xmlRecovered).song.title.text() == 'Here I go' 
```

|      | Creating `DOMToGroovy` instance                              |
| ---- | ------------------------------------------------------------ |
|      | Converts the XML to `MarkupBuilder` calls which are available in the output `StringWriter` |
|      | Using `output` variable to create the whole MarkupBuilder    |
|      | Back to XML string                                           |

#### 3.9.4. Manipulating XML

In this chapter you’ll see the different ways of adding / modifying / removing nodes using `XmlSlurper` or `XmlParser`. The xml we are going to be handling is the following:

```groovy
def xml = """
<response version-api="2.0">
    <value>
        <books>
            <book id="2">
                <title>Don Quixote</title>
                <author id="1">Miguel de Cervantes</author>
            </book>
        </books>
    </value>
</response>
"""
```

##### Adding nodes

The main difference between `XmlSlurper` and `XmlParser` is that when former creates the nodes they won’t be available until the document’s been evaluated again, so you should parse the transformed document again in order to be able to see the new nodes. So keep that in mind when choosing any of both approaches.

If you needed to see a node right after creating it then `XmlParser` should be your choice, but if you’re planning to do many changes to the XML and send the result to another process maybe `XmlSlurper` would be more efficient.

You can’t create a new node directly using the `XmlSlurper` instance, but you can with `XmlParser`. The way of creating a new node from XmlParser is through its method `createNode(..)`

```groovy
def parser = new XmlParser()
def response = parser.parseText(xml)
def numberOfResults = parser.createNode(
        response,
        new QName("numberOfResults"),
        [:]
)

numberOfResults.value = "1"
assert response.numberOfResults.text() == "1"
```

The `createNode()` method receives the following parameters:

- parent node (could be null)
- The qualified name for the tag (In this case we only use the local part without any namespace). We’re using an instance of `groovy.namespace.QName`
- A map with the tag’s attributes (None in this particular case)

Anyway you won’t normally be creating a node from the parser instance but from the parsed XML instance. That is from a `Node` or a `GPathResult` instance.

Take a look at the next example. We are parsing the xml with `XmlParser` and then creating a new node from the parsed document’s instance (Notice the method here is slightly different in the way it receives the parameters):

```groovy
def parser = new XmlParser()
def response = parser.parseText(xml)

response.appendNode(
        new QName("numberOfResults"),
        [:],
        "1"
)

response.numberOfResults.text() == "1"
```

When using `XmlSlurper`, `GPathResult` instances don’t have `createNode()` method.

##### Modifying / Removing nodes

We know how to parse the document, add new nodes, now I want to change a given node’s content. Let’s start using `XmlParser` and `Node`. This example changes the first book information to actually another book.

```groovy
def response = new XmlParser().parseText(xml)

/* Use the same syntax as groovy.xml.MarkupBuilder */
response.value.books.book[0].replaceNode { 
    book(id: "3") {
        title("To Kill a Mockingbird")
        author(id: "3", "Harper Lee")
    }
}

def newNode = response.value.books.book[0]

assert newNode.name() == "book"
assert newNode.@id == "3"
assert newNode.title.text() == "To Kill a Mockingbird"
assert newNode.author.text() == "Harper Lee"
assert newNode.author.@id.first() == "3"
```

When using `replaceNode()` the closure we pass as parameter should follow the same rules as if we were using `groovy.xml.MarkupBuilder`:

Here’s the same example using `XmlSlurper`:

```groovy
def response = new XmlSlurper().parseText(books)

/* Use the same syntax as groovy.xml.MarkupBuilder */
response.value.books.book[0].replaceNode {
    book(id: "3") {
        title("To Kill a Mockingbird")
        author(id: "3", "Harper Lee")
    }
}

assert response.value.books.book[0].title.text() == "Don Quixote"

/* That mkp is a special namespace used to escape away from the normal building mode
   of the builder and get access to helper markup methods
   'yield', 'pi', 'comment', 'out', 'namespaces', 'xmlDeclaration' and
   'yieldUnescaped' */
def result = new StreamingMarkupBuilder().bind { mkp.yield response }.toString()
def changedResponse = new XmlSlurper().parseText(result)

assert changedResponse.value.books.book[0].title.text() == "To Kill a Mockingbird"
```

Notice how using `XmlSlurper` we have to parse the transformed document again in order to find the created nodes. In this particular example could be a little bit annoying isn’t it?

Finally both parsers also use the same approach for adding a new attribute to a given attribute. This time again the difference is whether you want the new nodes to be available right away or not. First `XmlParser`:

```groovy
def parser = new XmlParser()
def response = parser.parseText(xml)

response.@numberOfResults = "1"

assert response.@numberOfResults == "1"
```

And `XmlSlurper`:

```groovy
def response = new XmlSlurper().parseText(books)
response.@numberOfResults = "2"

assert response.@numberOfResults == "2"
```

When using `XmlSlurper`, adding a new attribute does **not** require you to perform a new evaluation.

##### Printing XML

###### XmlUtil

Sometimes is useful to get not only the value of a given node but the node itself (for instance to add this node to another XML).

For that you can use `groovy.xml.XmlUtil` class. It has several static methods to serialize the xml fragment from several type of sources (Node, GPathResult, String…)

Getting a node as a string

```groovy
def response = new XmlParser().parseText(xml)
def nodeToSerialize = response.'**'.find { it.name() == 'author' }
def nodeAsText = XmlUtil.serialize(nodeToSerialize)

assert nodeAsText ==
        XmlUtil.serialize('<?xml version="1.0" encoding="UTF-8"?><author id="1">Miguel de Cervantes</author>')
```

### 3.10. Scripting Ant tasks

Groovy integrates very well with [Apache Ant](http://ant.apache.org/) thanks to [AntBuilder](https://docs.groovy-lang.org/latest/html/documentation/#_antbuilder).

### 3.11. The <groovy> Ant Task

|      | Here we describe an Ant task for using Groovy from within an Ant build file. You may also be interested in Ant’s built-in [`script`](https://ant.apache.org/manual/Tasks/script.html) task which supports Groovy and other languages, or [`AntBuilder`](https://docs.groovy-lang.org/latest/html/documentation/ant-builder.html#title-heading) which lets you write Ant build scripts in Groovy rather than XML. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Executes a series of Groovy statements from [Apache Ant](http://ant.apache.org/). Statements can either be read in from a resource or as direct text between the enclosing Groovy tags.

#### 3.11.1. Required taskdef

Assuming all the groovy jars you need are in *my.classpath* (this will be `groovy-VERSION.jar`, `groovy-ant-VERSION.jar` plus any modules and transitive dependencies you might be using) you will need to declare this task at some point in the `build.xml` prior to the `groovy` task being invoked.

```xml
<taskdef name="groovy"
         classname="org.codehaus.groovy.ant.Groovy"
         classpathref="my.classpath"/>
```

You can simply place statements between the `groovy` tags like this:

```xml
<groovy>
...
</groovy>
```

Or you can supply the Groovy source script as a resource. You can specify the pathname using the `src` attribute like this:

```xml
<groovy src="/some/path/MyGroovyScript.groovy" otherAttributes="...">
```

Or as a nested `fileset` like this (though the fileset definition is expected to select just one file):

```xml
<groovy>
    <fileset file="MyGroovyScript.groovy"/>
</groovy>
```

Or as a nested single element [resource collection](https://ant.apache.org/manual/Types/resources.html#collection) which could look like any of these:

```xml
<groovy>
    <file file="MyGroovyScript.groovy"/>
</groovy>

<groovy>
    <url url="https://some.domain/some/path/to/MyGroovyScript.groovy"/>
</groovy>

<groovy>
    <javaconstant name="some.packagename.SomeClass.MY_CODE_FRAGMENT"/>
</groovy>
```

You may also supply a [filter chain](https://ant.apache.org/manual/Types/filterchain.html) like this:

```xml
<groovy>
    <fileset file="MyGroovyScript.groovy"/>
    <!-- take 5 lines after skipping 18 lines, just as an example -->
    <filterchain>
        <headfilter lines="5" skip="18"/>
    </filterchain>
</groovy>
```

You might need to use the *contextClassLoader* attribute (see below) if any of your modules load services via the classpath, e.g. `groovy-json`.

#### 3.11.2. <groovy> attributes

| Attribute          | Description                                                  | Required                                    |
| :----------------- | :----------------------------------------------------------- | :------------------------------------------ |
| contextClassLoader | If enabled, the contextClassLoader to be set with the classLoader of the shell used to run the script. Not used if fork is true. | No                                          |
| src                | File containing Groovy statements. The directory containing the file is added to the classpath. | Yes, unless statements enclosed within tags |
| classpath          | The classpath to use.                                        | No                                          |
| classpathref       | The classpath to use, given as reference to a PATH defined elsewhere. | No                                          |
| output             | Set the output file; defaults to the Ant log.                | No                                          |
| append             | If enabled and output is to a file, append to existing file rather than overwrite. Defaults to false. | No                                          |
| fork               | If enabled the script will be executed in a forked JVM process (disabled by default). | No                                          |
| scriptBaseClass    | The name of the base class for scripts.                      | No                                          |
| indy               | If enabled the script will be executed with `invokedynamic` (disabled by default). | No                                          |
| parameters         | Generates metadata for reflection on method parameter names on JDK 8 and above. Defaults to false. | No                                          |
| useGroovyShell     | If enabled a new GroovyShell is used to run the script. Special variables won’t be available but you don’t need Ant in the classpath. Defaults to false. | No                                          |
| includeAntRuntime  | If enabled the system classpath will be included on the classpath when forking. Defaults to true. | No                                          |
| stacktrace         | If enabled a stacktrace will be reported if an error occurs during compilation. Defaults to false. | No                                          |
| configScript       | Sets the configuration script for the groovy compiler configuration. | No                                          |

#### 3.11.3. Parameters specified as nested elements

##### <classpath>

Groovy’s classpath attribute is a PATH like structure and can also be set via a nested classpath element.

##### <arg>

Arguments can be set via one or more nested <arg> elements using the standard Ant [command line conventions](http://ant.apache.org/manual/using.html#arg).

#### 3.11.4. Available bindings

A number of bindings are in scope for use within your Groovy statements.

| Name       | Description                                                  |
| :--------- | :----------------------------------------------------------- |
| args       | command line arguments, if any                               |
| ant        | an instance of `AntBuilder` that knows about the current ant project |
| project    | the current ant project                                      |
| properties | a `Map` of ant properties                                    |
| target     | the owning target that invoked this groovy script            |
| task       | the wrapping task, can access anything needed in `org.apache.tools.ant.Task` |

#### 3.11.5. Examples

Hello world, version 1:

```xml
<groovy>
println "Hello World"
</groovy>
```

Hello world, version 2:

```xml
<groovy>
ant.echo "Hello World"
</groovy>
```

List all xml files in the current directory:

```xml
<groovy>
xmlfiles = new File(".").listFiles().findAll{ it =~ "\.xml$" }
xmlfiles.sort().each { println it.toString() }
</groovy>
```

List all xml files within a jar:

```xml
<zipfileset id="found" src="foobar.jar"
            includes="**/*.xml"/>
<groovy>
    project.references.found.each {
        println it.name
    }
</groovy>
```

Run a script:

```xml
<groovy src="/some/directory/some/file.groovy">
  <classpath>
    <pathelement location="/my/groovy/classes/directory"/>
  </classpath>
</groovy>
```

Find all `Builder` classes having an `org.*` package within a directory of jars:

```xml
<property name="local.target" value="C:/Projects/GroovyExamples"/>
<groovy>
import java.util.jar.JarFile
def classes = []
def resourceNamePattern = /org\/.*\/.*Builder.class/
def jarNamePattern = /.*(beta|commons).*jar$/

def libdir = new File("${properties['local.target']}/lib")
libdir.listFiles().grep(~jarNamePattern).each { candidate ->
    new JarFile(candidate).entries().each { entry ->
        if (entry.name ==~ resourceNamePattern) classes += entry.name
    }
}
properties["builder-classes"] = classes.join(' ')
</groovy>
<echo message='${builder-classes}'/>
```

Which might result in something like:

```
org/apache/commons/cli/PatternOptionBuilder.class org/apache/commons/cli/OptionBuilder.class org/codehaus/groovy/tools/groovydoc/GroovyRootDocBuilder.class org/custommonkey/xmlunit/HTMLDocumentBuilder.class org/custommonkey/xmlunit/TolerantSaxDocumentBuilder.class
```

FileScanner version of above (with a slight variation on collecting the names):

```xml
<groovy>
import java.util.jar.JarFile
def resourceNamePattern = /org\/.*\/.*Builder.class/
def candidates = ant.fileScanner {
    fileset(dir: '${local.target}/lib') {
        include(name: '*beta*.jar')
        include(name: '*commons*.jar')
    }
}
def classes = candidates.collect {
    new JarFile(it).entries().collect { it.name }.findAll {
        it ==~ resourceNamePattern
    }
}.flatten()
properties["builder-classes"] = classes.join(' ')
</groovy>
```

Calling out to a web service from your Ant script:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project name="SOAP example" default="main" basedir=".">
    <property environment="env"/>
    <property name="celsius" value="0"/>
    <target name="main">
        <taskdef name="groovy" classname="org.codehaus.groovy.ant.Groovy">
            <classpath>
                <fileset dir="${env.GROOVY_HOME}" includes="lib/groovy-*.jar,lib/ivy*.jar"/>
            </classpath>
        </taskdef>
        <groovy>
            @Grab('org.codehaus.groovy.modules:groovyws:0.5.1')
            import groovyx.net.ws.WSClient
            def url = 'http://www.w3schools.com/webservices/tempconvert.asmx?WSDL'
            def proxy = new WSClient(url, this.class.classLoader)
            proxy.initialize()
            ant.echo "I'm freezing at ${properties.celsius} degrees Celsius"
            properties.result = proxy.CelsiusToFahrenheit(properties.celsius)
        </groovy>
        <antcall target="results"/>
    </target>
    <target name="results">
        <echo message="I'm freezing at ${result} degrees Fahrenheit"/>
    </target>
</project>
```

Which will output the following (along with some informational messages):

```
main:
     ...
     [echo] I'm freezing at 0 degrees Celsius
results:
     [echo] I'm freezing at 32 degrees Fahrenheit

BUILD SUCCESSFUL
```

Setting arguments:

```xml
<target name="run">
    <groovy>
        <arg line="1 2 3"/>
        <arg value="4 5"/>
        println args.size()
        println args[2]
        args.each{ ant.echo(message:it) }
    </groovy>
</target>
```

Output:

```
Buildfile: build.xml

run:
   [groovy] 4
   [groovy] 3
     [echo] 1
     [echo] 2
     [echo] 3
     [echo] 4 5

BUILD SUCCESSFUL
```

### 3.12. Template engines

#### 3.12.1. Introduction

Groovy supports multiple ways to generate text dynamically including `GStrings`, `printf` and [MarkupBuilder](https://docs.groovy-lang.org/latest/html/documentation/#_markupbuilder) just to name a few. In addition to these, there is a dedicated template framework which is well-suited to applications where the text to be generated follows the form of a static template.

#### 3.12.2. Template framework

The template framework in Groovy consists of a `TemplateEngine` abstract base class that engines must implement and a `Template` interface that the resulting templates they generate must implement.

Included with Groovy are several template engines:

- `SimpleTemplateEngine` - for basic templates
- `StreamingTemplateEngine` - functionally equivalent to `SimpleTemplateEngine`, but can handle strings larger than 64k
- `GStringTemplateEngine` - stores the template as writeable closures (useful for streaming scenarios)
- `XmlTemplateEngine` - works well when the template and output are valid XML
- `MarkupTemplateEngine` - a very complete, optimized, template engine

#### 3.12.3. SimpleTemplateEngine

Shown here is the `SimpleTemplateEngine` that allows you to use JSP-like scriptlets (see example below), script, and EL expressions in your template in order to generate parametrized text. Here is an example of using the system:

```groovy
def text = 'Dear "$firstname $lastname",\nSo nice to meet you in <% print city %>.\nSee you in ${month},\n${signed}'

def binding = ["firstname":"Sam", "lastname":"Pullara", "city":"San Francisco", "month":"December", "signed":"Groovy-Dev"]

def engine = new groovy.text.SimpleTemplateEngine()
def template = engine.createTemplate(text).make(binding)

def result = 'Dear "Sam Pullara",\nSo nice to meet you in San Francisco.\nSee you in December,\nGroovy-Dev'

assert result == template.toString()
```

While it is generally not deemed good practice to mix processing logic in your template (or view), sometimes very simple logic can be useful. E.g. in the example above, we could change this:

```groovy
$firstname
```

to this (assuming we have set up a static import for capitalize **inside** the template):

```groovy
${firstname.capitalize()}
```

or this:

```groovy
<% print city %>
```

to this:

```groovy
<% print city == "New York" ? "The Big Apple" : city %>
```

##### Advanced Usage Note

If you happen to be embedding your template directly in your script (as we did above) you have to be careful about backslash escaping. Because the template string itself will be parsed by Groovy before it is passed to the templating framework, you have to escape any backslashes inside GString expressions or scriptlet 'code' that are entered as part of a Groovy program. E.g. if we wanted quotes around *The Big Apple* above, we would use:

```groovy
<% print city == "New York" ? "\\"The Big Apple\\"" : city %>
```

Similarly, if we wanted a newline, we would use:

```groovy
\\n
```

in any GString expression or scriptlet 'code' that appears inside a Groovy script. A normal “\n” is fine within the static template text itself or if the entire template itself is in an external template file. Similarly, to represent an actual backslash in your text you would need

```groovy
\\\\
```

in an external file or

```groovy
\\\\
```

in any GString expression or scriptlet 'code'. (Note: the necessity to have this extra slash may go away in a future version of Groovy if we can find an easy way to support such a change.)

#### 3.12.4. StreamingTemplateEngine

The `StreamingTemplateEngine` engine is functionally equivalent to the `SimpleTemplateEngine`, but creates the template using writable closures making it more scalable for large templates. Specifically this template engine can handle strings larger than 64k.

It uses JSP style <% %> script and <%= %> expression syntax or GString style expressions. The variable 'out' is bound to the writer that the template is being written to.

Frequently, the template source will be a file but here we show a simple example providing the template as a string:

```groovy
def text = '''\
Dear <% out.print firstname %> ${lastname},

We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> \
to inform you that your paper entitled
'$title' was ${ accepted ? 'accepted' : 'rejected' }.

The conference committee.'''

def template = new groovy.text.StreamingTemplateEngine().createTemplate(text)

def binding = [
    firstname : "Grace",
    lastname  : "Hopper",
    accepted  : true,
    title     : 'Groovy for COBOL programmers'
]

String response = template.make(binding)

assert response == '''Dear Grace Hopper,

We are pleased to inform you that your paper entitled
'Groovy for COBOL programmers' was accepted.

The conference committee.'''
```

#### 3.12.5. GStringTemplateEngine

As an example of using the `GStringTemplateEngine`, here is the example above done again (with a few changes to show some other options). First we will store the template in a file this time:

test.template

```groovy
Dear "$firstname $lastname",
So nice to meet you in <% out << (city == "New York" ? "\\"The Big Apple\\"" : city) %>.
See you in ${month},
${signed}
```

Note that we used `out` instead of `print` to support the streaming nature of `GStringTemplateEngine`. Because we have the template in a separate file, there is no need to escape the backslashes. Here is how we call it:

```groovy
def f = new File('test.template')
def engine = new groovy.text.GStringTemplateEngine()
def template = engine.createTemplate(f).make(binding)
println template.toString()
```

and here is the output:

```
Dear "Sam Pullara",
So nice to meet you in "The Big Apple".
See you in December,
Groovy-Dev
```

#### 3.12.6. XmlTemplateEngine

`XmlTemplateEngine` for use in templating scenarios where both the template source and the expected output are intended to be XML. Templates may use the normal `${expression}` and `$variable` notations to insert an arbitrary expression into the template. In addition, support is also provided for special tags: `` (for inserting code fragments) and `` (for code fragments which produce output).

Comments and processing instructions will be removed as part of processing and special XML characters such as `<`, `>`, `"` and `'` will be escaped using the respective XML notation. The output will also be indented using standard XML pretty printing.

The xmlns namespace definition for gsp: tags will be removed but other namespace definitions will be preserved (but may change to an equivalent position within the XML tree).

Normally, the template source will be in a file but here is a simple example providing the XML template as a string:

```groovy
def binding = [firstname: 'Jochen', lastname: 'Theodorou', nickname: 'blackdrag', salutation: 'Dear']
def engine = new groovy.text.XmlTemplateEngine()
def text = '''\
    <document xmlns:gsp='http://groovy.codehaus.org/2005/gsp' xmlns:foo='baz' type='letter'>
        <gsp:scriptlet>def greeting = "${salutation}est"</gsp:scriptlet>
        <gsp:expression>greeting</gsp:expression>
        <foo:to>$firstname "$nickname" $lastname</foo:to>
        How are you today?
    </document>
'''
def template = engine.createTemplate(text).make(binding)
println template.toString()
```

This example will produce this output:

```xml
<document type='letter'>
  Dearest
  <foo:to xmlns:foo='baz'>
    Jochen &quot;blackdrag&quot; Theodorou
  </foo:to>
  How are you today?
</document>
```

#### 3.12.7. The MarkupTemplateEngine

This template engine is a template engine primarily aimed at generating XML-like markup (XML, XHTML, HTML5, …), but that can be used to generate any text based content. Unlike traditional template engines, this one relies on a DSL that uses the builder syntax. Here is a sample template:

```groovy
xmlDeclaration()
cars {
   cars.each {
       car(make: it.make, model: it.model)
   }
}
```

If you feed it with the following model:

```groovy
model = [cars: [new Car(make: 'Peugeot', model: '508'), new Car(make: 'Toyota', model: 'Prius')]]
```

It would be rendered as:

```xml
<?xml version='1.0'?>
<cars><car make='Peugeot' model='508'/><car make='Toyota' model='Prius'/></cars>
```

The key features of this template engine are:

- a *markup builder like* syntax
- templates are compiled into bytecode
- fast rendering
- optional type checking of the model
- includes
- internationalization support
- fragments/layouts

##### The template format

###### Basics

Templates consist of Groovy code. Let’s explore the first example more thoroughly:

```groovy
xmlDeclaration()                                
cars {                                          
   cars.each {                                  
       car(make: it.make, model: it.model)      
   }                                            
}
```

|      | renders the XML declaration string.                          |
| ---- | ------------------------------------------------------------ |
|      | opens a `cars` tag                                           |
|      | `cars` is a variable found in the *template model*, which is a list of `Car` instances |
|      | for each item, we create a `car` tag with the attributes from the `Car` instance |
|      | closes the `cars` tag                                        |

As you can see, regular Groovy code can be used in the template. Here, we are calling `each` on a list (retrieved from the model), allowing us to render one `car` tag per entry.

In a similar fashion, rendering HTML code is as simple as this:

```groovy
yieldUnescaped '<!DOCTYPE html>'                                                    
html(lang:'en') {                                                                   
    head {                                                                          
        meta('http-equiv':'"Content-Type" content="text/html; charset=utf-8"')      
        title('My page')                                                            
    }                                                                               
    body {                                                                          
        p('This is an example of HTML contents')                                    
    }                                                                               
}                                                                                   
```

|      | renders the HTML doctype special tag                 |
| ---- | ---------------------------------------------------- |
|      | opens the `html` tag with an attribute               |
|      | opens the `head` tag                                 |
|      | renders a `meta` tag with one `http-equiv` attribute |
|      | renders the `title` tag                              |
|      | closes the `head` tag                                |
|      | opens the `body` tag                                 |
|      | renders a `p` tag                                    |
|      | closes the `body` tag                                |
|      | closes the `html` tag                                |

The output is straightforward:

```html
<!DOCTYPE html><html lang='en'><head><meta http-equiv='"Content-Type" content="text/html; charset=utf-8"'/><title>My page</title></head><body><p>This is an example of HTML contents</p></body></html>
```

|      | With some [configuration](https://docs.groovy-lang.org/latest/html/documentation/#markuptemplate-config), you can have the output pretty printed, with newlines and indent automatically added. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Support methods

In the previous example, the doctype declaration was rendered using the `yieldUnescaped` method. We have also seen the `xmlDeclaration` method. The template engine provides several support methods that will help you render contents appropriately:

| Method         | Description                                                  | Example                                                      |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| yield          | Renders contents, but escapes it before rendering            | **Template**:`yield 'Some text with '`**Output**:`Some text with <angle brackets>` |
| yieldUnescaped | Renders raw contents. The argument is rendered as is, without escaping. | **Template**:`yieldUnescaped 'Some text with '`**Output**:`Some text with ` |
| xmlDeclaration | Renders an XML declaration String. If the encoding is specified in the configuration, it is written in the declaration. | **Template**:`xmlDeclaration()`**Output**:``If `TemplateConfiguration#getDeclarationEncoding` is not null:**Output**:`` |
| comment        | Renders raw contents inside an XML comment                   | **Template**:`comment 'This is [commented out](foo.html)'`**Output**:`` |
| newLine        | Renders a new line. See also `TemplateConfiguration#setAutoNewLine` and `TemplateConfiguration#setNewLineString`. | **Template**:`p('text') newLine() p('text on new line')`**Output**:`text text on new line` |
| pi             | Renders an XML processing instruction.                       | **Template**:`pi("xml-stylesheet":[href:"mystyle.css", type:"text/css"])`**Output**:`` |
| tryEscape      | Returns an escaped string for an object, if it is a `String` (or any type derived from `CharSequence`). Otherwise returns the object itself. | **Template**:`yieldUnescaped tryEscape('Some text with ')`**Output**:`Some text with <angle brackets>` |

###### Includes

The `MarkupTemplateEngine` supports inclusion of contents from another file. Included contents may be:

- another template
- raw contents
- contents to be escaped

Including another template can be done using:

```groovy
include template: 'other_template.tpl'
```

Including a file as raw contents, without escaping it, can be done like this:

```groovy
include unescaped: 'raw.txt'
```

Eventually, inclusion of text that should be escaped before rendering can be done using:

```groovy
include escaped: 'to_be_escaped.txt'
```

Alternatively, you can use the following helper methods instead:

- `includeGroovy()` to include another template
- `includeEscaped()` to include another file with escaping
- `includeUnescaped()` to include another file without escaping

Calling those methods instead of the `include xxx:` syntax can be useful if the name of the file to be included is dynamic (stored in a variable for example). Files to be included (independently of their type, template or text) are found on **classpath**. This is one of the reasons why the `MarkupTemplateEngine` takes an optional `ClassLoader` as constructor argument (the other reason being that you can include code referencing other classes in a template).

If you don’t want your templates to be on classpath, the `MarkupTemplateEngine` accepts a convenient constructor that lets you define the directory where templates are to be found.

###### Fragments

Fragments are nested templates. They can be used to provide improved composition in a single template. A fragment consists of a string, the inner template, and a model, used to render this template. Consider the following template:

```groovy
ul {
    pages.each {
        fragment "li(line)", line:it
    }
}
```

The `fragment` element creates a nested template, and renders it with a model which is specific to this template. Here, we have the `li(line)` fragment, where `line` is bound to `it`. Since `it` corresponds to the iteration of `pages`, we will generate a single `li` element for each page in our model:

```html
<ul><li>Page 1</li><li>Page 2</li></ul>
```

Fragments are interesting to factorize template elements. They come at the price of the compilation of a fragment per template, and they cannot be externalized.

###### Layouts

Layouts, unlike fragments, refer to other templates. They can be used to compose templates and share common structures. This is often interesting if you have, for example, a common HTML page setup, and that you only want to replace the body. This can be done easily with a *layout*. First of all, you need to create a layout template:

layout-main.tpl

```groovy
html {
    head {
        title(title)                
    }
    body {
        bodyContents()              
    }
}
```

|      | the `title` variable (inside the title tag) is a layout variable |
| ---- | ------------------------------------------------------------ |
|      | the `bodyContents` call will render the body                 |

Then what you need is a template that includes the layout:

```groovy
layout 'layout-main.tpl',                                   
    title: 'Layout example',                                
    bodyContents: contents { p('This is the body') }        
```

|      | use the `main-layout.tpl` layout file |
| ---- | ------------------------------------- |
|      | set the `title` variable              |
|      | set the `bodyContents`                |

As you can see, `bodyContents` will be rendered inside the layout, thanks to the `bodyContents()` call in the layout file. As a result, the template will be rendered as this:

```html
<html><head><title>Layout example</title></head><body><p>This is the body</p></body></html>
```

The call to the `contents` method is used to tell the template engine that the block of code is in fact a specification of a template, instead of a helper function to be rendered directly. If you don’t add `contents` before your specification, then the contents would be rendered, but you would also see a random string generated, corresponding to the result value of the block.

Layouts are a powerful way to share common elements across multiple templates, without having to rewrite everything or use includes.

Layouts use, by default, a model which is independent from the model of the page where they are used. It is however possible to make them inherit from the parent model. Imagine that the model is defined like this:

```java
model = new HashMap<String,Object>();
model.put('title','Title from main model');
```

and the following template:

```groovy
layout 'layout-main.tpl', true,                             
    bodyContents: contents { p('This is the body') }
```

|      | note the use of `true` to enable model inheritance |
| ---- | -------------------------------------------------- |
|      |                                                    |

then it is not necessary to pass the `title` value to the layout as in the [previous example](https://docs.groovy-lang.org/latest/html/documentation/#example-layout-simple). The result will be:

```html
<html><head><title>Title from main model</title></head><body><p>This is the body</p></body></html>
```

But it is also possible to override a value from the parent model:

```groovy
layout 'layout-main.tpl', true,                             
    title: 'overridden title',                               
    bodyContents: contents { p('This is the body') }
```

|      | `true` means inherit from the parent model |
| ---- | ------------------------------------------ |
|      | but `title` is overridden                  |

then the output will be:

```html
<html><head><title>overridden title</title></head><body><p>This is the body</p></body></html>
```

##### Rendering contents

###### Creation of a template engine

On the server side, rendering templates require an instance of `groovy.text.markup.MarkupTemplateEngine` and a `groovy.text.markup.TemplateConfiguration`:

```java
TemplateConfiguration config = new TemplateConfiguration();         
MarkupTemplateEngine engine = new MarkupTemplateEngine(config);     
Template template = engine.createTemplate("p('test template')");    
Map<String, Object> model = new HashMap<>();                        
Writable output = template.make(model);                             
output.writeTo(writer);                                             
```

|      | creates a template configuration                  |
| ---- | ------------------------------------------------- |
|      | creates a template engine with this configuration |
|      | creates a template instance from a `String`       |
|      | creates a model to be used in the template        |
|      | bind the model to the template instance           |
|      | render output                                     |

There are several possible options to parse templates:

- from a `String`, using `createTemplate(String)`
- from a `Reader`, using `createTemplate(Reader)`
- from a `URL`, using `createTemplate(URL)`
- given a template name, using `createTemplateByPath(String)`

The last version should in general be preferred:

```groovy
Template template = engine.createTemplateByPath("main.tpl");
Writable output = template.make(model);
output.writeTo(writer);
```

###### Configuration options

The behavior of the engine can be tweaked with several configuration options accessible through the `TemplateConfiguration` class:

| Option              | Default value                                     | Description                                                  | Example                                                      |
| :------------------ | :------------------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| declarationEncoding | null                                              | Determines the value of the encoding to be written when `xmlDeclaration` is called. It does **not** influence the writer you are using as output. | **Template**:`xmlDeclaration()`**Output**:``If `TemplateConfiguration#getDeclarationEncoding` is not null:**Output**:`` |
| expandEmptyElements | false                                             | If true, empty tags are rendered in their expanded form.     | **Template**:`p()`**Output**:``If `expandEmptyElements` is true:**Output**:`` |
| useDoubleQuotes     | false                                             | If true, use double quotes for attributes instead of simple quotes | **Template**:`tag(attr:'value')`**Output**:``If `useDoubleQuotes` is true:**Output**:`` |
| newLineString       | System default (system property `line.separator`) | Allows to choose what string is used when a new line is rendered | **Template**:`p('foo') newLine() p('baz')`If `newLineString='BAR'`:**Output**:`fooBARbaz` |
| autoEscape          | false                                             | If true, variables from models are automatically escaped before rendering. | See [the auto escape section](https://docs.groovy-lang.org/latest/html/documentation/#markuptemplate-autoescape) |
| autoIndent          | false                                             | If true, performs automatic indentation after new lines      | See [the auto formatting section](https://docs.groovy-lang.org/latest/html/documentation/#markuptemplate-autoformat) |
| autoIndentString    | four (4) spaces                                   | The string to be used as indent.                             | See [the auto formatting section](https://docs.groovy-lang.org/latest/html/documentation/#markuptemplate-autoformat) |
| autoNewLine         | false                                             | If true, performs automatic insertion of new lines           | See [the auto formatting section](https://docs.groovy-lang.org/latest/html/documentation/#markuptemplate-autoformat) |
| baseTemplateClass   | `groovy.text.markup.BaseTemplate`                 | Sets the super class of compiled templates. This can be used to provide application specific templates. | See [the custom templates section](https://docs.groovy-lang.org/latest/html/documentation/#markuptemplate-basetemplate) |
| locale              | Default locale                                    | Sets the default locale for templates.                       | See [the internationalization section](https://docs.groovy-lang.org/latest/html/documentation/#markuptemplate-i18n) |

|      | Once the template engine has been created, it is **unsafe** to change the configuration. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Automatic formatting

By default, the template engine will render output without any specific formatting. Some [configuration options](https://docs.groovy-lang.org/latest/html/documentation/#markuptemplate-config) can improve the situation:

- `autoIndent` is responsible for auto-indenting after a new line is inserted
- `autoNewLine` is responsible for automatically inserting new lines based on the original formatting of the template source

In general, it is recommended to set both `autoIndent` and `autoNewLine` to true if you want human-readable, pretty printed, output:

```java
config.setAutoNewLine(true);
config.setAutoIndent(true);
```

Using the following template:

```groovy
html {
    head {
        title('Title')
    }
}
```

The output will now be:

```html
<html>
    <head>
        <title>Title</title>
    </head>
</html>
```

We can slightly change the template so that the `title` instruction is found on the same line as the `head` one:

```groovy
html {
    head { title('Title')
    }
}
```

And the output will reflect that:

```html
<html>
    <head><title>Title</title>
    </head>
</html>
```

New lines are **only** inserted where curly braces for tags are found, and the insertion corresponds to where the nested content is found. This means that tags in the body of another tag will **not** trigger new lines unless they use curly braces themselves:

```groovy
html {
    head {
        meta(attr:'value')          
        title('Title')              
        newLine()                   
        meta(attr:'value2')         
    }
}
```

|      | a new line is inserted because `meta` is not on the same line as `head` |
| ---- | ------------------------------------------------------------ |
|      | no new line is inserted, because we’re on the same depth as the previous tag |
|      | we can force rendering of a new line by explicitly calling `newLine` |
|      | and this tag will be rendered on a separate line             |

This time, the output will be:

```html
<html>
    <head>
        <meta attr='value'/><title>Title</title>
        <meta attr='value2'/>
    </head>
</html>
```

By default, the renderer uses four(4) spaces as indent, but you can change it by setting the `TemplateConfiguration#autoIndentString` property.

###### Automatic escaping

By default, contents which is read from the model is rendered **as is**. If this contents comes from user input, it can be sensible, and you might want to escape it by default, for example to avoid XSS injection. For that, the template configuration provides an option which will automatically escape objects from the model, as long as they inherit from `CharSequence` (typically, `String`s).

Let’s imagine the following setup:

```groovy
config.setAutoEscape(false);
model = new HashMap<String,Object>();
model.put("unsafeContents", "I am an <html> hacker.");
```

and the following template:

```groovy
html {
    body {
        div(unsafeContents)
    }
}
```

Then you wouldn’t want the HTML from `unsafeContents` to be rendered as is, because of potential security issues:

```html
<html><body><div>I am an <html> hacker.</div></body></html>
```

Automatic escaping will fix this:

```groovy
config.setAutoEscape(true);
```

And now the output is properly escaped:

```html
<html><body><div>I am an &lt;html&gt; hacker.</div></body></html>
```

Note that using automatic escaping doesn’t prevent you from including unescaped contents from the model. To do this, your template should then explicitly mention that a model variable should not be escaped by prefixing it with `unescaped.`, like in this example:

Explicit bypass of automatic escaping

```html
html {
    body {
        div(unescaped.unsafeContents)
    }
}
```

###### Common gotchas

Strings containing markup

Say that you want to generate a `` tag which contains a string containing markup:

```groovy
p {
    yield "This is a "
    a(href:'target.html', "link")
    yield " to another page"
}
```

and generates:

```html
<p>This is a <a href='target.html'>link</a> to another page</p>
```

Can’t this be written shorter? A naive alternative would be:

```groovy
p {
    yield "This is a ${a(href:'target.html', "link")} to another page"
}
```

but the result will not look as expected:

```groovy
<p><a href='target.html'>link</a>This is a  to another page</p>
```

The reason is that the markup template engine is a *streaming* engine. In the original version, the first `yield` call generates a string which is streamed to the output, then the `a` link is generated and streamed, and then the last `yield` call is streamed, leading in an execution **in order**. But with the string version above, the order of execution is different:

- the `yield` call requires an argument, a *string*
- that arguments needs to be evaluated *before* the *yield* call is generated

so evaluating the string leads to an execution of the `a(href:…)` call **before** `yield` is itself called. This is not what you want to do. Instead, you want to generate a *string* which contains markup, which is then passed to the `yield` call. This can be done this way:

```groovy
p("This is a ${stringOf {a(href:'target.html', "link")}} to another page")
```

Note the `stringOf` call, which basically tells the markup template engine that the underlying markup needs to be rendered separately and exported as a string. Note that for simple expressions, `stringOf` can be replaced by an alternate tag notation that starts with a *dollar* sign:

```groovy
p("This is a ${$a(href:'target.html', "link")} to another page")
```

|      | It is worth noting that using `stringOf` or the special `$tag` notation triggers the creation of a distinct string writer which is then used to render the markup. It is slower than using the version with calls to `yield` which perform direct streaming of the markup instead. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Internationalization

The template engine has native support for internationalization. For that, when you create the `TemplateConfiguration`, you can provide a `Locale` which is the default locale to be used for templates. Each template may have different versions, one for each locale. The name of the template makes the difference:

- `file.tpl`: default template file
- `file_fr_FR.tpl`: french version of the template
- `file_en_US.tpl`: american english version of the template
- …

When a template is rendered or included, then:

- if the template name or include name **explicitly** sets a locale, the **specific** version is included, or the default version if not found
- if the template name doesn’t include a locale, the version for the `TemplateConfiguration` locale is used, or the default version if not found

For example, imagine the default locale is set to `Locale.ENGLISH` and that the main template includes:

Use an explicit locale in include

```groovy
include template: 'locale_include_fr_FR.tpl'
```

then the template is rendered using the specific template:

Bypass the template configuration

```html
Texte en français
```

Using an include without specifying a locale will make the template engine look for a template with the configured locale, and if not, fallback to the default, like here:

Don’t use a locale in include

```groovy
include template: 'locale_include.tpl'
```

Fallback to the default template

```html
Default text
```

However, changing the default locale of the template engine to `Locale.FRANCE` will change the output, because the template engine will now look for a file with the `fr_FR` locale:

Don’t fallback to the default template because a locale specific template was found

```html
Texte en français
```

This strategy lets you translate your templates one by one, by relying on default templates, for which no locale is set in the file name.

###### Custom template classes

By default, templates created inherit the `groovy.text.markup.BaseTemplate` class. It may be interesting for an application to provide a different template class, for example to provide additional helper methods which are aware of the application, or customized rendering primitives (for HTML, for example).

The template engine provides this ability by setting an alternative `baseTemplateClass` in the `TemplateConfiguration`:

```java
config.setBaseTemplateClass(MyTemplate.class);
```

The custom base class has to extend `BaseClass` like in this example:

```groovy
public abstract class MyTemplate extends BaseTemplate {
    private List<Module> modules
    public MyTemplate(
            final MarkupTemplateEngine templateEngine,
            final Map model,
            final Map<String, String> modelTypes,
            final TemplateConfiguration configuration) {
        super(templateEngine, model, modelTypes, configuration)
    }

    List<Module> getModules() {
        return modules
    }

    void setModules(final List<Module> modules) {
        this.modules = modules
    }

    boolean hasModule(String name) {
        modules?.any { it.name == name }
    }
}
```

This example shows a class which provides an additional method named `hasModule`, which can then be used directly in the template:

```groovy
if (hasModule('foo')) {
    p 'Found module [foo]'
} else {
    p 'Module [foo] not found'
}
```

##### Type checked templates

###### Optional type checking

Even if templates are not type checked, they are statically compiled. This means that once the templates are compiled, performance should be very good. For some applications, it might be good to make sure that templates are valid before they are actually rendered. This means failing template compilation, for example, if a method on a model variable doesn’t exist.

The `MarkupTemplateEngine` provides such a facility. Templates can be optionally type checked. For that, the developer must provide additional information at template creation time, which is the types of the variables found in the model. Imagine a model exposing a list of pages, where a page is defined as:

Page.groovy

```groovy
public class Page {

    Long id
    String title
    String body
}
```

Then a list of pages can be exposed in the model, like this:

```groovy
Page p = new Page();
p.setTitle("Sample page");
p.setBody("Page body");
List<Page> pages = new LinkedList<>();
pages.add(p);
model = new HashMap<String,Object>();
model.put("pages", pages);
```

A template can use it easily:

```groovy
pages.each { page ->                    
    p("Page title: $page.title")        
    p(page.text)                        
}
```

|      | iterate on pages from the model                |
| ---- | ---------------------------------------------- |
|      | `page.title` is valid                          |
|      | `page.text` is **not** (should be `page.body`) |

Without type checking, the compilation of the template succeeds, because the template engine doesn’t know about the model until a page is actually rendered. This means that the problem would only surface at runtime, once the page is rendered:

Runtime error

```
No such property: text
```

In some situations, this can be complicated to sort out or even notice. By declaring the type of the `pages` to the template engine, we’re now capable of failing at compile time:

```groovy
modelTypes = new HashMap<String,String>();                                          
modelTypes.put("pages", "List<Page>");                                              
Template template = engine.createTypeCheckedModelTemplate("main.tpl", modelTypes)   
```

|      | create a map which will hold the model types                 |
| ---- | ------------------------------------------------------------ |
|      | declare the type of the `pages` variables (note the use of a string for the type) |
|      | use `createTypeCheckedModelTemplate` instead of `createTemplate` |

This time, when the template is compiled at the last line, an error occurs:

Template compilation time error

```
[Static type checking] - No such property: text for class: Page
```

This means that you don’t need to wait for the page to be rendered to see an error. The use of `createTypeCheckedModelTemplate` is mandatory.

###### Alternative declaration of types

Alternatively, if the developer is also the one who writes the templates, it is possible to declare the types of the expected variables directly in the template. In this case, even if you call `createTemplate`, it will be type checked:

Inline declaration of types

```groovy
modelTypes = {                          
    List<Page> pages                    
}

pages.each { page ->
    p("Page title: $page.title")
    p(page.text)
}
```

|      | types need to be declared in the `modelTypes` header |
| ---- | ---------------------------------------------------- |
|      | declare one variable per object in the model         |

###### Performance of type checked templates

An additional interest of using type checked models is that performance should improve. By telling the type checker what are the expected types, you also let the compiler generate optimized code for that, so if you are looking for the best performance, consider using type checked templates.

#### 3.12.8. Other solutions

Also, there are other templating solutions that can be used along with Groovy, such as [FreeMarker](http://freemarker.org/), [Velocity](http://velocity.apache.org/), [StringTemplate](http://stringtemplate.org/) and others.

### 3.13. Servlet support

You can write (Java) Servlets in Groovy (called Groovlets).

There is also a `GroovyServlet`.

This feature will automatically compile your .groovy source files, turn them into bytecode, load the Class and cache it until you change the source file.

Here’s a simple example to show you the kind of things you can do from a Groovlet.

Notice the use of implicit variables to access the session, output and request. Also notice that this is more like a script as it does not have a class wrapper.

```groovy
if (!session) {
  session = request.getSession(true)
}

if (!session.counter) {
  session.counter = 1
}

println """
<html>
    <head>
        <title>Groovy Servlet</title>
    </head>
    <body>
        <p>
Hello, ${request.remoteHost}: ${session.counter}! ${new Date()}
        </p>
    </body>
</html>
"""
session.counter = session.counter + 1
```

Or, do the same thing using MarkupBuilder:

```groovy
if (!session) {
    session = request.getSession(true)
}

if (!session.counter) {
    session.counter = 1
}

html.html { // html is implicitly bound to new MarkupBuilder(out)
  head {
      title('Groovy Servlet')
  }
  body {
    p("Hello, ${request.remoteHost}: ${session.counter}! ${new Date()}")
  }
}
session.counter = session.counter + 1
```

#### 3.13.1. Implicit variables

The following variables are ready for use in Groovlets:

| variable name | bound to                      | note                 |
| :------------ | :---------------------------- | :------------------- |
| request       | ServletRequest                | -                    |
| response      | ServletResponse               | -                    |
| context       | ServletContext                | -                    |
| application   | ServletContext                | -                    |
| session       | getSession(false)             | can be null! see <1> |
| params        |                               | a Map object         |
| headers       |                               | a Map object         |
| out           | response.getWriter()          | see <2>              |
| sout          | response.getOutputStream()    | see <2>              |
| html          | new MarkupBuilder(out)        | see <2>              |
| json          | new StreamingJsonBuilder(out) | see <2>              |

1. The session variable is only set, if there was already a session object. See the `if (session == null)` checks in the examples above.
2. These variables cannot be re-assigned inside a `Groovlet`. They are bound on first access, allowing to e.g. calling methods on the `response` object before using `out`.

#### 3.13.2. Setting up groovylets

Add the following to your `web.xml`:

```xml
<servlet>
    <servlet-name>Groovy</servlet-name>
    <servlet-class>groovy.servlet.GroovyServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>Groovy</servlet-name>
    <url-pattern>*.groovy</url-pattern>
</servlet-mapping>
```

Then put the required groovy jar files into `WEB-INF/lib`.

Now put the .groovy files in, say, the root directory (i.e. where you would put your html files). The `GroovyServlet` takes care of compiling the .groovy files.

So for example using tomcat you could edit `tomcat/conf/server.xml` like this:

```xml
<Context path="/groovy" docBase="c:/groovy-servlet"/>
```

Then access it with http://localhost:8080/groovy/hello.groovy

### 3.14. Integrating Groovy in a Java application

#### 3.14.1. Groovy integration mechanisms

The Groovy language proposes several ways to integrate itself into applications (Java or even Groovy) at runtime, from the most basic, simple code execution to the most complete, integrating caching and compiler customization.

|      | All the examples written in this section are using Groovy, but the same integration mechanisms can be used from Java. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Eval

The `groovy.util.Eval` class is the simplest way to execute Groovy dynamically at runtime. This can be done by calling the `me` method:

```groovy
import groovy.util.Eval

assert Eval.me('33*3') == 99
assert Eval.me('"foo".toUpperCase()') == 'FOO'
```

`Eval` supports multiple variants that accept parameters for simple evaluation:

```groovy
assert Eval.x(4, '2*x') == 8                
assert Eval.me('k', 4, '2*k') == 8          
assert Eval.xy(4, 5, 'x*y') == 20           
assert Eval.xyz(4, 5, 6, 'x*y+z') == 26     
```

|      | Simple evaluation with one bound parameter named `x`         |
| ---- | ------------------------------------------------------------ |
|      | Same evaluation, with a custom bound parameter named `k`     |
|      | Simple evaluation with two bound parameters named `x` and `y` |
|      | Simple evaluation with three bound parameters named `x`, `y` and `z` |

The `Eval` class makes it very easy to evaluate simple scripts, but doesn’t scale: there is no caching of the script, and it isn’t meant to evaluate more than one liners.

##### GroovyShell

###### Multiple sources

The `groovy.lang.GroovyShell` class is the preferred way to evaluate scripts with the ability to cache the resulting script instance. Although the `Eval` class returns the result of the execution of the compiled script, the `GroovyShell` class offers more options.

```groovy
def shell = new GroovyShell()                           
def result = shell.evaluate '3*5'                       
def result2 = shell.evaluate(new StringReader('3*5'))   
assert result == result2
def script = shell.parse '3*5'                          
assert script instanceof groovy.lang.Script
assert script.run() == 15                               
```

|      | create a new `GroovyShell` instance                          |
| ---- | ------------------------------------------------------------ |
|      | can be used as `Eval` with direct execution of the code      |
|      | can read from multiple sources (`String`, `Reader`, `File`, `InputStream`) |
|      | can defer execution of the script. `parse` returns a `Script` instance |
|      | `Script` defines a `run` method                              |

###### Sharing data between a script and the application

It is possible to share data between the application and the script using a `groovy.lang.Binding`:

```groovy
def sharedData = new Binding()                          
def shell = new GroovyShell(sharedData)                 
def now = new Date()
sharedData.setProperty('text', 'I am shared data!')     
sharedData.setProperty('date', now)                     

String result = shell.evaluate('"At $date, $text"')     

assert result == "At $now, I am shared data!"
```

|      | create a new `Binding` that will contain shared data         |
| ---- | ------------------------------------------------------------ |
|      | create a `GroovyShell` using this shared data                |
|      | add a string to the binding                                  |
|      | add a date to the binding (you are not limited to simple types) |
|      | evaluate the script                                          |

Note that it is also possible to write from the script into the binding:

```groovy
def sharedData = new Binding()                          
def shell = new GroovyShell(sharedData)                 

shell.evaluate('foo=123')                               

assert sharedData.getProperty('foo') == 123             
```

|      | create a new `Binding` instance                              |
| ---- | ------------------------------------------------------------ |
|      | create a new `GroovyShell` using that shared data            |
|      | use an **undeclared** variable to store the result into the binding |
|      | read the result from the caller                              |

It is important to understand that you need to use an undeclared variable if you want to write into the binding. Using `def` or an `explicit` type like in the example below would fail because you would then create a *local variable*:

```groovy
def sharedData = new Binding()
def shell = new GroovyShell(sharedData)

shell.evaluate('int foo=123')

try {
    assert sharedData.getProperty('foo')
} catch (MissingPropertyException e) {
    println "foo is defined as a local variable"
}
```

|      | You must be very careful when using shared data in a multithreaded environment. The `Binding` instance that you pass to `GroovyShell` is **not** thread safe, and shared by all scripts. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

It is possible to work around the shared instance of `Binding` by leveraging the `Script` instance which is returned by `parse`:

```groovy
def shell = new GroovyShell()

def b1 = new Binding(x:3)                       
def b2 = new Binding(x:4)                       
def script = shell.parse('x = 2*x')
script.binding = b1
script.run()
script.binding = b2
script.run()
assert b1.getProperty('x') == 6
assert b2.getProperty('x') == 8
assert b1 != b2
```

|      | will store the `x` variable inside `b1` |
| ---- | --------------------------------------- |
|      | will store the `x` variable inside `b2` |

However, you must be aware that you are still sharing the **same instance** of a script. So this technique cannot be used if you have two threads working on the same script. In that case, you must make sure of creating two distinct script instances:

```groovy
def shell = new GroovyShell()

def b1 = new Binding(x:3)
def b2 = new Binding(x:4)
def script1 = shell.parse('x = 2*x')            
def script2 = shell.parse('x = 2*x')            
assert script1 != script2
script1.binding = b1                            
script2.binding = b2                            
def t1 = Thread.start { script1.run() }         
def t2 = Thread.start { script2.run() }         
[t1,t2]*.join()                                 
assert b1.getProperty('x') == 6
assert b2.getProperty('x') == 8
assert b1 != b2
```

|      | create an instance of script for thread 1 |
| ---- | ----------------------------------------- |
|      | create an instance of script for thread 2 |
|      | assign first binding to script 1          |
|      | assign second binding to script 2         |
|      | start first script in a separate thread   |
|      | start second script in a separate thread  |
|      | wait for completion                       |

In case you need thread safety like here, it is more advisable to use the [GroovyClassLoader](https://docs.groovy-lang.org/latest/html/documentation/#groovyclassloader) directly instead.

###### Custom script class

We have seen that the `parse` method returns an instance of `groovy.lang.Script`, but it is possible to use a custom class, given that it extends `Script` itself. It can be used to provide additional behavior to the script like in the example below:

```groovy
abstract class MyScript extends Script {
    String name

    String greet() {
        "Hello, $name!"
    }
}
```

The custom class defines a property called `name` and a new method called `greet`. This class can be used as the script base class by using a custom configuration:

```groovy
import org.codehaus.groovy.control.CompilerConfiguration

def config = new CompilerConfiguration()                                    
config.scriptBaseClass = 'MyScript'                                         

def shell = new GroovyShell(this.class.classLoader, new Binding(), config)  
def script = shell.parse('greet()')                                         
assert script instanceof MyScript
script.setName('Michel')
assert script.run() == 'Hello, Michel!'
```

|      | create a `CompilerConfiguration` instance                    |
| ---- | ------------------------------------------------------------ |
|      | instruct it to use `MyScript` as the base class for scripts  |
|      | then use the compiler configuration when you create the shell |
|      | the script now has access to the new method `greet`          |

|      | You are not limited to the sole *scriptBaseClass* configuration. You can use any of the compiler configuration tweaks, including the [compilation customizers](https://docs.groovy-lang.org/latest/html/documentation/#compilation-customizers). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### GroovyClassLoader

In the [previous section](https://docs.groovy-lang.org/latest/html/documentation/#integ-groovyshell), we have shown that `GroovyShell` was an easy tool to execute scripts, but it makes it complicated to compile anything but scripts. Internally, it makes use of the `groovy.lang.GroovyClassLoader`, which is at the heart of the compilation and loading of classes at runtime.

By leveraging the `GroovyClassLoader` instead of `GroovyShell`, you will be able to load classes, instead of instances of scripts:

```groovy
import groovy.lang.GroovyClassLoader

def gcl = new GroovyClassLoader()                                           
def clazz = gcl.parseClass('class Foo { void doIt() { println "ok" } }')    
assert clazz.name == 'Foo'                                                  
def o = clazz.newInstance()                                                 
o.doIt()                                                                    
```

|      | create a new `GroovyClassLoader`                             |
| ---- | ------------------------------------------------------------ |
|      | `parseClass` will return an instance of `Class`              |
|      | you can check that the class which is returns is really the one defined in the script |
|      | and you can create a new instance of the class, which is not a script |
|      | then call any method on it                                   |

|      | A GroovyClassLoader keeps a reference of all the classes it created, so it is easy to create a memory leak. In particular, if you execute the same script twice, if it is a String, then you obtain two distinct classes! |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```groovy
import groovy.lang.GroovyClassLoader

def gcl = new GroovyClassLoader()
def clazz1 = gcl.parseClass('class Foo { }')                                
def clazz2 = gcl.parseClass('class Foo { }')                                
assert clazz1.name == 'Foo'                                                 
assert clazz2.name == 'Foo'
assert clazz1 != clazz2                                                     
```

|      | dynamically create a class named "Foo"                       |
| ---- | ------------------------------------------------------------ |
|      | create an identical looking class, using a separate `parseClass` call |
|      | make sure both classes have the same name                    |
|      | but they are actually different!                             |

The reason is that a `GroovyClassLoader` doesn’t keep track of the source text. If you want to have the same instance, then the source **must** be a file, like in this example:

```groovy
def gcl = new GroovyClassLoader()
def clazz1 = gcl.parseClass(file)                                           
def clazz2 = gcl.parseClass(new File(file.absolutePath))                    
assert clazz1.name == 'Foo'                                                 
assert clazz2.name == 'Foo'
assert clazz1 == clazz2                                                     
```

|      | parse a class from a `File`                                  |
| ---- | ------------------------------------------------------------ |
|      | parse a class from a distinct file instance, but pointing to the same physical file |
|      | make sure our classes have the same name                     |
|      | but now, they are the same instance                          |

Using a `File` as input, the `GroovyClassLoader` is capable of **caching** the generated class file, which avoids creating multiple classes at runtime for the same source.

##### GroovyScriptEngine

The `groovy.util.GroovyScriptEngine` class provides a flexible foundation for applications which rely on script reloading and script dependencies. While `GroovyShell` focuses on standalone `Script`s and `GroovyClassLoader` handles dynamic compilation and loading of any Groovy class, the `GroovyScriptEngine` will add a layer on top of `GroovyClassLoader` to handle both script dependencies and reloading.

To illustrate this, we will create a script engine and execute code in an infinite loop. First of all, you need to create a directory with the following script inside:

ReloadingTest.groovy

```groovy
class Greeter {
    String sayHello() {
        def greet = "Hello, world!"
        greet
    }
}

new Greeter()
```

then you can execute this code using a `GroovyScriptEngine`:

```groovy
def binding = new Binding()
def engine = new GroovyScriptEngine([tmpDir.toURI().toURL()] as URL[])          

while (true) {
    def greeter = engine.run('ReloadingTest.groovy', binding)                   
    println greeter.sayHello()                                                  
    Thread.sleep(1000)
}
```

|      | create a script engine which will look for sources into our source directory |
| ---- | ------------------------------------------------------------ |
|      | execute the script, which will return an instance of `Greeter` |
|      | print the greeting message                                   |

At this point, you should see a message printed every second:

```
Hello, world!
Hello, world!
...
```

**Without** interrupting the script execution, now replace the contents of the `ReloadingTest` file with:

ReloadingTest.groovy

```groovy
class Greeter {
    String sayHello() {
        def greet = "Hello, Groovy!"
        greet
    }
}

new Greeter()
```

And the message should change to:

```
Hello, world!
...
Hello, Groovy!
Hello, Groovy!
...
```

But it is also possible to have a dependency on another script. To illustrate this, create the following file into the same directory, without interrupting the executing script:

Depencency.groovy

```groovy
class Dependency {
    String message = 'Hello, dependency 1'
}
```

and update the `ReloadingTest` script like this:

ReloadingTest.groovy

```groovy
import Dependency

class Greeter {
    String sayHello() {
        def greet = new Dependency().message
        greet
    }
}

new Greeter()
```

And this time, the message should change to:

```
Hello, Groovy!
...
Hello, dependency 1!
Hello, dependency 1!
...
```

And as a last test, you can update the `Dependency.groovy` file without touching the `ReloadingTest` file:

Depencency.groovy

```groovy
class Dependency {
    String message = 'Hello, dependency 2'
}
```

And you should observe that the dependent file was reloaded:

```
Hello, dependency 1!
...
Hello, dependency 2!
Hello, dependency 2!
```

##### CompilationUnit

Ultimately, it is possible to perform more operations during compilation by relying directly on the `org.codehaus.groovy.control.CompilationUnit` class. This class is responsible for determining the various steps of compilation and would let you introduce new steps or even stop compilation at various phases. This is for example how stub generation is done, for the joint compiler.

However, overriding `CompilationUnit` is not recommended and should only be done if no other standard solution works.

#### 3.14.2. Bean Scripting Framework

|      | The [Bean Scripting Framework](http://commons.apache.org/proper/commons-bsf/) is an attempt to create an API to allow calling scripting languages from Java. It hasn’t been updated for long and abandoned in favor of the standard [JSR-223](https://docs.groovy-lang.org/latest/html/documentation/#jsr223) API. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

The BSF engine for Groovy is implemented by the `org.codehaus.groovy.bsf.GroovyEngine` class. However, that fact is normally hidden away by the BSF APIs. You just treat Groovy like any of the other scripting languages via the BSF API.

|      | Since Groovy has its own native support for integration with Java, you only need to worry about BSF if you also want to also be able to call other languages, e.g. [JRuby](https://www.jruby.org/) or if you want to remain very loosely coupled from your scripting language. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

##### Getting started

Provided you have Groovy and BSF jars in your classpath, you can use the following Java code to run a sample Groovy script:

```java
String myScript = "println('Hello World')\n  return [1, 2, 3]";
BSFManager manager = new BSFManager();
List answer = (List) manager.eval("groovy", "myScript.groovy", 0, 0, myScript);
assertEquals(3, answer.size());
```

##### Passing in variables

BSF lets you pass beans between Java and your scripting language. You can *register*/*unregister* beans which makes them known to BSF. You can then use BSF methods to *lookup* beans as required. Alternatively, you can *declare*/*undeclare* beans. This will register them but also make them available for use directly in your scripting language. This second approach is the normal approach used with Groovy. Here is an example:

```java
BSFManager manager = new BSFManager();
manager.declareBean("xyz", 4, Integer.class);
Object answer = manager.eval("groovy", "test.groovy", 0, 0, "xyz + 1");
assertEquals(5, answer);
```

##### Other calling options

The previous examples used the *eval* method. BSF makes multiple methods available for your use (see the [BSF documentation](http://commons.apache.org/proper/commons-bsf/manual.html) for more details). One of the other available methods is *apply*. It allows you to define an anonymous function in your scripting language and apply that function to arguments. Groovy supports this function using closures. Here is an example:

```java
BSFManager manager = new BSFManager();
Vector<String> ignoreParamNames = null;
Vector<Integer> args = new Vector<>();
args.add(2);
args.add(5);
args.add(1);
Integer actual = (Integer) manager.apply("groovy", "applyTest", 0, 0,
        "def summer = { a, b, c -> a * 100 + b * 10 + c }", ignoreParamNames, args);
assertEquals(251, actual.intValue());
```

##### Access to the scripting engine

Although you don’t normally need it, BSF does provide a hook that lets you get directly to the scripting engine. One of the functions which the engine can perform is to invoke a single method call on an object. Here is an example:

```java
BSFManager manager = new BSFManager();
BSFEngine bsfEngine = manager.loadScriptingEngine("groovy");
manager.declareBean("myvar", "hello", String.class);
Object myvar = manager.lookupBean("myvar");
String result = (String) bsfEngine.call(myvar, "reverse", new Object[0]);
assertEquals("olleh", result);
```

#### 3.14.3. JSR 223 javax.script API

|      | JSR-223 is a standard API for calling scripting frameworks in Java. It is available since Java 6 and aims at providing a common framework for calling multiple languages from Java. Groovy provides its own richer integration mechanisms, and if you don’t plan to use multiple languages in the same application, it is recommended that you use the Groovy integration mechanisms instead of the limited JSR-223 API. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Here is how you need to initialize the JSR-223 engine to talk to Groovy from Java:

```java
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
...
ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine = factory.getEngineByName("groovy");
```

Then you can execute Groovy scripts easily:

```java
Integer sum = (Integer) engine.eval("(1..10).sum()");
assertEquals(new Integer(55), sum);
```

It is also possible to share variables:

```java
engine.put("first", "HELLO");
engine.put("second", "world");
String result = (String) engine.eval("first.toLowerCase() + ' ' + second.toUpperCase()");
assertEquals("hello WORLD", result);
```

This next example illustrates calling an invokable function:

```java
import javax.script.Invocable;
...
ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine = factory.getEngineByName("groovy");
String fact = "def factorial(n) { n == 1 ? 1 : n * factorial(n - 1) }";
engine.eval(fact);
Invocable inv = (Invocable) engine;
Object[] params = {5};
Object result = inv.invokeFunction("factorial", params);
assertEquals(new Integer(120), result);
```

The engine keeps per default hard references to the script functions. To change this you should set a engine level scoped attribute to the script context of the name `#jsr223.groovy.engine.keep.globals` with a String being `phantom` to use phantom references, `weak` to use weak references or `soft` to use soft references - casing is ignored. Any other string will cause the use of hard references.

### 3.15. Domain-Specific Languages

#### 3.15.1. Command chains

Groovy lets you omit parentheses around the arguments of a method call for top-level statements. "command chain" feature extends this by allowing us to chain such parentheses-free method calls, requiring neither parentheses around arguments, nor dots between the chained calls. The general idea is that a call like `a b c d` will actually be equivalent to `a(b).c(d)`. This also works with multiple arguments, closure arguments, and even named arguments. Furthermore, such command chains can also appear on the right-hand side of assignments. Let’s have a look at some examples supported by this new syntax:

```groovy
// equivalent to: turn(left).then(right)
turn left then right

// equivalent to: take(2.pills).of(chloroquinine).after(6.hours)
take 2.pills of chloroquinine after 6.hours

// equivalent to: paint(wall).with(red, green).and(yellow)
paint wall with red, green and yellow

// with named parameters too
// equivalent to: check(that: margarita).tastes(good)
check that: margarita tastes good

// with closures as parameters
// equivalent to: given({}).when({}).then({})
given { } when { } then { }
```

It is also possible to use methods in the chain which take no arguments, but in that case, the parentheses are needed:

```groovy
// equivalent to: select(all).unique().from(names)
select all unique() from names
```

If your command chain contains an odd number of elements, the chain will be composed of method / arguments, and will finish by a final property access:

```groovy
// equivalent to: take(3).cookies
// and also this: take(3).getCookies()
take 3 cookies
```

This command chain approach opens up interesting possibilities in terms of the much wider range of DSLs which can now be written in Groovy.

The above examples illustrate using a command chain based DSL but not how to create one. There are various strategies that you can use, but to illustrate creating such a DSL, we will show a couple of examples - first using maps and Closures:

```groovy
show = { println it }
square_root = { Math.sqrt(it) }

def please(action) {
  [the: { what ->
    [of: { n -> action(what(n)) }]
  }]
}

// equivalent to: please(show).the(square_root).of(100)
please show the square_root of 100
// ==> 10.0
```

As a second example, consider how you might write a DSL for simplifying one of your existing APIs. Maybe you need to put this code in front of customers, business analysts or testers who might be not hard-core Java developers. We’ll use the `Splitter` from the Google [Guava libraries](https://github.com/google/guava) project as it already has a nice Fluent API. Here is how we might use it out of the box:

```groovy
@Grab('com.google.guava:guava:r09')
import com.google.common.base.*
def result = Splitter.on(',').trimResults(CharMatcher.is('_' as char)).split("_a ,_b_ ,c__").iterator().toList()
```

It reads fairly well for a Java developer but if that is not your target audience or you have many such statements to write, it could be considered a little verbose. Again, there are many options for writing a DSL. We’ll keep it simple with Maps and Closures. We’ll first write a helper method:

```groovy
@Grab('com.google.guava:guava:r09')
import com.google.common.base.*
def split(string) {
  [on: { sep ->
    [trimming: { trimChar ->
      Splitter.on(sep).trimResults(CharMatcher.is(trimChar as char)).split(string).iterator().toList()
    }]
  }]
}
```

now instead of this line from our original example:

```groovy
def result = Splitter.on(',').trimResults(CharMatcher.is('_' as char)).split("_a ,_b_ ,c__").iterator().toList()
```

we can write this:

```groovy
def result = split "_a ,_b_ ,c__" on ',' trimming '_\'
```

#### 3.15.2. Operator overloading

Various operators in Groovy are mapped onto regular method calls on objects.

This allows you to provide your own Java or Groovy objects which can take advantage of operator overloading. The following table describes the operators supported in Groovy and the methods they map to.

| Operator                  | Method                  |
| :------------------------ | :---------------------- |
| `a + b`                   | a.plus(b)               |
| `a - b`                   | a.minus(b)              |
| `a * b`                   | a.multiply(b)           |
| `a ** b`                  | a.power(b)              |
| `a / b`                   | a.div(b)                |
| `a % b`                   | a.mod(b)                |
| `a | b`                   | a.or(b)                 |
| `a & b`                   | a.and(b)                |
| `a ^ b`                   | a.xor(b)                |
| `a++` or `++a`            | a.next()                |
| `a--` or `--a`            | a.previous()            |
| `a[b]`                    | a.getAt(b)              |
| `a[b] = c`                | a.putAt(b, c)           |
| `a << b`                  | a.leftShift(b)          |
| `a >> b`                  | a.rightShift(b)         |
| `a >>> b`                 | a.rightShiftUnsigned(b) |
| `switch(a) { case(b) : }` | b.isCase(a)             |
| `if(a)`                   | a.asBoolean()           |
| `~a`                      | a.bitwiseNegate()       |
| `-a`                      | a.negative()            |
| `+a`                      | a.positive()            |
| `a as b`                  | a.asType(b)             |
| `a == b`                  | a.equals(b)             |
| `a != b`                  | ! a.equals(b)           |
| `a <=> b`                 | a.compareTo(b)          |
| `a > b`                   | a.compareTo(b) > 0      |
| `a >= b`                  | a.compareTo(b) >= 0     |
| `a < b`                   | a.compareTo(b) < 0      |
| `a <= b`                  | a.compareTo(b) <= 0     |

#### 3.15.3. Script base classes

##### The Script class

Groovy scripts are always compiled to classes. For example, a script as simple as:

```groovy
println 'Hello from Groovy'
```

is compiled to a class extending the abstract [groovy.lang.Script](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/Script.html) class. This class contains a single abstract method called *run*. When a script is compiled, then its body will become the *run* method, while the other methods found in the script are found in the implementing class. The `Script` class provides base support for integration with your application through the `Binding` object, as illustrated in this example:

```groovy
def binding = new Binding()             
def shell = new GroovyShell(binding)    
binding.setVariable('x',1)              
binding.setVariable('y',3)
shell.evaluate 'z=2*x+y'                
assert binding.getVariable('z') == 5    
```

|      | a binding is used to share data between the script and the calling class |
| ---- | ------------------------------------------------------------ |
|      | a `GroovyShell` can be used with this binding                |
|      | input variables are set from the calling class inside the binding |
|      | then the script is evaluated                                 |
|      | and the `z` variable has been "exported" into the binding    |

This is a very practical way to share data between the caller and the script, however it may be insufficient or not practical in some cases. For that purpose, Groovy allows you to set your own base script class. A base script class has to extend [groovy.lang.Script](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/Script.html) and be a single abstract method type:

```groovy
abstract class MyBaseClass extends Script {
    String name
    public void greet() { println "Hello, $name!" }
}
```

Then the custom script base class can be declared in the compiler configuration, for example:

```groovy
def config = new CompilerConfiguration()                                
config.scriptBaseClass = 'MyBaseClass'                                  
def shell = new GroovyShell(this.class.classLoader, config)             
shell.evaluate """
    setName 'Judith'                                                    
    greet()
"""
```

|      | create a custom compiler configuration                       |
| ---- | ------------------------------------------------------------ |
|      | set the base script class to our custom base script class    |
|      | then create a `GroovyShell` using that configuration         |
|      | the script will then extend the base script class, giving direct access to the `name` property and `greet` method |

##### The @BaseScript annotation

As an alternative, it is also possible to use the `@BaseScript` annotation directly into a script:

```groovy
import groovy.transform.BaseScript

@BaseScript MyBaseClass baseScript
setName 'Judith'
greet()
```

where `@BaseScript` should annotate a variable which type is the class of the base script. Alternatively, you can set the base script class as a member of the `@BaseScript` annotation itself:

```groovy
@BaseScript(MyBaseClass)
import groovy.transform.BaseScript

setName 'Judith'
greet()
```

##### Alternate abstract method

We have seen that the base script class is a single abstract method type that needs to implement the `run` method. The `run` method is executed by the script engine automatically. In some circumstances it may be interesting to have a base class which implements the `run` method, but provides an alternative abstract method to be used for the script body. For example, the base script `run` method might perform some initialization before the `run` method is executed. This is possible by doing this:

```groovy
abstract class MyBaseClass extends Script {
    int count
    abstract void scriptBody()                              
    def run() {
        count++                                             
        scriptBody()                                        
        count                                               
    }
}
```

|      | the base script class should define one (and only one) abstract method |
| ---- | ------------------------------------------------------------ |
|      | the `run` method can be overridden and perform a task before executing the script body |
|      | `run` calls the abstract `scriptBody` method which will delegate to the user script |
|      | then it can return something else than the value from the script |

If you execute this code:

```groovy
def result = shell.evaluate """
    println 'Ok'
"""
assert result == 1
```

Then you will see that the script is executed, but the result of the evaluation is `1` as returned by the `run` method of the base class. It is even clearer if you use `parse` instead of `evaluate`, because it would allow you to execute the `run` method several times on the same script instance:

```groovy
def script = shell.parse("println 'Ok'")
assert script.run() == 1
assert script.run() == 2
```

#### 3.15.4. Adding properties to numbers

In Groovy number types are considered equal to any other types. As such, it is possible to enhance numbers by adding properties or methods to them. This can be very handy when dealing with measurable quantities for example. Details about how existing classes can be enhanced in Groovy are found in the [extension modules](https://docs.groovy-lang.org/latest/html/documentation/core-metaprogramming.html#_extension_modules) section or the [categories](https://docs.groovy-lang.org/latest/html/documentation/core-metaprogramming.html#categories) section.

An illustration of this can be found in Groovy using the `TimeCategory`:

```groovy
use(TimeCategory)  {
    println 1.minute.from.now       
    println 10.hours.ago

    def someDate = new Date()       
    println someDate - 3.months
}
```

|      | using the `TimeCategory`, a property `minute` is added to the `Integer` class |
| ---- | ------------------------------------------------------------ |
|      | similarily, the `months` method returns a `groovy.time.DatumDependentDuration` which can be used in calculus |

Categories are lexically bound, making them a great fit for internal DSLs.

#### 3.15.5. @DelegatesTo

##### Explaining delegation strategy at compile time

`@groovy.lang.DelegatesTo` is a documentation and compile-time annotation aimed at:

- documenting APIs that use closures as arguments
- providing type information for the static type checker and compiler

The Groovy language is a platform of choice for building DSLs. Using closures, it’s quite easy to create custom control structures, as well as it is simple to create builders. Imagine that you have the following code:

```groovy
email {
    from 'dsl-guru@mycompany.com'
    to 'john.doe@waitaminute.com'
    subject 'The pope has resigned!'
    body {
        p 'Really, the pope has resigned!'
    }
}
```

One way of implementing this is using the builder strategy, which implies a method, named `email` which accepts a closure as an argument. The method may delegate subsequent calls to an object that implements the `from`, `to`, `subject` and `body` methods. Again, `body` is a method which accepts a closure as an argument and that uses the builder strategy.

Implementing such a builder is usually done the following way:

```groovy
def email(Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}
```

the `EmailSpec` class implements the `from`, `to`, … methods. By calling `rehydrate`, we’re creating a copy of the closure for which we set the `delegate`, `owner` and `thisObject` values. Setting the owner and the `this` object is not very important here since we will use the `DELEGATE_ONLY` strategy which says that the method calls will be resolved only against the delegate of the closure.

```groovy
class EmailSpec {
    void from(String from) { println "From: $from"}
    void to(String... to) { println "To: $to"}
    void subject(String subject) { println "Subject: $subject"}
    void body(Closure body) {
        def bodySpec = new BodySpec()
        def code = body.rehydrate(bodySpec, this, this)
        code.resolveStrategy = Closure.DELEGATE_ONLY
        code()
    }
}
```

The `EmailSpec` class has itself a `body` method accepting a closure that is cloned and executed. This is what we call the builder pattern in Groovy.

One of the problems with the code that we’ve shown is that the user of the `email` method doesn’t have any information about the methods that he’s allowed to call inside the closure. The only possible information is from the method documentation. There are two issues with this: first of all, documentation is not always written, and if it is, it’s not always available (javadoc not downloaded, for example). Second, it doesn’t help IDEs. What would be really interesting, here, is for IDEs to help the developer by suggesting, once they are in the closure body, methods that exist on the `email` class.

Moreover, if the user calls a method in the closure which is not defined by the `EmailSpec` class, the IDE should at least issue a warning (because it’s very likely that it will break at runtime).

One more problem with the code above is that it is not compatible with static type checking. Type checking would let the user know if a method call is authorized at compile time instead of runtime, but if you try to perform type checking on this code:

```groovy
email {
    from 'dsl-guru@mycompany.com'
    to 'john.doe@waitaminute.com'
    subject 'The pope has resigned!'
    body {
        p 'Really, the pope has resigned!'
    }
}
```

Then the type checker will know that there’s an `email` method accepting a `Closure`, but it will complain for every method call **inside** the closure, because `from`, for example, is not a method which is defined in the class. Indeed, it’s defined in the `EmailSpec` class and it has absolutely no hint to help it knowing that the closure delegate will, at runtime, be of type `EmailSpec`:

```groovy
@groovy.transform.TypeChecked
void sendEmail() {
    email {
        from 'dsl-guru@mycompany.com'
        to 'john.doe@waitaminute.com'
        subject 'The pope has resigned!'
        body {
            p 'Really, the pope has resigned!'
        }
    }
}
```

will fail compilation with errors like this one:

```
[Static type checking] - Cannot find matching method MyScript#from(java.lang.String). Please check if the declared type is correct and if the method exists.
 @ line 31, column 21.
                       from 'dsl-guru@mycompany.com'
```

##### @DelegatesTo

For those reasons, Groovy 2.1 introduced a new annotation named `@DelegatesTo`. The goal of this annotation is to solve both the documentation issue, that will let your IDE know about the expected methods in the closure body, and it will also solve the type checking issue, by giving hints to the compiler about what are the potential receivers of method calls in the closure body.

The idea is to annotate the `Closure` parameter of the `email` method:

```groovy
def email(@DelegatesTo(EmailSpec) Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}
```

What we’ve done here is telling the compiler (or the IDE) that when the method will be called with a closure, the delegate of this closure will be set to an object of type `email`. But there is still a problem: the default delegation strategy is not the one which is used in our method. So we will give more information and tell the compiler (or the IDE) that the delegation strategy is also changed:

```groovy
def email(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=EmailSpec) Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}
```

Now, both the IDE and the type checker (if you are using `@TypeChecked`) will be aware of the delegate and the delegation strategy. This is very nice because it will both allow the IDE to provide smart completion, but it will also remove errors at compile time that exist only because the behaviour of the program is normally only known at runtime!

The following code will now pass compilation:

```groovy
@TypeChecked
void doEmail() {
    email {
        from 'dsl-guru@mycompany.com'
        to 'john.doe@waitaminute.com'
        subject 'The pope has resigned!'
        body {
            p 'Really, the pope has resigned!'
        }
    }
}
```

##### DelegatesTo modes

`@DelegatesTo` supports multiple modes that we will describe with examples in this section.

###### Simple delegation

In this mode, the only mandatory parameter is the *value* which says to which class we delegate calls. Nothing more. We’re telling the compiler that the type of the delegate will **always** be of the type documented by `@DelegatesTo` (note that it can be a subclass, but if it is, the methods defined by the subclass will not be visible to the type checker).

```groovy
void body(@DelegatesTo(BodySpec) Closure cl) {
    // ...
}
```

###### Delegation strategy

In this mode, you must specify both the delegate class **and** a delegation strategy. This must be used if the closure will not be called with the default delegation strategy, which is `Closure.OWNER_FIRST`.

```groovy
void body(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=BodySpec) Closure cl) {
    // ...
}
```

###### Delegate to parameter

In this variant, we will tell the compiler that we are delegating to another parameter of the method. Take the following code:

```groovy
def exec(Object target, Closure code) {
   def clone = code.rehydrate(target, this, this)
   clone()
}
```

Here, the delegate which will be used is **not** created inside the `exec` method. In fact, we take an argument of the method and delegate to it. Usage may look like this:

```groovy
def email = new Email()
exec(email) {
   from '...'
   to '...'
   send()
}
```

Each of the method calls are delegated to the `email` parameter. This is a widely used pattern which is also supported by `@DelegatesTo` using a companion annotation:

```groovy
def exec(@DelegatesTo.Target Object target, @DelegatesTo Closure code) {
   def clone = code.rehydrate(target, this, this)
   clone()
}
```

A closure is annotated with `@DelegatesTo`, but this time, without specifying any class. Instead, we’re annotating another parameter with `@DelegatesTo.Target`. The type of the delegate is then determined at compile time. One could think that we are using the parameter type, which in this case is `Object` but this is not true. Take this code:

```groovy
class Greeter {
   void sayHello() { println 'Hello' }
}
def greeter = new Greeter()
exec(greeter) {
   sayHello()
}
```

Remember that this works out of the box **without** having to annotate with `@DelegatesTo`. However, to make the IDE aware of the delegate type, or the **type checker** aware of it, we need to add `@DelegatesTo`. And in this case, it will know that the `Greeter` variable is of type `Greeter`, so it will not report errors on the *sayHello* method **even if the exec method doesn’t explicitly define the target as of type Greeter**. This is a very powerful feature, because it prevents you from writing multiple versions of the same `exec` method for different receiver types!

In this mode, the `@DelegatesTo` annotation also supports the `strategy` parameter that we’ve described upper.

###### Multiple closures

In the previous example, the `exec` method accepted only one closure, but you may have methods that take multiple closures:

```groovy
void fooBarBaz(Closure foo, Closure bar, Closure baz) {
    ...
}
```

Then nothing prevents you from annotating each closure with `@DelegatesTo`:

```groovy
class Foo { void foo(String msg) { println "Foo ${msg}!" } }
class Bar { void bar(int x) { println "Bar ${x}!" } }
class Baz { void baz(Date d) { println "Baz ${d}!" } }

void fooBarBaz(@DelegatesTo(Foo) Closure foo, @DelegatesTo(Bar) Closure bar, @DelegatesTo(Baz) Closure baz) {
   ...
}
```

But more importantly, if you have multiple closures **and** multiple arguments, you can use several targets:

```groovy
void fooBarBaz(
    @DelegatesTo.Target('foo') foo,
    @DelegatesTo.Target('bar') bar,
    @DelegatesTo.Target('baz') baz,

    @DelegatesTo(target='foo') Closure cl1,
    @DelegatesTo(target='bar') Closure cl2,
    @DelegatesTo(target='baz') Closure cl3) {
    cl1.rehydrate(foo, this, this).call()
    cl2.rehydrate(bar, this, this).call()
    cl3.rehydrate(baz, this, this).call()
}

def a = new Foo()
def b = new Bar()
def c = new Baz()
fooBarBaz(
    a, b, c,
    { foo('Hello') },
    { bar(123) },
    { baz(new Date()) }
)
```

|      | At this point, you may wonder why we don’t use the parameter names as references. The reason is that the information (the parameter name) is not always available (it’s a debug-only information), so it’s a limitation of the JVM. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Delegating to a generic type

In some situations, it is interesting to instruct the IDE or the compiler that the delegate type will not be a parameter but a generic type. Imagine a configurator that runs on a list of elements:

```groovy
public <T> void configure(List<T> elements, Closure configuration) {
   elements.each { e->
      def clone = configuration.rehydrate(e, this, this)
      clone.resolveStrategy = Closure.DELEGATE_FIRST
      clone.call()
   }
}
```

Then this method can be called with any list like this:

```groovy
@groovy.transform.ToString
class Realm {
   String name
}
List<Realm> list = []
3.times { list << new Realm() }
configure(list) {
   name = 'My Realm'
}
assert list.every { it.name == 'My Realm' }
```

To let the type checker and the IDE know that the `configure` method calls the closure on each element of the list, you need to use `@DelegatesTo` differently:

```groovy
public <T> void configure(
    @DelegatesTo.Target List<T> elements,
    @DelegatesTo(strategy=Closure.DELEGATE_FIRST, genericTypeIndex=0) Closure configuration) {
   def clone = configuration.rehydrate(e, this, this)
   clone.resolveStrategy = Closure.DELEGATE_FIRST
   clone.call()
}
```

`@DelegatesTo` takes an optional `genericTypeIndex` argument that tells what is the index of the generic type that will be used as the delegate type. This **must** be used in conjunction with `@DelegatesTo.Target` and the index starts at 0. In the example above, that means that the delegate type is resolved against `List`, and since the generic type at index 0 is `T` and inferred as a `Realm`, the type checker infers that the delegate type will be of type `Realm`.

|      | We’re using a `genericTypeIndex` instead of a placeholder (`T`) because of JVM limitations. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

###### Delegating to an arbitrary type

It is possible that none of the options above can represent the type you want to delegate to. For example, let’s define a mapper class which is parametrized with an object and defines a map method which returns an object of another type:

```groovy
class Mapper<T,U> {                             
    final T value                               
    Mapper(T value) { this.value = value }
    U map(Closure<U> producer) {                
        producer.delegate = value
        producer()
    }
}
```

|      | The mapper class takes two generic type arguments: the source type and the target type |
| ---- | ------------------------------------------------------------ |
|      | The source object is stored in a final field                 |
|      | The `map` method asks to convert the source object to a target object |

As you can see, the method signature from `map` does not give any information about what object will be manipulated by the closure. Reading the method body, we know that it will be the `value` which is of type `T`, but `T` is not found in the method signature, so we are facing a case where none of the available options for `@DelegatesTo` is suitable. For example, if we try to statically compile this code:

```groovy
def mapper = new Mapper<String,Integer>('Hello')
assert mapper.map { length() } == 5
```

Then the compiler will fail with:

```
Static type checking] - Cannot find matching method TestScript0#length()
```

In that case, you can use the `type` member of the `@DelegatesTo` annotation to reference `T` as a type token:

```groovy
class Mapper<T,U> {
    final T value
    Mapper(T value) { this.value = value }
    U map(@DelegatesTo(type="T") Closure<U> producer) {  
        producer.delegate = value
        producer()
    }
}
```

|      | The `@DelegatesTo` annotation references a generic type which is not found in the method signature |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Note that you are not limited to generic type tokens. The `type` member can be used to represent complex types, such as `List` or `Map>`. The reason why you should use that in last resort is that the type is only checked when the type checker finds usage of `@DelegatesTo`, not when the annotated method itself is compiled. This means that type safety is only ensured at the call site. Additionally, compilation will be slower (though probably unnoticeable for most cases).

#### 3.15.6. Compilation customizers

##### Introduction

Whether you are using `groovyc` to compile classes or a `GroovyShell`, for example, to execute scripts, under the hood, a *compiler configuration* is used. This configuration holds information like the source encoding or the classpath but it can also be used to perform more operations like adding imports by default, applying AST transformations transparently or disabling global AST transformations.

The goal of compilation customizers is to make those common tasks easy to implement. For that, the `CompilerConfiguration` class is the entry point. The general schema will always be based on the following code:

```groovy
import org.codehaus.groovy.control.CompilerConfiguration
// create a configuration
def config = new CompilerConfiguration()
// tweak the configuration
config.addCompilationCustomizers(...)
// run your script
def shell = new GroovyShell(config)
shell.evaluate(script)
```

Compilation customizers must extend the *org.codehaus.groovy.control.customizers.CompilationCustomizer* class. A customizer works:

- on a specific compilation phase
- on *every* class node being compiled

You can implement your own compilation customizer but Groovy includes some of the most common operations.

##### Import customizer

Using this compilation customizer, your code will have imports added transparently. This is in particular useful for scripts implementing a DSL where you want to avoid users from having to write imports. The import customizer will let you add all the variants of imports the Groovy language allows, that is:

- class imports, optionally aliased
- star imports
- static imports, optionally aliased
- static star imports

```groovy
import org.codehaus.groovy.control.customizers.ImportCustomizer

def icz = new ImportCustomizer()
// "normal" import
icz.addImports('java.util.concurrent.atomic.AtomicInteger', 'java.util.concurrent.ConcurrentHashMap')
// "aliases" import
icz.addImport('CHM', 'java.util.concurrent.ConcurrentHashMap')
// "static" import
icz.addStaticImport('java.lang.Math', 'PI') // import static java.lang.Math.PI
// "aliased static" import
icz.addStaticImport('pi', 'java.lang.Math', 'PI') // import static java.lang.Math.PI as pi
// "star" import
icz.addStarImports 'java.util.concurrent' // import java.util.concurrent.*
// "static star" import
icz.addStaticStars 'java.lang.Math' // import static java.lang.Math.*
```

A detailed description of all shortcuts can be found in [org.codehaus.groovy.control.customizers.ImportCustomizer](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/customizers/ImportCustomizer.html)

##### AST transformation customizer

The AST transformation customizer is meant to apply AST transformations transparently. Unlike global AST transformations that apply on every class being compiled as long as the transform is found on classpath (which has drawbacks like increasing the compilation time or side effects due to transformations applied where they should not), the customizer will allow you to selectively apply a transform only for specific scripts or classes.

As an example, let’s say you want to be able to use `@Log` in a script. The problem is that `@Log` is normally applied on a class node and a script, by definition, doesn’t require one. But implementation wise, scripts are classes, it’s just that you cannot annotate this implicit class node with `@Log`. Using the AST customizer, you have a workaround to do it:

```groovy
import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import groovy.util.logging.Log

def acz = new ASTTransformationCustomizer(Log)
config.addCompilationCustomizers(acz)
```

That’s all! Internally, the `@Log` AST transformation is applied to every class node in the compilation unit. This means that it will be applied to the script, but also to classes defined within the script.

If the AST transformation that you are using accepts parameters, you can use parameters in the constructor too:

```groovy
def acz = new ASTTransformationCustomizer(Log, value: 'LOGGER')
// use name 'LOGGER' instead of the default 'log'
config.addCompilationCustomizers(acz)
```

As the AST transformation customizers works with objects instead of AST nodes, not all values can be converted to AST transformation parameters. For example, primitive types are converted to `ConstantExpression` (that is `LOGGER` is converted to `new ConstantExpression('LOGGER')`, but if your AST transformation takes a closure as an argument, then you have to give it a `ClosureExpression`, like in the following example:

```groovy
def configuration = new CompilerConfiguration()
def expression = new AstBuilder().buildFromCode(CompilePhase.CONVERSION) { -> true }.expression[0]
def customizer = new ASTTransformationCustomizer(ConditionalInterrupt, value: expression, thrown: SecurityException)
configuration.addCompilationCustomizers(customizer)
def shell = new GroovyShell(configuration)
shouldFail(SecurityException) {
    shell.evaluate("""
        // equivalent to adding @ConditionalInterrupt(value={true}, thrown: SecurityException)
        class MyClass {
            void doIt() { }
        }
        new MyClass().doIt()
    """)
}
```

For a complete list of options, please refer to [org.codehaus.groovy.control.customizers.ASTTransformationCustomizer](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/customizers/ASTTransformationCustomizer.html)

##### Secure AST customizer

This customizer will allow the developer of a DSL to restrict the **grammar** of the language, to prevent users from using some constructs, for example. It is only ``secure'' in that sense only and it is very important to understand that it does **not** replace a security manager. The only reason for it to exist is to limit the expressiveness of the language. This customizer only works at the AST (abstract syntax tree) level, not at runtime! It can be strange at first glance, but it makes much more sense if you think of Groovy as a platform to build DSLs. You may not want a user to have a complete language at hand. In the example below, we will demonstrate it using an example of language that only allows arithmetic operations, but this customizer allows you to:

- allow/disallow creation of closures
- allow/disallow imports
- allow/disallow package definition
- allow/disallow definition of methods
- restrict the receivers of method calls
- restrict the kind of AST expressions a user can use
- restrict the tokens (grammar-wise) a user can use
- restrict the types of the constants that can be used in code

For all those features, the secure AST customizer works using either a whitelist (list of elements that are allowed) **or** a blacklist (list of elements that are disallowed). For each type of feature (imports, tokens, …) you have the choice to use either a whitelist or a blacklist, but you can mix whitelists and blacklists for distinct features. In general, you will choose whitelists (disallow all, allow selected).

```groovy
import org.codehaus.groovy.control.customizers.SecureASTCustomizer
import static org.codehaus.groovy.syntax.Types.* 

def scz = new SecureASTCustomizer()
scz.with {
    closuresAllowed = false // user will not be able to write closures
    methodDefinitionAllowed = false // user will not be able to define methods
    importsWhitelist = [] // empty whitelist means imports are disallowed
    staticImportsWhitelist = [] // same for static imports
    staticStarImportsWhitelist = ['java.lang.Math'] // only java.lang.Math is allowed
    // the list of tokens the user can find
    // constants are defined in org.codehaus.groovy.syntax.Types
    tokensWhitelist = [ 
            PLUS,
            MINUS,
            MULTIPLY,
            DIVIDE,
            MOD,
            POWER,
            PLUS_PLUS,
            MINUS_MINUS,
            COMPARE_EQUAL,
            COMPARE_NOT_EQUAL,
            COMPARE_LESS_THAN,
            COMPARE_LESS_THAN_EQUAL,
            COMPARE_GREATER_THAN,
            COMPARE_GREATER_THAN_EQUAL,
    ].asImmutable()
    // limit the types of constants that a user can define to number types only
    constantTypesClassesWhiteList = [ 
            Integer,
            Float,
            Long,
            Double,
            BigDecimal,
            Integer.TYPE,
            Long.TYPE,
            Float.TYPE,
            Double.TYPE
    ].asImmutable()
    // method calls are only allowed if the receiver is of one of those types
    // be careful, it's not a runtime type!
    receiversClassesWhiteList = [ 
            Math,
            Integer,
            Float,
            Double,
            Long,
            BigDecimal
    ].asImmutable()
}
```

|      | use for token types from [org.codehaus.groovy.syntax.Types](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/syntax/Types.html) |
| ---- | ------------------------------------------------------------ |
|      | you can use class literals here                              |

If what the secure AST customizer provides out of the box isn’t enough for your needs, before creating your own compilation customizer, you might be interested in the expression and statement checkers that the AST customizer supports. Basically, it allows you to add custom checks on the AST tree, on expressions (expression checkers) or statements (statement checkers). For this, you must implement `org.codehaus.groovy.control.customizers.SecureASTCustomizer.StatementChecker` or `org.codehaus.groovy.control.customizers.SecureASTCustomizer.ExpressionChecker`.

Those interfaces define a single method called `isAuthorized`, returning a boolean, and taking a `Statement` (or `Expression`) as a parameter. It allows you to perform complex logic over expressions or statements to tell if a user is allowed to do it or not.

For example, there’s no predefined configuration flag in the customizer which will let you prevent people from using an attribute expression. Using a custom checker, it is trivial:

```groovy
def scz = new SecureASTCustomizer()
def checker = { expr ->
    !(expr instanceof AttributeExpression)
} as SecureASTCustomizer.ExpressionChecker
scz.addExpressionCheckers(checker)
```

Then we can make sure that this works by evaluating a simple script:

```groovy
new GroovyShell(config).evaluate '''
    class A {
        int val
    }

    def a = new A(val: 123)
    a.@val 
'''
```

|      | will fail compilation |
| ---- | --------------------- |
|      |                       |

Statements can be checked using [org.codehaus.groovy.control.customizers.SecureASTCustomizer.StatementChecker](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/customizers/SecureASTCustomizer/StatementChecker.html) Expressions can be checked using [org.codehaus.groovy.control.customizers.SecureASTCustomizer.ExpressionChecker](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/control/customizers/SecureASTCustomizer/ExpressionChecker.html)

##### Source aware customizer

This customizer may be used as a filter on other customizers. The filter, in that case, is the `org.codehaus.groovy.control.SourceUnit`. For this, the source aware customizer takes another customizer as a delegate, and it will apply customization of that delegate only and only if predicates on the source unit match.

`SourceUnit` gives you access to multiple things but in particular the file being compiled (if compiling from a file, of course). It gives you the potential to perform operation based on the file name, for example. Here is how you would create a source aware customizer:

```groovy
import org.codehaus.groovy.control.customizers.SourceAwareCustomizer
import org.codehaus.groovy.control.customizers.ImportCustomizer

def delegate = new ImportCustomizer()
def sac = new SourceAwareCustomizer(delegate)
```

Then you can use predicates on the source aware customizer:

```groovy
// the customizer will only be applied to classes contained in a file name ending with 'Bean'
sac.baseNameValidator = { baseName ->
    baseName.endsWith 'Bean'
}

// the customizer will only be applied to files which extension is '.spec'
sac.extensionValidator = { ext -> ext == 'spec' }

// source unit validation
// allow compilation only if the file contains at most 1 class
sac.sourceUnitValidator = { SourceUnit sourceUnit -> sourceUnit.AST.classes.size() == 1 }

// class validation
// the customizer will only be applied to classes ending with 'Bean'
sac.classValidator = { ClassNode cn -> cn.endsWith('Bean') }
```

##### Customizer builder

If you are using compilation customizers in Groovy code (like the examples above) then you can use an alternative syntax to customize compilation. A builder (`org.codehaus.groovy.control.customizers.builder.CompilerCustomizationBuilder`) simplifies the creation of customizers using a hierarchical DSL.

```groovy
import org.codehaus.groovy.control.CompilerConfiguration
import static org.codehaus.groovy.control.customizers.builder.CompilerCustomizationBuilder.withConfig 

def conf = new CompilerConfiguration()
withConfig(conf) {
    // ... 
}
```

|      | static import of the builder method |
| ---- | ----------------------------------- |
|      | configuration goes here             |

The code sample above shows how to use the builder. A static method, *withConfig*, takes a closure corresponding to the builder code, and automatically registers compilation customizers to the configuration. Every compilation customizer available in the distribution can be configured this way:

###### Import customizer

```groovy
withConfig(configuration) {
   imports { // imports customizer
      normal 'my.package.MyClass' // a normal import
      alias 'AI', 'java.util.concurrent.atomic.AtomicInteger' // an aliased import
      star 'java.util.concurrent' // star imports
      staticMember 'java.lang.Math', 'PI' // static import
      staticMember 'pi', 'java.lang.Math', 'PI' // aliased static import
   }
}
```

###### AST transformation customizer

```groovy
withConfig(conf) {
   ast(Log) 
}

withConfig(conf) {
   ast(Log, value: 'LOGGER') 
}
```

|      | apply @Log transparently                        |
| ---- | ----------------------------------------------- |
|      | apply @Log with a different name for the logger |

###### Secure AST customizer

```groovy
withConfig(conf) {
   secureAst {
       closuresAllowed = false
       methodDefinitionAllowed = false
   }
}
```

###### Source aware customizer

```groovy
withConfig(configuration){
    source(extension: 'sgroovy') {
        ast(CompileStatic) 
    }
}

withConfig(configuration){
    source(extensions: ['sgroovy','sg']) {
        ast(CompileStatic) 
    }
}

withConfig(configuration) {
    source(extensionValidator: { it.name in ['sgroovy','sg']}) {
        ast(CompileStatic) 
    }
}

withConfig(configuration) {
    source(basename: 'foo') {
        ast(CompileStatic) 
    }
}

withConfig(configuration) {
    source(basenames: ['foo', 'bar']) {
        ast(CompileStatic) 
    }
}

withConfig(configuration) {
    source(basenameValidator: { it in ['foo', 'bar'] }) {
        ast(CompileStatic) 
    }
}

withConfig(configuration) {
    source(unitValidator: { unit -> !unit.AST.classes.any { it.name == 'Baz' } }) {
        ast(CompileStatic) 
    }
}
```

|      | apply CompileStatic AST annotation on .sgroovy files         |
| ---- | ------------------------------------------------------------ |
|      | apply CompileStatic AST annotation on .sgroovy or .sg files  |
|      | apply CompileStatic AST annotation on files whose name is 'foo' |
|      | apply CompileStatic AST annotation on files whose name is 'foo' or 'bar' |
|      | apply CompileStatic AST annotation on files that do not contain a class named 'Baz' |

###### Inlining a customizer

Inlined customizer allows you to write a compilation customizer directly, without having to create a class for it.

```groovy
withConfig(configuration) {
    inline(phase:'CONVERSION') { source, context, classNode ->  
        println "visiting $classNode"                           
    }
}
```

|      | define an inlined customizer which will execute at the CONVERSION phase |
| ---- | ------------------------------------------------------------ |
|      | prints the name of the class node being compiled             |

###### Multiple customizers

Of course, the builder allows you to define multiple customizers at once:

```groovy
withConfig(configuration) {
   ast(ToString)
   ast(EqualsAndHashCode)
}
```

##### Config script flag

So far, we have described how you can customize compilation using a `CompilationConfiguration` class, but this is only possible if you embed Groovy and that you create your own instances of `CompilerConfiguration` (then use it to create a `GroovyShell`, `GroovyScriptEngine`, …).

If you want it to be applied on the classes you compile with the normal Groovy compiler (that is to say with  `groovyc`, `ant` or `gradle`, for example), it is possible to use a compilation flag named `configscript` that takes a Groovy configuration script as argument.

This script gives you access to the `CompilerConfiguration` instance **before** the files are compiled (exposed into the configuration script as a variable named `configuration`), so that you can tweak it.

It also transparently integrates the compiler configuration builder above. As an example, let’s see how you would activate static compilation by default on all classes.

###### Static compilation by default

Normally, classes in Groovy are compiled with a dynamic runtime. You can activate static compilation by placing an annotation named `@CompileStatic` on any class. Some people would like to have this mode activated by default, that is to say not having to annotated classes. Using `configscript`, this is possible. First of all, you need to create a file named `config.groovy` into `src/conf` with the following contents:

```groovy
withConfig(configuration) { 
   ast(groovy.transform.CompileStatic)
}
```

|      | *configuration* references a `CompilerConfiguration` instance |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

That is actually all you need. You don’t have to import the builder, it’s automatically exposed in the script. Then, compile your files using the following command line:

```
groovyc -configscript src/conf/config.groovy src/main/groovy/MyClass.groovy
```

We strongly recommend you to separate configuration files from classes, hence why we suggest using the `src/main` and `src/conf` directories above.

##### AST transformations

If:

- runtime metaprogramming doesn’t allow you do do what you want
- you need to improve the performance of the execution of your DSLs
- you want to leverage the same syntax as Groovy but with different semantics
- you want to improve support for type checking in your DSLs

Then AST transformations are the way to go. Unlike the techniques used so far, AST transformations are meant to change or generate code before it is compiled to bytecode. AST transformations are capable of adding new methods at compile time for example, or totally changing the body of a method based on your needs. They are a very powerful tool but also come at the price of not being easy to write. For more information about AST transformations, please take a look at the [compile-time metaprogramming](http://docs.groovy-lang.org/latest/html/documentation/index.html#_compile_time_metaprogramming) section of this manual.

#### 3.15.7. Custom type checking extensions

It may be interesting, in some circumstances, to provide feedback about wrong code to the user as soon as possible, that is to say when the DSL script is compiled, rather than having to wait for the execution of the script. However, this is not often possible with dynamic code. Groovy actually provides a practical answer to this known as [type checking extensions](https://docs.groovy-lang.org/latest/html/documentation/type-checking-extensions.html).

#### 3.15.8. Builders

(TBD)

##### Creating a builder

(TBD)

###### BuilderSupport

(TBD)

###### FactoryBuilderSupport

(TBD)

##### Existing builders

(TBD)

###### MarkupBuilder

See [Creating Xml - MarkupBuilder](https://docs.groovy-lang.org/latest/html/documentation/xml-userguide.html#_markupbuilder).

###### StreamingMarkupBuilder

See [Creating Xml - StreamingMarkupBuilder](https://docs.groovy-lang.org/latest/html/documentation/xml-userguide.html#_streamingmarkupbuilder).

###### SaxBuilder

A builder for generating [Simple API for XML (SAX)](https://en.wikipedia.org/wiki/Simple_API_for_XML) events.

If you have the following SAX handler:

```groovy
class LogHandler extends org.xml.sax.helpers.DefaultHandler {

    String log = ''

    void startElement(String uri, String localName, String qName, org.xml.sax.Attributes attributes) {
        log += "Start Element: $localName, "
    }

    void endElement(String uri, String localName, String qName) {
        log += "End Element: $localName, "
    }
}
```

You can use `SaxBuilder` to generate SAX events for the handler like this:

```groovy
def handler = new LogHandler()
def builder = new groovy.xml.SAXBuilder(handler)

builder.root() {
    helloWorld()
}
```

And then check that everything worked as expected:

```groovy
assert handler.log == 'Start Element: root, Start Element: helloWorld, End Element: helloWorld, End Element: root, '
```

###### StaxBuilder

A Groovy builder that works with [Streaming API for XML (StAX)](http://en.wikipedia.org/wiki/StAX) processors.

Here is a simple example using the StAX implementation of Java to generate XML:

```groovy
def factory = javax.xml.stream.XMLOutputFactory.newInstance()
def writer = new StringWriter()
def builder = new groovy.xml.StaxBuilder(factory.createXMLStreamWriter(writer))

builder.root(attribute:1) {
    elem1('hello')
    elem2('world')
}

assert writer.toString() == '<?xml version="1.0" ?><root attribute="1"><elem1>hello</elem1><elem2>world</elem2></root>'
```

An external library such as [Jettison](https://github.com/jettison-json/jettison) can be used as follows:

```groovy
@Grab('org.codehaus.jettison:jettison:1.3.3')
@GrabExclude('stax:stax-api') // part of Java 6 and later
import org.codehaus.jettison.mapped.*

def writer = new StringWriter()
def mappedWriter = new MappedXMLStreamWriter(new MappedNamespaceConvention(), writer)
def builder = new groovy.xml.StaxBuilder(mappedWriter)

builder.root(attribute:1) {
     elem1('hello')
     elem2('world')
}

assert writer.toString() == '{"root":{"@attribute":"1","elem1":"hello","elem2":"world"}}'
```

###### DOMBuilder

A builder for parsing HTML, XHTML and XML into a [W3C DOM](https://en.wikipedia.org/wiki/Document_Object_Model) tree.

For example this XML `String`:

```groovy
String recordsXML = '''
    <records>
      <car name='HSV Maloo' make='Holden' year='2006'>
        <country>Australia</country>
        <record type='speed'>Production Pickup Truck with speed of 271kph</record>
      </car>
      <car name='P50' make='Peel' year='1962'>
        <country>Isle of Man</country>
        <record type='size'>Smallest Street-Legal Car at 99cm wide and 59 kg in weight</record>
      </car>
      <car name='Royale' make='Bugatti' year='1931'>
        <country>France</country>
        <record type='price'>Most Valuable Car at $15 million</record>
      </car>
    </records>'''
```

Can be parsed into a DOM tree with a `DOMBuilder` like this:

```groovy
def reader = new StringReader(recordsXML)
def doc = groovy.xml.DOMBuilder.parse(reader)
```

And then processed further e.g. by using [DOMCategory](https://docs.groovy-lang.org/latest/html/documentation/#_domcategory):

```groovy
def records = doc.documentElement
use(groovy.xml.dom.DOMCategory) {
    assert records.car.size() == 3
}
```

###### NodeBuilder

`NodeBuilder` is used for creating nested trees of [Node](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/util/Node.html) objects for handling arbitrary data. To create a simple user list you use a `NodeBuilder` like this:

```groovy
def nodeBuilder = new NodeBuilder()
def userlist = nodeBuilder.userlist {
    user(id: '1', firstname: 'John', lastname: 'Smith') {
        address(type: 'home', street: '1 Main St.', city: 'Springfield', state: 'MA', zip: '12345')
        address(type: 'work', street: '2 South St.', city: 'Boston', state: 'MA', zip: '98765')
    }
    user(id: '2', firstname: 'Alice', lastname: 'Doe')
}
```

Now you can process the data further, e.g. by using [GPath expressions](https://docs.groovy-lang.org/latest/html/documentation/#gpath_expressions):

```groovy
assert userlist.user.@firstname.join(', ') == 'John, Alice'
assert userlist.user.find { it.@lastname == 'Smith' }.address.size() == 2
```

###### JsonBuilder

Groovy’s `JsonBuilder` makes it easy to create Json. For example to create this Json string:

```groovy
String carRecords = '''
    {
        "records": {
        "car": {
            "name": "HSV Maloo",
            "make": "Holden",
            "year": 2006,
            "country": "Australia",
            "record": {
              "type": "speed",
              "description": "production pickup truck with speed of 271kph"
            }
          }
      }
    }
'''
```

you can use a `JsonBuilder` like this:

```groovy
JsonBuilder builder = new JsonBuilder()
builder.records {
  car {
        name 'HSV Maloo'
        make 'Holden'
        year 2006
        country 'Australia'
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }
}
String json = JsonOutput.prettyPrint(builder.toString())
```

We use [JsonUnit](https://github.com/lukas-krecan/JsonUnit) to check that the builder produced the expected result:

```groovy
JsonAssert.assertJsonEquals(json, carRecords)
```

If you need to customize the generated output you can pass a `JsonGenerator` instance when creating a `JsonBuilder`:

```groovy
import groovy.json.*

def generator = new JsonGenerator.Options()
        .excludeNulls()
        .excludeFieldsByName('make', 'country', 'record')
        .excludeFieldsByType(Number)
        .addConverter(URL) { url -> "http://groovy-lang.org" }
        .build()

JsonBuilder builder = new JsonBuilder(generator)
builder.records {
  car {
        name 'HSV Maloo'
        make 'Holden'
        year 2006
        country 'Australia'
        homepage new URL('http://example.org')
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }
}

assert builder.toString() == '{"records":{"car":{"name":"HSV Maloo","homepage":"http://groovy-lang.org"}}}'
```

###### StreamingJsonBuilder

Unlike `JsonBuilder` which creates a data structure in memory, which is handy in those situations where you want to alter the structure programmatically before output, `StreamingJsonBuilder` directly streams to a writer without any intermediate memory data structure. If you do not need to modify the structure and want a more memory-efficient approach, use `StreamingJsonBuilder`.

The usage of `StreamingJsonBuilder` is similar to `JsonBuilder`. In order to create this Json string:

```groovy
String carRecords = '''
    {
        "records": {
        "car": {
            "name": "HSV Maloo",
            "make": "Holden",
            "year": 2006,
            "country": "Australia",
            "record": {
              "type": "speed",
              "description": "production pickup truck with speed of 271kph"
            }
          }
      }
    }
'''
```

you use a `StreamingJsonBuilder` like this:

```groovy
StringWriter writer = new StringWriter()
StreamingJsonBuilder builder = new StreamingJsonBuilder(writer)
builder.records {
  car {
        name 'HSV Maloo'
        make 'Holden'
        year 2006
        country 'Australia'
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }
}
String json = JsonOutput.prettyPrint(writer.toString())
```

We use [JsonUnit](https://github.com/lukas-krecan/JsonUnit) to check the expected result:

```groovy
JsonAssert.assertJsonEquals(json, carRecords)
```

If you need to customize the generated output you can pass a `JsonGenerator` instance when creating a `StreamingJsonBuilder`:

```groovy
def generator = new JsonGenerator.Options()
        .excludeNulls()
        .excludeFieldsByName('make', 'country', 'record')
        .excludeFieldsByType(Number)
        .addConverter(URL) { url -> "http://groovy-lang.org" }
        .build()

StringWriter writer = new StringWriter()
StreamingJsonBuilder builder = new StreamingJsonBuilder(writer, generator)

builder.records {
  car {
        name 'HSV Maloo'
        make 'Holden'
        year 2006
        country 'Australia'
        homepage new URL('http://example.org')
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }
}

assert writer.toString() == '{"records":{"car":{"name":"HSV Maloo","homepage":"http://groovy-lang.org"}}}'
```

###### SwingBuilder

`SwingBuilder` allows you to create full-fledged Swing GUIs in a declarative and concise fashion. It accomplishes this by employing a common idiom in Groovy, builders. Builders handle the busywork of creating complex objects for you, such as instantiating children, calling Swing methods, and attaching these children to their parents. As a consequence, your code is much more readable and maintainable, while still allowing you access to the full range of Swing components.

Here’s a simple example of using `SwingBuilder`:

```groovy
import groovy.swing.SwingBuilder
import java.awt.BorderLayout as BL

count = 0
new SwingBuilder().edt {
  frame(title: 'Frame', size: [300, 300], show: true) {
    borderLayout()
    textlabel = label(text: 'Click the button!', constraints: BL.NORTH)
    button(text:'Click Me',
         actionPerformed: {count++; textlabel.text = "Clicked ${count} time(s)."; println "clicked"}, constraints:BL.SOUTH)
  }
}
```

Here is what it will look like:

![SwingBuilder001](https://docs.groovy-lang.org/latest/html/documentation/assets/img/SwingBuilder001.gif)

This hierarchy of components would normally be created through a series of repetitive instantiations, setters, and finally attaching this child to its respective parent. Using `SwingBuilder`, however, allows you to define this hierarchy in its native form, which makes the interface design understandable simply by reading the code.

The flexibility shown here is made possible by leveraging the many programming features built-in to Groovy, such as closures, implicit constructor calling, import aliasing, and string interpolation. Of course, these do not have to be fully understood in order to use `SwingBuilder`; as you can see from the code above, their uses are intuitive.

Here is a slightly more involved example, with an example of `SwingBuilder` code re-use via a closure.

```groovy
import groovy.swing.SwingBuilder
import javax.swing.*
import java.awt.*

def swing = new SwingBuilder()

def sharedPanel = {
     swing.panel() {
        label("Shared Panel")
    }
}

count = 0
swing.edt {
    frame(title: 'Frame', defaultCloseOperation: JFrame.EXIT_ON_CLOSE, pack: true, show: true) {
        vbox {
            textlabel = label('Click the button!')
            button(
                text: 'Click Me',
                actionPerformed: {
                    count++
                    textlabel.text = "Clicked ${count} time(s)."
                    println "Clicked!"
                }
            )
            widget(sharedPanel())
            widget(sharedPanel())
        }
    }
}
```

Here’s another variation that relies on observable beans and binding:

```groovy
import groovy.swing.SwingBuilder
import groovy.beans.Bindable

class MyModel {
   @Bindable int count = 0
}

def model = new MyModel()
new SwingBuilder().edt {
  frame(title: 'Java Frame', size: [100, 100], locationRelativeTo: null, show: true) {
    gridLayout(cols: 1, rows: 2)
    label(text: bind(source: model, sourceProperty: 'count', converter: { v ->  v? "Clicked $v times": ''}))
    button('Click me!', actionPerformed: { model.count++ })
  }
}
```

[@Bindable](https://docs.groovy-lang.org/latest/html/documentation/#xform-Bindable) is one of the core AST Transformations. It generates all the required boilerplate code to turn a simple bean into an observable one. The `bind()` node creates appropriate `PropertyChangeListeners` that will update the interested parties whenever a `PropertyChangeEvent` is fired.

###### AntBuilder

|      | Here we describe `AntBuilder` which lets you write Ant build scripts in Groovy rather than XML. You may also be interested in using Groovy from Ant using the [Groovy Ant task](https://docs.groovy-lang.org/latest/html/documentation/groovy-ant-task.html#title-heading). |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Despite being primarily a build tool, [Apache Ant](http://ant.apache.org/) is a very practical tool for manipulating files including zip files, copy, resource processing, and more. But if ever you’ve been working with a `build.xml` file or some *Jelly script* and found yourself a little restricted by all those pointy brackets, or found it a bit weird using XML as a scripting language and wanted something a little cleaner and more straight forward, then maybe Ant scripting with Groovy might be what you’re after.

Groovy has a helper class called `AntBuilder` which makes the scripting of Ant tasks really easy; allowing a real scripting language to be used for programming constructs (variables, methods, loops, logical branching, classes etc). It still looks like a neat concise version of Ant’s XML without all those pointy brackets; though you can mix and match this markup inside your script. Ant itself is a collection of jar files. By adding them to your classpath, you can easily use them within Groovy as is. We believe using `AntBuilder` leads to more concise and readily understood syntax.

`AntBuilder` exposes Ant tasks directly using the convenient builder notation that we are used to in Groovy. Here is the most basic example, which is printing a message on the standard output:

```groovy
def ant = new groovy.ant.AntBuilder()          
ant.echo('hello from Ant!')         
```

|      | creates an instance of `AntBuilder`                    |
| ---- | ------------------------------------------------------ |
|      | executes the `echo` task with the message in parameter |

Imagine that you need to create a ZIP file. It can be as simple as:

```groovy
def ant = new AntBuilder()
ant.zip(destfile: 'sources.zip', basedir: 'src')
```

In the next example, we demonstrate the use of `AntBuilder` to copy a list of files using a classical Ant pattern directly in Groovy:

```groovy
// let's just call one task
ant.echo("hello")

// here is an example of a block of Ant inside GroovyMarkup
ant.sequential {
    echo("inside sequential")
    def myDir = "target/AntTest/"
    mkdir(dir: myDir)
    copy(todir: myDir) {
        fileset(dir: "src/test") {
            include(name: "**/*.groovy")
        }
    }
    echo("done")
}

// now let's do some normal Groovy again
def file = new File(ant.project.baseDir,"target/AntTest/some/pkg/MyTest.groovy")
assert file.exists()
```

Another example would be iterating over a list of files matching a specific pattern:

```groovy
// let's create a scanner of filesets
def scanner = ant.fileScanner {
    fileset(dir:"src/test") {
        include(name:"**/My*.groovy")
    }
}

// now let's iterate over
def found = false
for (f in scanner) {
    println("Found file $f")
    found = true
    assert f instanceof File
    assert f.name.endsWith(".groovy")
}
assert found
```

Or executing a JUnit test:

```groovy
ant.junit {
    classpath { pathelement(path: '.') }
    test(name:'some.pkg.MyTest')
}
```

We can even go further by compiling and executing a Java file directly from Groovy:

```groovy
ant.echo(file:'Temp.java', '''
    class Temp {
        public static void main(String[] args) {
            System.out.println("Hello");
        }
    }
''')
ant.javac(srcdir:'.', includes:'Temp.java', fork:'true')
ant.java(classpath:'.', classname:'Temp', fork:'true')
ant.echo('Done')
```

It is worth mentioning that `AntBuilder` is included in [Gradle](http://gradle.org/), so you can use it in Gradle just like you would in Groovy. Additional documentation can be found in the [Gradle manual](http://gradle.org/docs/current/userguide/ant.html).

###### CliBuilder

`CliBuilder` provides a compact way to specify the available options for a commandline application and then automatically parse the application’s commandline parameters according to that specification. By convention, a distinction is made between *option* commandline parameters and any remaining parameters which are passed to an application as its arguments. Typically, several types of options might be supported such as `-V` or `--tabsize=4`. `CliBuilder` removes the burden of developing lots of code for commandline processing. Instead, it supports a somewhat declarative approach to declaring your options and then provides a single call to parse the commandline parameters with a simple mechanism to interrogate the options (you can think of this as a simple model for your options).

Even though the details of each commandline you create could be quite different, the same main steps are followed each time. First, a `CliBuilder` instance is created. Then, allowed commandline options are defined. This can be done using a *dynamic api* style or an *annotation* style. The commandline parameters are then parsed according to the options specification resulting in a collection of options which are then interrogated.

Here is a simple example `Greeter.groovy` script illustrating usage:

```groovy
// import of CliBuilder not shown                          
// specify parameters
def cli = new CliBuilder(usage: 'groovy Greeter [option]') 
cli.a(longOpt: 'audience', args: 1, 'greeting audience')   
cli.h(longOpt: 'help', 'display usage')                    

// parse and process parameters
def options = cli.parse(args)                              
if (options.h) cli.usage()                                 
else println "Hello ${options.a ? options.a : 'World'}"    
```

|      | Earlier versions of Groovy had a CliBuilder in the groovy.util package and no import was necessary. While still supported, this approach is now deprecated and you should instead choose the groovy.cli.picocli or groovy.cli.commons version. The groovy.util version points to the commons-cli version for backwards compatibility but will be removed in a future version of Groovy. |
| ---- | ------------------------------------------------------------ |
|      | define a new `CliBuilder` instance specifying an optional usage string |
|      | specify a `-a` option taking a single argument with an optional long variant `--audience` |
|      | specify a `-h` option taking no arguments with an optional long variant `--help` |
|      | parse the commandline parameters supplied to the script      |
|      | if the `h` option is found display a usage message           |
|      | display a standard greeting or, if the `a` option is found, a customized greeting |

Running this script with no commandline parameters, i.e.:

```shell
> groovy Greeter
```

results in the following output:

```
Hello World
```

Running this script with `-h` as the single commandline parameter, i.e.:

```shell
> groovy Greeter -h
```

results in the following output:

```
usage: groovy Greeter [option]
 -a,--audience <arg>   greeting audience
 -h,--help             display usage
```

Running this script with `--audience Groovologist` as the commandline parameters, i.e.:

```shell
> groovy Greeter --audience Groovologist
```

results in the following output:

```
Hello Groovologist
```

When creating the `CliBuilder` instance in the above example, we set the optional `usage` property within the constructor call. This follows Groovy’s normal ability to set additional properties of the instance during construction. There are numerous other properties which can be set such as `header` and `footer`. For the complete set of available properties, see the available properties for the [CliBuilder](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/util/CliBuilder.html) class.

When defining an allowed commandline option, both a short name (e.g. "h" for the `help` option shown previously) and a short description (e.g. "display usage" for the `help` option) must be supplied. In our example above, we also set some additional properties such as `longOpt` and `args`. The following additional properties are supported when specifying an allowed commandline option:

| Name           | Description                                             | Type                  |
| :------------- | :------------------------------------------------------ | :-------------------- |
| argName        | the name of the argument for this option used in output | `String`              |
| longOpt        | the long representation or long name of the option      | `String`              |
| args           | the number of argument values                           | `int` or `String` <1> |
| optionalArg    | whether the argument value is optional                  | `boolean`             |
| required       | whether the option is mandatory                         | `boolean`             |
| type           | the type of this option                                 | `Class`               |
| valueSeparator | the character that is the value separator               | `char` <2>            |
| defaultValue   | a default value                                         | `String`              |
| convert        | converts the incoming String to the required type       | `Closure` <1>         |

|      | More details later                                           |
| ---- | ------------------------------------------------------------ |
|      | Single character Strings are coerced to chars in special cases in Groovy |

If you have an option with only a `longOpt` variant, you can use the special shortname of '_' to specify the option, e.g. : `cli._(longOpt: 'verbose', 'enable verbose logging')`. Some of the remaining named parameters should be fairly self-explanatory while others deserve a bit more explanation. But before further explanations, let’s look at ways of using `CliBuilder` with annotations.

Using Annotations and an interface

Rather than making a series of method calls (albeit in a very declarative mini-DSL form) to specify the allowable options, you can provide an interface specification of the allowable options where annotations are used to indicate and provide details for those options and for how unprocessed parameters are handled. Two annotations are used: [groovy.cli.Option](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/cli/Option.html) and [groovy.cli.Unparsed](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/cli/Unparsed.html).

Here is how such a specification can be defined:

```groovy
interface GreeterI {
    @Option(shortName='h', description='display usage') Boolean help()        
    @Option(shortName='a', description='greeting audience') String audience() 
    @Unparsed(description = "positional parameters") List remaining()         
}
```

|      | Specify a Boolean option set using `-h` or `--help`    |
| ---- | ------------------------------------------------------ |
|      | Specify a String option set using `-a` or `--audience` |
|      | Specify where any remaining parameters will be stored  |

Note how the long name is automatically determined from the interface method name. You can use the `longName` annotation attribute to override that behavior and specify a custom long name if you wish or use a longName of '_' to indicate that no long name is to be provided. You will need to specify a shortName in such a case.

Here is how you could use the interface specification:

```groovy
// import CliBuilder not shown
def cli = new CliBuilder(usage: 'groovy Greeter')  
def argz = '--audience Groovologist'.split()
def options = cli.parseFromSpec(GreeterI, argz)             
assert options.audience() == 'Groovologist'                 

argz = '-h Some Other Args'.split()
options = cli.parseFromSpec(GreeterI, argz)                 
assert options.help()
assert options.remaining() == ['Some', 'Other', 'Args']     
```

|      | Create a `CliBuilder` instance as before with optional properties |
| ---- | ------------------------------------------------------------ |
|      | Parse parameters using the interface specification           |
|      | Interrogate options using the methods from the interface     |
|      | Parse a different set of parameters                          |
|      | Interrogate the remaining parameters                         |

When `parseFromSpec` is called, `CliBuilder` automatically creates an instance implementing the interface and populates it. You simply call the interface methods to interrogate the option values.

Using Annotations and an instance

Alternatively, perhaps you already have a domain class containing the option information. You can simply annotate properties or setters from that class to enable `CliBuilder` to appropriately populate your domain object. Each annotation both describes that option’s properties through the annotation attributes and indicates the setter the `CliBuilder` will use to populate that option in your domain object.

Here is how such a specification can be defined:

```groovy
class GreeterC {
    @Option(shortName='h', description='display usage')
    Boolean help                        

    private String audience
    @Option(shortName='a', description='greeting audience')
    void setAudience(String audience) { 
        this.audience = audience
    }
    String getAudience() { audience }

    @Unparsed(description = "positional parameters")
    List remaining                      
}
```

|      | Indicate that a Boolean property is an option                |
| ---- | ------------------------------------------------------------ |
|      | Indicate that a String property (with explicit setter) is an option |
|      | Specify where any remaining args will be stored              |

And here is how you could use the specification:

```groovy
// import CliBuilder not shown
def cli = new CliBuilder(usage: 'groovy Greeter [option]') 
def options = new GreeterC()                               
def argz = '--audience Groovologist foo'.split()
cli.parseFromInstance(options, argz)                       
assert options.audience == 'Groovologist'                  
assert options.remaining == ['foo']                        
```

|      | Create a `CliBuilder` instance as before with optional parameters |
| ---- | ------------------------------------------------------------ |
|      | Create an instance for `CliBuilder` to populate              |
|      | Parse arguments populating the supplied instance             |
|      | Interrogate the String option property                       |
|      | Interrogate the remaining arguments property                 |

When `parseFromInstance` is called, `CliBuilder` automatically populates your instance. You simply interrogate the instance properties (or whatever accessor methods you have provided in your domain object) to access the option values.

Using Annotations and a script

Finally, there are two additional convenience annotation aliases specifically for scripts. They simply combine the previously mentioned annotations and [groovy.transform.Field](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/transform/Field.html). The groovydoc for those annotations reveals the details: [groovy.cli.OptionField](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/cli/OptionField.html) and [groovy.cli.UnparsedField](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/cli/UnparsedField.html).

Here is an example using those annotations in a self-contained script that would be called with the same arguments as shown for the instance example earlier:

```groovy
// import CliBuilder not shown
import groovy.cli.OptionField
import groovy.cli.UnparsedField

@OptionField String audience
@OptionField Boolean help
@UnparsedField List remaining
new CliBuilder().parseFromInstance(this, args)
assert audience == 'Groovologist'
assert remaining == ['foo']
```

Options with arguments

We saw in our initial example that some options act like flags, e.g. `Greeter -h` but others take an argument, e.g. `Greeter --audience Groovologist`. The simplest cases involve options which act like flags or have a single (potentially optional) argument. Here is an example involving those cases:

```groovy
// import CliBuilder not shown
def cli = new CliBuilder()
cli.a(args: 0, 'a arg') 
cli.b(args: 1, 'b arg') 
cli.c(args: 1, optionalArg: true, 'c arg') 
def options = cli.parse('-a -b foo -c bar baz'.split()) 

assert options.a == true
assert options.b == 'foo'
assert options.c == 'bar'
assert options.arguments() == ['baz']

options = cli.parse('-a -c -b foo bar baz'.split()) 

assert options.a == true
assert options.c == true
assert options.b == 'foo'
assert options.arguments() == ['bar', 'baz']
```

|      | An option that is simply a flag - the default; setting args to 0 is allowed but not needed. |
| ---- | ------------------------------------------------------------ |
|      | An option with exactly one argument                          |
|      | An option with an optional argument; it acts like a flag if the option is left out |
|      | An example using this spec where an argument is supplied to the 'c' option |
|      | An example using this spec where no argument is supplied to the 'c' option; it’s just a flag |

Note: when an option with an optional argument is encountered, it will (somewhat) greedily consume the next parameter from the supplied commandline parameters. If however, the next parameter matches a known long or short option (with leading single or double hyphens), that will take precedence, e.g. `-b` in the above example.

Option arguments may also be specified using the annotation style. Here is an interface option specification illustrating such a definition:

```groovy
interface WithArgsI {
    @Option boolean a()
    @Option String b()
    @Option(optionalArg=true) String[] c()
    @Unparsed List remaining()
}
```

And here is how it is used:

```groovy
def cli = new CliBuilder()
def options = cli.parseFromSpec(WithArgsI, '-a -b foo -c bar baz'.split())
assert options.a()
assert options.b() == 'foo'
assert options.c() == ['bar']
assert options.remaining() == ['baz']

options = cli.parseFromSpec(WithArgsI, '-a -c -b foo bar baz'.split())
assert options.a()
assert options.c() == []
assert options.b() == 'foo'
assert options.remaining() == ['bar', 'baz']
```

This example makes use of an array-typed option specification. We cover this in more detail shortly when we discuss multiple arguments.

Specifying a type

Arguments on the commandline are by nature Strings (or arguably can be considered Booleans for flags) but can be converted to richer types automatically by supplying additional typing information. For the annotation-based argument definition style, these types are supplied using the field types for annotation properties or return types of annotated methods (or the setter argument type for setter methods). For the dynamic method style of argument definition a special 'type' property is supported which allows you to specify a Class name.

When an explicit type is defined, the `args` named-parameter is assumed to be 1 (except for Boolean-typed options where it is 0 by default). An explicit `args` parameter can still be provided if needed. Here is an example using types with the dynamic api argument definition style:

```groovy
def argz = '''-a John -b -d 21 -e 1980 -f 3.5 -g 3.14159
    -h cv.txt -i DOWN and some more'''.split()
def cli = new CliBuilder()
cli.a(type: String, 'a-arg')
cli.b(type: boolean, 'b-arg')
cli.c(type: Boolean, 'c-arg')
cli.d(type: int, 'd-arg')
cli.e(type: Long, 'e-arg')
cli.f(type: Float, 'f-arg')
cli.g(type: BigDecimal, 'g-arg')
cli.h(type: File, 'h-arg')
cli.i(type: RoundingMode, 'i-arg')
def options = cli.parse(argz)
assert options.a == 'John'
assert options.b
assert !options.c
assert options.d == 21
assert options.e == 1980L
assert options.f == 3.5f
assert options.g == 3.14159
assert options.h == new File('cv.txt')
assert options.i == RoundingMode.DOWN
assert options.arguments() == ['and', 'some', 'more']
```

Primitives, numeric types, files, enums and arrays thereof, are supported (they are converted using [StringGroovyMethods#asType(String, Class)](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?org/codehaus/groovy/runtime/StringGroovyMethods.html#asType)).

Custom parsing of the argument String

If the supported types aren’t sufficient, you can supply a closure to handle the String to rich type conversion for you. Here is a sample using the dynamic api style:

```groovy
def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
def cli = new CliBuilder()
def lower = { it.toLowerCase() }
cli.a(convert: lower, 'a-arg')
cli.b(convert: { it.toUpperCase() }, 'b-arg')
cli.d(convert: { Date.parse('yyyy-MM-dd', it) }, 'd-arg')
def options = cli.parse(argz)
assert options.a == 'john'
assert options.b == 'MARY'
assert options.d.format('dd-MM-yyyy') == '01-01-2016'
assert options.arguments() == ['and', 'some', 'more']
```

Alternatively, you can use the annotation style by supplying the conversion closure as an annotation parameter. Here is an example specification:

```groovy
interface WithConvertI {
    @Option(convert={ it.toLowerCase() }) String a()
    @Option(convert={ it.toUpperCase() }) String b()
    @Option(convert={ Date.parse("yyyy-MM-dd", it) }) Date d()
    @Unparsed List remaining()
}
```

And an example using that specification:

```groovy
Date newYears = Date.parse("yyyy-MM-dd", "2016-01-01")
def argz = '''-a John -b Mary -d 2016-01-01 and some more'''.split()
def cli = new CliBuilder()
def options = cli.parseFromSpec(WithConvertI, argz)
assert options.a() == 'john'
assert options.b() == 'MARY'
assert options.d() == newYears
assert options.remaining() == ['and', 'some', 'more']
```

Options with multiple arguments

Multiple arguments are also supported using an `args` value greater than 1. There is a special named parameter, `valueSeparator`, which can also be optionally used when processing multiple arguments. It allows some additional flexibility in the syntax supported when supplying such argument lists on the commandline. For example, supplying a value separator of ',' allows a comma-delimited list of values to be passed on the commandline.

The `args` value is normally an integer. It can be optionally supplied as a String. There are two special String symbols: `+` and `*`. The `*` value means 0 or more. The `+` value means 1 or more. The `*` value is the same as using `+` and also setting the `optionalArg` value to true.

Accessing the multiple arguments follows a special convention. Simply add an 's' to the normal property you would use to access the argument option and you will retrieve all the supplied arguments as a list. So, for a short option named 'a', you access the first 'a' argument using `options.a` and the list of all arguments using `options.as`. It’s fine to have a shortname or longname ending in 's' so long as you don’t also have the singular variant without the 's'. So, if `name` is one of your options with multiple arguments and `guess` is another with a single argument, there will be no confusion using `options.names` and `options.guess`.

Here is an excerpt highlighting the use of multiple arguments:

```groovy
// import CliBuilder not shown
def cli = new CliBuilder()
cli.a(args: 2, 'a-arg')
cli.b(args: '2', valueSeparator: ',', 'b-arg') 
cli.c(args: '+', valueSeparator: ',', 'c-arg') 

def options = cli.parse('-a 1 2 3 4'.split()) 
assert options.a == '1' 
assert options.as == ['1', '2'] 
assert options.arguments() == ['3', '4']

options = cli.parse('-a1 -a2 3'.split()) 
assert options.as == ['1', '2']
assert options.arguments() == ['3']

options = cli.parse(['-b1,2']) 
assert options.bs == ['1', '2']

options = cli.parse(['-c', '1'])
assert options.cs == ['1']

options = cli.parse(['-c1'])
assert options.cs == ['1']

options = cli.parse(['-c1,2,3'])
assert options.cs == ['1', '2', '3']
```

|      | Args value supplied as a String and comma value separator specified |
| ---- | ------------------------------------------------------------ |
|      | One or more arguments are allowed                            |
|      | Two commandline parameters will be supplied as the 'b' option’s list of arguments |
|      | Access the 'a' option’s first argument                       |
|      | Access the 'a' option’s list of arguments                    |
|      | An alternative syntax for specifying two arguments for the 'a' option |
|      | The arguments to the 'b' option supplied as a comma-separated value |

As an alternative to accessing multiple arguments using the *plural name* approach, you can use an array-based type for the option. In this case, all options will always be returned via the array which is accessed via the normal singular name. We’ll see an example of this next when discussing types.

Multiple arguments are also supported using the annotation style of option definition by using an array type for the annotated class member (method or property) as this example shows:

```groovy
interface ValSepI {
    @Option(numberOfArguments=2) String[] a()
    @Option(numberOfArgumentsString='2', valueSeparator=',') String[] b()
    @Option(numberOfArgumentsString='+', valueSeparator=',') String[] c()
    @Unparsed remaining()
}
```

And used as follows:

```groovy
def cli = new CliBuilder()

def options = cli.parseFromSpec(ValSepI, '-a 1 2 3 4'.split())
assert options.a() == ['1', '2']
assert options.remaining() == ['3', '4']

options = cli.parseFromSpec(ValSepI, '-a1 -a2 3'.split())
assert options.a() == ['1', '2']
assert options.remaining() == ['3']

options = cli.parseFromSpec(ValSepI, ['-b1,2'] as String[])
assert options.b() == ['1', '2']

options = cli.parseFromSpec(ValSepI, ['-c', '1'] as String[])
assert options.c() == ['1']

options = cli.parseFromSpec(ValSepI, ['-c1'] as String[])
assert options.c() == ['1']

options = cli.parseFromSpec(ValSepI, ['-c1,2,3'] as String[])
assert options.c() == ['1', '2', '3']
```

Types and multiple arguments

Here is an example using types and multiple arguments with the dynamic api argument definition style:

```groovy
def argz = '''-j 3 4 5 -k1.5,2.5,3.5 and some more'''.split()
def cli = new CliBuilder()
cli.j(args: 3, type: int[], 'j-arg')
cli.k(args: '+', valueSeparator: ',', type: BigDecimal[], 'k-arg')
def options = cli.parse(argz)
assert options.js == [3, 4, 5] 
assert options.j == [3, 4, 5]  
assert options.k == [1.5, 2.5, 3.5]
assert options.arguments() == ['and', 'some', 'more']
```

|      | For an array type, the trailing 's' can be used but isn’t needed |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Setting a default value

Groovy makes it easy using the Elvis operator to provide a default value at the point of usage of some variable, e.g. `String x = someVariable ?: 'some default'`. But sometimes you wish to make such a default part of the options specification to minimise the interrogators work in later stages. `CliBuilder` supports the `defaultValue` property to cater for this scenario.

Here is how you could use it using the dynamic api style:

```groovy
def cli = new CliBuilder()
cli.f longOpt: 'from', type: String, args: 1, defaultValue: 'one', 'f option'
cli.t longOpt: 'to', type: int, defaultValue: '35', 't option'

def options = cli.parse('-f two'.split())
assert options.hasOption('f')
assert options.f == 'two'
assert !options.hasOption('t')
assert options.t == 35

options = cli.parse('-t 45'.split())
assert !options.hasOption('from')
assert options.from == 'one'
assert options.hasOption('to')
assert options.to == 45
```

Similarly, you might want such a specification using the annotation style. Here is an example using an interface specification:

```groovy
interface WithDefaultValueI {
    @Option(shortName='f', defaultValue='one') String from()
    @Option(shortName='t', defaultValue='35') int to()
}
```

Which would be used like this:

```groovy
def cli = new CliBuilder()

def options = cli.parseFromSpec(WithDefaultValueI, '-f two'.split())
assert options.from() == 'two'
assert options.to() == 35

options = cli.parseFromSpec(WithDefaultValueI, '-t 45'.split())
assert options.from() == 'one'
assert options.to() == 45
```

You can also use the `defaultValue` annotation attribute when using annotations with an instance, though it’s probably just as easy to provide an initial value for the property (or backing field).

Use with `TypeChecked`

The dynamic api style of using `CliBuilder` is inherently dynamic but you have a few options should you want to make use of Groovy’s static type checking capabilities. Firstly, consider using the annotation style, for example, here is an interface option specification:

```groovy
interface TypeCheckedI{
    @Option String name()
    @Option int age()
    @Unparsed List remaining()
}
```

And it can be used in combination with `@TypeChecked` as shown here:

```groovy
@TypeChecked
void testTypeCheckedInterface() {
    def argz = "--name John --age 21 and some more".split()
    def cli = new CliBuilder()
    def options = cli.parseFromSpec(TypeCheckedI, argz)
    String n = options.name()
    int a = options.age()
    assert n == 'John' && a == 21
    assert options.remaining() == ['and', 'some', 'more']
}
```

Secondly, there is a feature of the dynamic api style which offers some support. The definition statements are inherently dynamic but actually return a value which we have ignored in earlier examples. The returned value is in fact a `TypedOption` and special `getAt` support allows the options to be interrogated using the typed option, e.g. `options[savedTypeOption]`. So, if you have statements similar to these in a non type checked part of your code:

```groovy
def cli = new CliBuilder()
TypedOption<Integer> age = cli.a(longOpt: 'age', type: Integer, 'some age option')
```

Then, the following statements can be in a separate part of your code which is type checked:

```groovy
def args = '--age 21'.split()
def options = cli.parse(args)
int a = options[age]
assert a == 21
```

Finally, there is one additional convenience method offered by `CliBuilder` to even allow the definition part to be type checked. It is a slightly more verbose method call. Instead of using the short name (the *opt* name) in the method call, you use a fixed name of `option` and supply the `opt` value as a property. You must also specify the type directly as shown in the following example:

```groovy
import groovy.cli.TypedOption
import groovy.transform.TypeChecked

@TypeChecked
void testTypeChecked() {
    def cli = new CliBuilder()
    TypedOption<String> name = cli.option(String, opt: 'n', longOpt: 'name', 'name option')
    TypedOption<Integer> age = cli.option(Integer, longOpt: 'age', 'age option')
    def argz = "--name John --age 21 and some more".split()
    def options = cli.parse(argz)
    String n = options[name]
    int a = options[age]
    assert n == 'John' && a == 21
    assert options.arguments() == ['and', 'some', 'more']
}
```

Advanced CLI Usage

|      | **NOTE** Advanced CLI features`CliBuilder` can be thought of as a Groovy friendly wrapper on top of either [picocli](https://github.com/remkop/picocli) or [Apache Commons CLI](https://commons.apache.org/proper/commons-cli/). If there is a feature not provided by `CliBuilder` that you know is supported in the underlying library, the current `CliBuilder` implementation (and various Groovy language features) make it easy for you to call the underlying library methods directly. Doing so is a pragmatic way to leverage the Groovy-friendly syntax offered by `CliBuilder` and yet still access some of the underlying library’s advanced features. A word of caution however; future versions of `CliBuilder` could potentially use another underlying library and in that event, some porting work may be required for your Groovy classes and/or scripts. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Apache Commons CLI

As an example, here is some code for making use of Apache Commons CLI’s grouping mechanism:

```groovy
import org.apache.commons.cli.*

def cli = new CliBuilder()
cli.f longOpt: 'from', 'f option'
cli.u longOpt: 'until', 'u option'
def optionGroup = new OptionGroup()
optionGroup.with {
  addOption cli.option('o', [longOpt: 'output'], 'o option')
  addOption cli.option('d', [longOpt: 'directory'], 'd option')
}
cli.options.addOptionGroup optionGroup
assert !cli.parse('-d -o'.split()) 
```

|      | The parse will fail since only one option from a group can be used at a time. |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Picocli

Below are some features available in the picocli version of `CliBuilder`.

**New property: errorWriter**

When users of your application give invalid command line arguments, CliBuilder writes an error message and the usage help message to the `stderr` output stream. It doesn’t use the `stdout` stream to prevent the error message from being parsed when your program’s output is used as input for another process. You can customize the destination by setting the `errorWriter` to a different value.

On the other hand, `CliBuilder.usage()` prints the usage help message to the `stdout` stream. This way, when users request help (e.g. with a `--help` parameter), they can pipe the output to a utility like `less` or `grep`.

You can specify different writers for testing. *Be aware that for backwards compatibility, setting the `writer` property to a different value will set **both** the `writer` and the `errorWriter` to the specified writer.*

**ANSI colors**

The picocli version of CliBuilder renders the usage help message in ANSI colors on supported platforms automatically. If desired you can [customize](http://picocli.info/#_usage_help_with_styles_and_colors) this. (An example follows below.)

**New property: name**

As before, you can set the synopsis of the usage help message with the `usage` property. You may be interested in a small improvement: if you only set the command `name`, a synopsis will be generated automatically, with repeating elements followed by `…` and optional elements surrounded with `[` and `]`. (An example follows below.)

**New property: usageMessage**

This property exposes a `UsageMessageSpec` object from the underlying picocli library, which gives fine-grained control over various sections of the usage help message. For example:

```groovy
def cli = new CliBuilder()
cli.name = "myapp"
cli.usageMessage.with {
    headerHeading("@|bold,underline Header heading:|@%n")
    header("Header 1", "Header 2")                     // before the synopsis
    synopsisHeading("%n@|bold,underline Usage:|@ ")
    descriptionHeading("%n@|bold,underline Description heading:|@%n")
    description("Description 1", "Description 2")      // after the synopsis
    optionListHeading("%n@|bold,underline Options heading:|@%n")
    footerHeading("%n@|bold,underline Footer heading:|@%n")
    footer("Footer 1", "Footer 2")
}
cli.a('option a description')
cli.b('option b description')
cli.c(args: '*', 'option c description')
cli.usage()
```

Gives this output:

![usageMessageSpec](https://docs.groovy-lang.org/latest/html/documentation/assets/img/usageMessageSpec.png)

**New property: parser**

The `parser` property gives access to the picocli `ParserSpec` object that can be used to customize the parser behavior. See the [documentation](http://picocli.info/apidocs/picocli/CommandLine.Model.ParserSpec.html) for details.

**Map options**

Finally, if your application has options that are key-value pairs, you may be interested in picocli’s support for maps. For example:

```groovy
import java.util.concurrent.TimeUnit
import static java.util.concurrent.TimeUnit.DAYS
import static java.util.concurrent.TimeUnit.HOURS

def cli = new CliBuilder()
cli.D(args: 2,   valueSeparator: '=', 'the old way')                          
cli.X(type: Map, 'the new way')                                               
cli.Z(type: Map, auxiliaryTypes: [TimeUnit, Integer].toArray(), 'typed map')  

def options = cli.parse('-Da=b -Dc=d -Xx=y -Xi=j -ZDAYS=2 -ZHOURS=23'.split())
assert options.Ds == ['a', 'b', 'c', 'd']                                     
assert options.Xs == [ 'x':'y', 'i':'j' ]                                     
assert options.Zs == [ (DAYS as TimeUnit):2, (HOURS as TimeUnit):23 ]         
```

|      | Previously, `key=value` pairs were split up into parts and added to a list |
| ---- | ------------------------------------------------------------ |
|      | Picocli map support: simply specify `Map` as the type of the option |
|      | You can even specify the type of the map elements            |
|      | To compare, let’s specify two key-value pairs for each option |
|      | Previously, all key-value pairs end up in a list and it is up to the application to work with this list |
|      | Picocli returns the key-value pairs as a `Map`               |
|      | Both keys and values of the map can be strongly typed        |

###### ObjectGraphBuilder

`ObjectGraphBuilder` is a builder for an arbitrary graph of beans that follow the JavaBean convention. It is in particular useful for creating test data.

Let’s start with a list of classes that belong to your domain:

```groovy
package com.acme

class Company {
    String name
    Address address
    List employees = []
}

class Address {
    String line1
    String line2
    int zip
    String state
}

class Employee {
    String name
    int employeeId
    Address address
    Company company
}
```

Then using `ObjectGraphBuilder` building a `Company` with three employees is as easy as:

```groovy
def builder = new ObjectGraphBuilder()                          
builder.classLoader = this.class.classLoader                    
builder.classNameResolver = "com.acme"                          

def acme = builder.company(name: 'ACME') {                      
    3.times {
        employee(id: it.toString(), name: "Drone $it") {        
            address(line1:"Post street")                        
        }
    }
}

assert acme != null
assert acme instanceof Company
assert acme.name == 'ACME'
assert acme.employees.size() == 3
def employee = acme.employees[0]
assert employee instanceof Employee
assert employee.name == 'Drone 0'
assert employee.address instanceof Address
```

|      | creates a new object graph builder                      |
| ---- | ------------------------------------------------------- |
|      | sets the classloader where the classes will be resolved |
|      | sets the base package name for classes to be resolved   |
|      | creates a `Company` instance                            |
|      | with 3 `Employee` instances                             |
|      | each of them having a distinct `Address`                |

Behind the scenes, the object graph builder:

- will try to match a node name into a `Class`, using a default `ClassNameResolver` strategy that requires a package name
- then will create an instance of the appropriate class using a default `NewInstanceResolver` strategy that calls a no-arg constructor
- resolves the parent/child relationship for nested nodes, involving two other strategies:
  - `RelationNameResolver` will yield the name of the child property in the parent, and the name of the parent property in the child (if any, in this case, `Employee` has a parent property aptly named `company`)
  - `ChildPropertySetter` will insert the child into the parent taking into account if the child belongs to a `Collection` or not (in this case `employees` should be a list of `Employee` instances in `Company`).

All 4 strategies have a default implementation that work as expected if the code follows the usual conventions for writing JavaBeans. In case any of your beans or objects do not follow the convention you may plug your own implementation of each strategy. For example imagine that you need to build a class which is immutable:

```groovy
@Immutable
class Person {
    String name
    int age
}
```

Then if you try to create a `Person` with the builder:

```groovy
def person = builder.person(name:'Jon', age:17)
```

It will fail at runtime with:

```
Cannot set readonly property: name for class: com.acme.Person
```

Fixing this can be done by changing the new instance strategy:

```groovy
builder.newInstanceResolver = { Class klazz, Map attributes ->
    if (klazz.getConstructor(Map)) {
        def o = klazz.newInstance(attributes)
        attributes.clear()
        return o
    }
    klazz.newInstance()
}
```

`ObjectGraphBuilder` supports ids per node, meaning that you can store a reference to a node in the builder. This is useful when multiple objects reference the same instance. Because a property named `id` may be of business meaning in some domain models `ObjectGraphBuilder` has a strategy named `IdentifierResolver` that you may configure to change the default name value. The same may happen with the property used for referencing a previously saved instance, a strategy named `ReferenceResolver` will yield the appropriate value (default is `refId'):

```groovy
def company = builder.company(name: 'ACME') {
    address(id: 'a1', line1: '123 Groovy Rd', zip: 12345, state: 'JV')          
    employee(name: 'Duke', employeeId: 1, address: a1)                          
    employee(name: 'John', employeeId: 2 ){
      address( refId: 'a1' )                                                    
    }
}
```

|      | an address can be created with an `id`                       |
| ---- | ------------------------------------------------------------ |
|      | an employee can reference the address directly with its id   |
|      | or use the `refId` attribute corresponding to the `id` of the corresponding address |

Its worth mentioning that you cannot modify the properties of a referenced bean.

###### JmxBuilder

See [Working with JMX - JmxBuilder](https://docs.groovy-lang.org/latest/html/documentation/#jmx_jmxbuilder) for details.

###### FileTreeBuilder

[FileTreeBuilder](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/util/FileTreeBuilder.html) is a builder for generating a file directory structure from a specification. For example, to create the following tree:

```
 src/
  |--- main
  |     |--- groovy
  |            |--- Foo.groovy
  |--- test
        |--- groovy
               |--- FooTest.groovy
```

You can use a `FileTreeBuilder` like this:

```groovy
tmpDir = File.createTempDir()
def fileTreeBuilder = new FileTreeBuilder(tmpDir)
fileTreeBuilder.dir('src') {
    dir('main') {
       dir('groovy') {
          file('Foo.groovy', 'println "Hello"')
       }
    }
    dir('test') {
       dir('groovy') {
          file('FooTest.groovy', 'class FooTest extends groovy.test.GroovyTestCase {}')
       }
    }
 }
```

To check that everything worked as expected we use the following `assert`s:

```groovy
assert new File(tmpDir, '/src/main/groovy/Foo.groovy').text == 'println "Hello"'
assert new File(tmpDir, '/src/test/groovy/FooTest.groovy').text == 'class FooTest extends groovy.test.GroovyTestCase {}'
```

`FileTreeBuilder` also supports a shorthand syntax:

```groovy
tmpDir = File.createTempDir()
def fileTreeBuilder = new FileTreeBuilder(tmpDir)
fileTreeBuilder.src {
    main {
       groovy {
          'Foo.groovy'('println "Hello"')
       }
    }
    test {
       groovy {
          'FooTest.groovy'('class FooTest extends groovy.test.GroovyTestCase {}')
       }
    }
 }
```

This produces the same directory structure as above, as shown by these `assert`s:

```groovy
assert new File(tmpDir, '/src/main/groovy/Foo.groovy').text == 'println "Hello"'
assert new File(tmpDir, '/src/test/groovy/FooTest.groovy').text == 'class FooTest extends groovy.test.GroovyTestCase {}'
```

### 3.16. Working with JMX

#### 3.16.1. Introduction

Given that Groovy sits directly on top of Java, Groovy can leverage the tremendous amount of work already done for [JMX](http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html) with Java. In addition, Groovy provides a `GroovyMBean` class which makes an MBean look like a normal Groovy object. This simplifies Groovy code for interacting with *MBeans*. For example, the following code:

```groovy
println server.getAttribute(beanName, 'Age')
server.setAttribute(beanName, new Attribute('Name', 'New name'))
Object[] params = [5, 20]
String[] signature = [Integer.TYPE, Integer.TYPE]
println server.invoke(beanName, 'add', params, signature)
```

can be simplified to:

```groovy
def mbean = new GroovyMBean(server, beanName)
println mbean.Age
mbean.Name = 'New name'
println mbean.add(5, 20)
```

The remainder of this page shows you how to:

- Monitor the JVM using MXBeans
- Monitor Apache Tomcat and display statistics
- Monitor Oracle OC4J and display information
- Monitor BEA WebLogic and display information
- Leverage Spring’s MBean annotation support to export your Groovy beans as MBeans

#### 3.16.2. Monitoring the JVM

MBeans are not accessed directly by an application but are managed by a repository called an *MBean server*. Java includes a special MBean server called the *platform MBean server*, which is built into the JVM. Platform MBeans are registered in this server using unique names.

You can monitor the JVM through its platform MBeans with the following code:

```groovy
import java.lang.management.*

def os = ManagementFactory.operatingSystemMXBean
println """OPERATING SYSTEM:
\tarchitecture = $os.arch
\tname = $os.name
\tversion = $os.version
\tprocessors = $os.availableProcessors
"""

def rt = ManagementFactory.runtimeMXBean
println """RUNTIME:
\tname = $rt.name
\tspec name = $rt.specName
\tvendor = $rt.specVendor
\tspec version = $rt.specVersion
\tmanagement spec version = $rt.managementSpecVersion
"""

def cl = ManagementFactory.classLoadingMXBean
println """CLASS LOADING SYSTEM:
\tisVerbose = ${cl.isVerbose()}
\tloadedClassCount = $cl.loadedClassCount
\ttotalLoadedClassCount = $cl.totalLoadedClassCount
\tunloadedClassCount = $cl.unloadedClassCount
"""

def comp = ManagementFactory.compilationMXBean
println """COMPILATION:
\ttotalCompilationTime = $comp.totalCompilationTime
"""

def mem = ManagementFactory.memoryMXBean
def heapUsage = mem.heapMemoryUsage
def nonHeapUsage = mem.nonHeapMemoryUsage
println """MEMORY:
HEAP STORAGE:
\tcommitted = $heapUsage.committed
\tinit = $heapUsage.init
\tmax = $heapUsage.max
\tused = $heapUsage.used
NON-HEAP STORAGE:
\tcommitted = $nonHeapUsage.committed
\tinit = $nonHeapUsage.init
\tmax = $nonHeapUsage.max
\tused = $nonHeapUsage.used
"""

ManagementFactory.memoryPoolMXBeans.each { mp ->
    println "\tname: " + mp.name
    String[] mmnames = mp.memoryManagerNames
    mmnames.each{ mmname ->
        println "\t\tManager Name: $mmname"
    }
    println "\t\tmtype = $mp.type"
    println "\t\tUsage threshold supported = " + mp.isUsageThresholdSupported()
}
println()

def td = ManagementFactory.threadMXBean
println "THREADS:"
td.allThreadIds.each { tid ->
    println "\tThread name = ${td.getThreadInfo(tid).threadName}"
}
println()

println "GARBAGE COLLECTION:"
ManagementFactory.garbageCollectorMXBeans.each { gc ->
    println "\tname = $gc.name"
    println "\t\tcollection count = $gc.collectionCount"
    println "\t\tcollection time = $gc.collectionTime"
    String[] mpoolNames = gc.memoryPoolNames
    mpoolNames.each { mpoolName ->
        println "\t\tmpool name = $mpoolName"
    }
}
```

When run, you will see something like this:

```
OPERATING SYSTEM:
	architecture = x86
	name = Windows XP
	version = 5.1
	processors = 2

RUNTIME:
	name = 620@LYREBIRD
	spec name = Java Virtual Machine Specification
	vendor = Sun Microsystems Inc.
	spec version = 1.0
	management spec version = 1.0

CLASS LOADING SYSTEM:
	isVerbose = false
	loadedClassCount = 919
	totalLoadedClassCount = 919
	unloadedClassCount = 0

COMPILATION:
	totalCompilationTime = 91

MEMORY:
HEAP STORAGE:
	committed = 3108864
	init = 0
	max = 66650112
	used = 1994728
NON-HEAP STORAGE:
	committed = 9240576
	init = 8585216
	max = 100663296
	used = 5897880

	name: Code Cache
		Manager Name: CodeCacheManager
		mtype = Non-heap memory
		Usage threshold supported = true
	name: Eden Space
		Manager Name: MarkSweepCompact
		Manager Name: Copy
		mtype = Heap memory
		Usage threshold supported = false
	name: Survivor Space
		Manager Name: MarkSweepCompact
		Manager Name: Copy
		mtype = Heap memory
		Usage threshold supported = false
	name: Tenured Gen
		Manager Name: MarkSweepCompact
		mtype = Heap memory
		Usage threshold supported = true
	name: Perm Gen
		Manager Name: MarkSweepCompact
		mtype = Non-heap memory
		Usage threshold supported = true

THREADS:
	Thread name = Monitor Ctrl-Break
	Thread name = Signal Dispatcher
	Thread name = Finalizer
	Thread name = Reference Handler
	Thread name = main

GARBAGE COLLECTION:
	name = Copy
		collection count = 60
		collection time = 141
		mpool name = Eden Space
		mpool name = Survivor Space
	name = MarkSweepCompact
		collection count = 0
		collection time = 0
		mpool name = Eden Space
		mpool name = Survivor Space
		mpool name = Tenured Gen
		mpool name = Perm Gen
```

#### 3.16.3. Monitoring Tomcat

First start up [Tomcat](http://tomcat.apache.org/) with JMX monitoring enabled by setting the following:

```shell
set JAVA_OPTS=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9004\
 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false
```

You can do this in your startup script and may choose any available port, we used 9004.

The following code uses JMX to discover the available MBeans in the running Tomcat, determine which are web modules, extract the processing time for each web module and displays the result in a graph using JFreeChart:

```groovy
import groovy.swing.SwingBuilder

import javax.management.ObjectName
import javax.management.remote.JMXConnectorFactory as JmxFactory
import javax.management.remote.JMXServiceURL as JmxUrl
import javax.swing.WindowConstants as WC

import org.jfree.chart.ChartFactory
import org.jfree.data.category.DefaultCategoryDataset as Dataset
import org.jfree.chart.plot.PlotOrientation as Orientation

def serverUrl = 'service:jmx:rmi:///jndi/rmi://localhost:9004/jmxrmi'
def server = JmxFactory.connect(new JmxUrl(serverUrl)).MBeanServerConnection
def serverInfo = new GroovyMBean(server, 'Catalina:type=Server').serverInfo
println "Connected to: $serverInfo"

def query = new ObjectName('Catalina:*')
String[] allNames = server.queryNames(query, null)
def modules = allNames.findAll { name ->
    name.contains('j2eeType=WebModule')
}.collect{ new GroovyMBean(server, it) }

println "Found ${modules.size()} web modules. Processing ..."
def dataset = new Dataset()

modules.each { m ->
    println m.name()
    dataset.addValue m.processingTime, 0, m.path
}

def labels = ['Time per Module', 'Module', 'Time']
def options = [false, true, true]
def chart = ChartFactory.createBarChart(*labels, dataset,
                Orientation.VERTICAL, *options)
def swing = new SwingBuilder()
def frame = swing.frame(title:'Catalina Module Processing Time', defaultCloseOperation:WC.EXIT_ON_CLOSE) {
    panel(id:'canvas') { rigidArea(width:600, height:250) }
}
frame.pack()
frame.show()
chart.draw(swing.canvas.graphics, swing.canvas.bounds)
```

When run, we will see a trace of progress being made:

```
Connected to: Apache Tomcat/6.0.13
Found 5 web modules. Processing ...
Catalina:j2eeType=WebModule,name=//localhost/,J2EEApplication=none,J2EEServer=none
Catalina:j2eeType=WebModule,name=//localhost/host-manager,J2EEApplication=none,J2EEServer=none
Catalina:j2eeType=WebModule,name=//localhost/docs,J2EEApplication=none,J2EEServer=none
Catalina:j2eeType=WebModule,name=//localhost/examples,J2EEApplication=none,J2EEServer=none
Catalina:j2eeType=WebModule,name=//localhost/manager,J2EEApplication=none,J2EEServer=none
```

The output will look like this:

![catalina](https://docs.groovy-lang.org/latest/html/documentation/assets/img/catalina.gif)

Note: if you get errors running this script, see the **Troubleshooting** section below.

#### 3.16.4. OC4J Example

Here is a script to access OC4J and print out some information about the server, its runtime and (as an example) the configured JMS destinations:

```groovy
import javax.management.remote.*
import oracle.oc4j.admin.jmx.remote.api.JMXConnectorConstant

def serverUrl = new JMXServiceURL('service:jmx:rmi://localhost:23791')
def serverPath = 'oc4j:j2eeType=J2EEServer,name=standalone'
def jvmPath = 'oc4j:j2eeType=JVM,name=single,J2EEServer=standalone'
def provider = 'oracle.oc4j.admin.jmx.remote'
def credentials = [
    (JMXConnectorConstant.CREDENTIALS_LOGIN_KEY): 'oc4jadmin',
    (JMXConnectorConstant.CREDENTIALS_PASSWORD_KEY): 'admin'
]
def env = [
    (JMXConnectorFactory.PROTOCOL_PROVIDER_PACKAGES): provider,
    (JMXConnector.CREDENTIALS): credentials
]
def server = JmxFactory.connect(serverUrl, env).MBeanServerConnection
def serverInfo = new GroovyMBean(server, serverPath)
def jvmInfo = new GroovyMBean(server, jvmPath)
println """Connected to $serverInfo.node. \
Server started ${new Date(serverInfo.startTime)}.
OC4J version:  $serverInfo.serverVersion from $serverInfo.serverVendor
JVM version:   $jvmInfo.javaVersion from $jvmInfo.javaVendor
Memory usage:  $jvmInfo.freeMemory bytes free, \
$jvmInfo.totalMemory bytes total
"""

def query = new javax.management.ObjectName('oc4j:*')
String[] allNames = server.queryNames(query, null)
def dests = allNames.findAll { name ->
    name.contains('j2eeType=JMSDestinationResource')
}.collect { new GroovyMBean(server, it) }

println "Found ${dests.size()} JMS destinations. Listing ..."
dests.each { d -> println "$d.name: $d.location" }
```

Here is the result of running this script:

```
Connected to LYREBIRD. Server started Thu May 31 21:04:54 EST 2007.
OC4J version:  11.1.1.0.0 from Oracle Corp.
JVM version:   1.6.0_01 from Sun Microsystems Inc.
Memory usage:  8709976 bytes free, 25153536 bytes total

Found 5 JMS destinations. Listing ...
Demo Queue: jms/demoQueue
Demo Topic: jms/demoTopic
jms/Oc4jJmsExceptionQueue: jms/Oc4jJmsExceptionQueue
jms/RAExceptionQueue: jms/RAExceptionQueue
OracleASRouter_store: OracleASRouter_store
```

As a slight variation, this script displays a pie chart of memory usage using JFreeChart:

```groovy
import org.jfree.chart.ChartFactory
import javax.swing.WindowConstants as WC
import javax.management.remote.*
import oracle.oc4j.admin.jmx.remote.api.JMXConnectorConstant

def url = 'service:jmx:rmi://localhost:23791'
def credentials = [:]
credentials[JMXConnectorConstant.CREDENTIALS_LOGIN_KEY] = "oc4jadmin"
credentials[JMXConnectorConstant.CREDENTIALS_PASSWORD_KEY] = "password"
def env = [:]
env[JMXConnectorFactory.PROTOCOL_PROVIDER_PACKAGES] = "oracle.oc4j.admin.jmx.remote"
env[JMXConnector.CREDENTIALS] = credentials
def server = JMXConnectorFactory.connect(new JMXServiceURL(url), env).MBeanServerConnection
def jvmInfo = new GroovyMBean(server, 'oc4j:j2eeType=JVM,name=single,J2EEServer=standalone')

def piedata = new org.jfree.data.general.DefaultPieDataset()
piedata.setValue "Free", jvmInfo.freeMemory
piedata.setValue "Used", jvmInfo.totalMemory - jvmInfo.freeMemory

def options = [true, true, true]
def chart = ChartFactory.createPieChart('OC4J Memory Usage', piedata, *options)
chart.backgroundPaint = java.awt.Color.white
def swing = new groovy.swing.SwingBuilder()
def frame = swing.frame(title:'OC4J Memory Usage', defaultCloseOperation:WC.EXIT_ON_CLOSE) {
    panel(id:'canvas') { rigidArea(width:350, height:250) }
}
frame.pack()
frame.show()
chart.draw(swing.canvas.graphics, swing.canvas.bounds)
```

Which looks like:

![oc4jpie](https://docs.groovy-lang.org/latest/html/documentation/assets/img/oc4jpie.gif)

#### 3.16.5. WebLogic Example

This script prints out information about the server followed by information about JMS Destinations (as an example). Many other mbeans are [available](http://docs.oracle.com/cd/E13222_01/wls/docs90/wlsmbeanref/core/index.html).

```groovy
import javax.management.remote.*
import javax.management.*
import javax.naming.Context

def urlRuntime = '/jndi/weblogic.management.mbeanservers.runtime'
def urlBase = 'service:jmx:t3://localhost:7001'

def serviceURL = new JMXServiceURL(urlBase + urlRuntime)
def h = new Hashtable()
h.put(Context.SECURITY_PRINCIPAL, 'weblogic')
h.put(Context.SECURITY_CREDENTIALS, 'weblogic')
h.put(JMXConnectorFactory.PROTOCOL_PROVIDER_PACKAGES, 'weblogic.management.remote')
def server = JMXConnectorFactory.connect(serviceURL, h).MBeanServerConnection
def domainName = new ObjectName('com.bea:Name=RuntimeService,Type=weblogic.management.mbeanservers.runtime.RuntimeServiceMBean')
def rtName = server.getAttribute(domainName, 'ServerRuntime')
def rt = new GroovyMBean(server, rtName)
println "Server: name=$rt.Name, state=$rt.State, version=$rt.WeblogicVersion"
def destFilter = Query.match(Query.attr('Type'), Query.value('JMSDestinationRuntime'))
server.queryNames(new ObjectName('com.bea:*'), destFilter).each { name ->
    def jms = new GroovyMBean(server, name)
    println "JMS Destination: name=$jms.Name, type=$jms.DestinationType, messages=$jms.MessagesReceivedCount"
}
```

Here is the output:

```
Server: name=examplesServer, state=RUNNING, version=WebLogic Server 10.0  Wed May 9 18:10:27 EDT 2007 933139
JMS Destination: name=examples-jms!exampleTopic, type=Topic, messages=0
JMS Destination: name=examples-jms!exampleQueue, type=Queue, messages=0
JMS Destination: name=examples-jms!jms/MULTIDATASOURCE_MDB_QUEUE, type=Queue, messages=0
JMS Destination: name=examplesJMSServer!examplesJMSServer.TemporaryQueue0, type=Queue, messages=68
JMS Destination: name=examples-jms!quotes, type=Topic, messages=0
JMS Destination: name=examples-jms!weblogic.wsee.wseeExamplesDestinationQueue, type=Queue, messages=0
JMS Destination: name=examples-jms!weblogic.examples.ejb30.ExampleQueue, type=Queue, messages=0
```

#### 3.16.6. Spring Example

You can also use Spring to automatically register beans as JMX aware.

Here is an example class (Calculator.groovy):

```groovy
import org.springframework.jmx.export.annotation.*

@ManagedResource(objectName="bean:name=calcMBean", description="Calculator MBean")
public class Calculator {

    private int invocations

    @ManagedAttribute(description="The Invocation Attribute")
    public int getInvocations() {
        return invocations
    }

    private int base = 10

    @ManagedAttribute(description="The Base to use when adding strings")
    public int getBase() {
        return base
    }

    @ManagedAttribute(description="The Base to use when adding strings")
    public void setBase(int base) {
        this.base = base
    }

    @ManagedOperation(description="Add two numbers")
    @ManagedOperationParameters([
        @ManagedOperationParameter(name="x", description="The first number"),
        @ManagedOperationParameter(name="y", description="The second number")])
    public int add(int x, int y) {
        invocations++
        return x + y
    }

    @ManagedOperation(description="Add two strings representing numbers of a particular base")
    @ManagedOperationParameters([
        @ManagedOperationParameter(name="x", description="The first number"),
        @ManagedOperationParameter(name="y", description="The second number")])
    public String addStrings(String x, String y) {
        invocations++
        def result = Integer.valueOf(x, base) + Integer.valueOf(y, base)
        return Integer.toString(result, base)
    }
}
```

Here is the Spring configuration file (beans.xml):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="mbeanServer"
          class="org.springframework.jmx.support.MBeanServerFactoryBean">
        <property name="locateExistingServerIfPossible" value="true"/>
    </bean>

    <bean id="exporter"
          class="org.springframework.jmx.export.MBeanExporter">
        <property name="assembler" ref="assembler"/>
        <property name="namingStrategy" ref="namingStrategy"/>
        <property name="beans">
            <map>
                <entry key="bean:name=defaultCalcName" value-ref="calcBean"/>
            </map>
        </property>
        <property name="server" ref="mbeanServer"/>
        <property name="autodetect" value="true"/>
    </bean>

    <bean id="jmxAttributeSource"
          class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>

    <!-- will create management interface using annotation metadata -->
    <bean id="assembler"
          class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
        <property name="attributeSource" ref="jmxAttributeSource"/>
    </bean>

    <!-- will pick up the ObjectName from the annotation -->
    <bean id="namingStrategy"
          class="org.springframework.jmx.export.naming.MetadataNamingStrategy">
        <property name="attributeSource" ref="jmxAttributeSource"/>
    </bean>

    <bean id="calcBean"
          class="Calculator">
        <property name="base" value="10"/>
    </bean>
</beans>
```

Here is a script which uses this bean and configuration:

```groovy
import org.springframework.context.support.ClassPathXmlApplicationContext
import java.lang.management.ManagementFactory
import javax.management.ObjectName
import javax.management.Attribute

// get normal bean
def ctx = new ClassPathXmlApplicationContext("beans.xml")
def calc = ctx.getBean("calcBean")

Thread.start {
    // access bean via JMX, use a separate thread just to
    // show that we could access remotely if we wanted
    def server = ManagementFactory.platformMBeanServer
    def mbean = new GroovyMBean(server, 'bean:name=calcMBean')
    sleep 1000
    assert 8 == mbean.add(7, 1)
    mbean.Base = 8
    assert '10' == mbean.addStrings('7', '1')
    mbean.Base = 16
    sleep 2000
    println "Number of invocations: $mbean.Invocations"
    println mbean
}

assert 15 == calc.add(9, 6)
assert '11' == calc.addStrings('10', '1')
sleep 2000
assert '20' == calc.addStrings('1f', '1')
```

And here is the resulting output:

```
Number of invocations: 5
MBean Name:
  bean:name=calcMBean

Attributes:
  (rw) int Base
  (r) int Invocations
Operations:
  int add(int x, int y)
  java.lang.String addStrings(java.lang.String x, java.lang.String y)
  int getInvocations()
  int getBase()
  void setBase(int p1)
```

You can even attach to the process while it is running with [jconsole](http://docs.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html). It will look something like:

![jconsole](https://docs.groovy-lang.org/latest/html/documentation/assets/img/jconsole.gif)

We started the Groovy application with the `-Dcom.sun.management.jmxremote` JVM argument.

See also:

- [Dynamic language beans in Spring](https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#dynamic-language-beans)
- [Spring JMX Documentation](https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#jmx)

#### 3.16.7. Troubleshooting

##### java.lang.SecurityException

If you get the following error, your container’s JMX access is password protected:

```
java.lang.SecurityException: Authentication failed! Credentials required
```

To fix that, add an environment with the credentials when connecting, like this (password has to be set before that):

```groovy
def jmxEnv = null
if (password != null) {
    jmxEnv = [(JMXConnector.CREDENTIALS): (String[])["monitor", password]]
}
def connector = JMXConnectorFactory.connect(new JMXServiceURL(serverUrl), jmxEnv)
```

Details for the software you are trying to monitor/manage may differ slightly. Check out the other examples using credentials above if appropriate (e.g. OC4J and WebLogic). If you still have troubles, you will have to consult the documentation for the software you are trying to monitor/manage for details on how to provide credentials.

#### 3.16.8. JmxBuilder

**JmxBuilder is a Groovy-based domain specific language for the Java Management Extension (JMX) API**. It uses the builder pattern (FactoryBuilder) to create an internal DSL that facilitates the exposure of POJO’s and Groovy beans as management components via the MBean server. JmxBuilder hides the complexity of creating and exporting management beans via the JMX API and provides a set of natural Groovy constructs to interact with the JMX infrastructure.

##### Instantiating JmxBuilder

To start using JmxBuilder, simply make sure the jar file is on your class path. Then you can do the following in your code:

```groovy
def jmx = new JmxBuilder()
```

**That’s it!** You are now ready to use the JmxBuilder.

**NOTE**

- You can pass in an instance of **your own MBeanServer** to the builder (**JmxBuilder(MBeanServer)**)
- If no MBeanServer is specified, the builder instance will default to the underlying platform MBeanServer.

Once you have an instance of JmxBuilder, you are now ready to invoke any of its builder nodes.

##### JMX Connectors

Remote connectivity is a crucial part of the JMX architecture. JmxBuilder facilitates the creation of connector servers and connector clients with a minimal amount of coding.

###### Connector Server

JmxBuilder.connectorServer() supports the full Connector api syntax and will let you specify properties, override the URL, specify your own host, etc.

**Syntax**

```
jmx.connectorServer(
    protocol:"rmi",
    host:"...",
    port:1099,
    url:"...",
    properties:[
        "authenticate":true|false,
        "passwordFile":"...",
        "accessFile":"...",
        "sslEnabled" : true | false
        // any valid connector property
    ]
)
```

Note that the serverConnector node will accept four ServerConnector property aliases (authenticate, passwordFile,accessFile, and sslEnabled). You can use these aliases or provided any of the RMI-supported properties.

**Example - Connector Server (see correction below)**

```groovy
jmx.connectorServer(port: 9000).start()
```

The snippet above returns an RMI connector that will start listening on port 9000. By default, the builder will internally generate URL **"service:jmx:rmi:///jndi/rmi://localhost:9000/jmxrmi"**.

*NOTE: Sadly you are as likely to get something like the following when attempting to run the previous snippet of code (example is incomplete, see below):*

```
Caught: java.io.IOException: Cannot bind to URL [rmi://localhost:9000/jmxrmi]: javax.naming.ServiceUnavailableException [Root exception is java.rmi.ConnectException: Connection refused to host: localhost; nested exception is:
?????? java.net.ConnectException: Connection refused]
??
```

*This occurs on Mac and Linux (CentOS 5) with Groovy 1.6 installed. Perhaps there were assumptions made about the configuration of the /etc/hosts file?*

|      | *The correct example is shown below.* |
| ---- | ------------------------------------- |
|      |                                       |

**Connector Example (Corrected) - Connector Server**

The example above does not create the RMI registry. So, in order to export, you have to first export the RMI object registry (make sure to import `java.rmi.registry.LocateRegistry`).

```groovy
import java.rmi.registry.LocateRegistry
//...

LocateRegistry.createRegistry(9000)
jmx.connectorServer(port: 9000).start()
```

###### Connector Client

JmxBuilder.connectorClient() node lets you create JMX connector client object to connect to a JMX MBean Server.

**Syntax**

```
jmx.connectorClient (
    protocol:"rmi",
    host:"...",
    port:1099,
    url:"...",
)
```

**Example - Client Connector**

Creating a connector client can be done just as easily. With one line of code, you can create an instance of a JMX Connector Client as shown below.

```groovy
def client = jmx.connectorClient(port: 9000)
client.connect()
```

You can then access the MBeanServerConnection associated with the connector using:

```groovy
client.getMBeanServerConnection()
```

##### JmxBuilder MBean Export

You can **export a Java object or a Groovy object** with minimal coding. JmxBuilder will even find and **export dynamic Groovy methods** injected at runtime.

###### Implicit vs Explicit Descriptors

When using the builder, you can **let JmxBuilder implicitly generate** all of your MBean descriptor info. This is useful when you want to write minimal code to quickly export your beans. You can also explicitly declare all descriptor info for the bean. This gives you total control on how you want to describe every piece of information that you want to export for the underlying bean.

###### The JmxBuilder.export() Node

The **JmxBuilder.export() node provides a container** where all management entities to be exported to the MBeanServer are placed. You can place one or more bean() or timer() nodes as children of the export() node. JmxBuilder will **automatically batch export the entities described** by the nodes to the MBean server for management (see example below).

```groovy
def beans = jmx.export {
    bean(new Foo())
    bean(new Bar())
    bean(new SomeBar())
}
```

In the code snippet above, **JmxBuilder.export() will export three management beans** to the MBean server.

###### JmxBuilder.export() Syntax

JmxBuilder.export() node supports the **registrationPolicy** parameter to specify how JmxBuilder will behave to resolve bean name collision during MBean registration:

```
jmx.export(policy:"replace|ignore|error")
or
jmx.export(regPolicy:"replace|ignore|error")
```

- **replace** - JmxBuilder.export() will replace any bean already registered with the MBean during export.
- **ignore** - The bean being exported will be ignored if the same bean is already registered.
- **error** - JmxBuilder.export() throws an error upon bean name collision during registration.

###### Integration with GroovyMBean Class

When you export an MBean to the MBeanServer, **JmxBuilder will return an instance of GroovyMBean** representing the management bean that have been exported by the builder. Nodes such as **bean()** and **timer()** will return an instances of GroovyMBean when they are invoked. The **export()** node returns an **array of all of GroovyMBean[]** representing all managed objects exported to the MBean server.

###### MBean Registration with JmxBuilder.bean()

This portion of this reference uses class **RequestController** to illustrate how to use JmxBuilder to export runtime management beans. The class is for illustration purpose and can be a POJO or a Groovy bean.

**RequestController**

```groovy
class RequestController {
    // constructors
    RequestController() { super() }
    RequestController(Map resource) { }

    // attributes
    boolean isStarted() { true }
    int getRequestCount() { 0 }
    int getResourceCount() { 0 }
    void setRequestLimit(int limit) { }
    int getRequestLimit() { 0 }

    // operations
    void start() { }
    void stop() { }
    void putResource(String name, Object resource) { }
    void makeRequest(String res) { }
    void makeRequest() { }
}
```

Implicit Export

As mentioned earlier, you can use JmxBuilder’s flexible syntax to export any POJO/POGO with no descriptor. The builder can automatically describe all aspects of the management beans using implicit defaults. These default values can easily be overridden as we’ll see in this in the next section.

The simplest way to export a POJO or POGO is listed below.

```groovy
jmx.export {
    bean(new RequestController(resource: "Hello World"))
}
```

**What this does:**

- First, the **JmxBuilder.export() node will export** an MBean to the MBeanServer representing **the declared POJO** instance.
- The builder will **generate a default ObjectName** for the MBean and all other MBean descriptor information.
- **JmxBuilder will automatically export** all declared **attributes** (MBean getter/setters), **constructors**, and **operations** on the instance.
- The exported **attributes** will have **read-only** visibility.

Remember, **JmxBuilder.export() returns an array of GroovyMBean[] objects** for all exported instances. So, once you call JmxBuilder.export(), **you have immediate access to the underlying MBean proxy** (via GroovyMBean).

JConsole view of Exported Bean

![jconsole implicit export](https://docs.groovy-lang.org/latest/html/documentation/assets/img/jconsole-implicit-export.png)

###### JmxBuilder.bean() Syntax

The JmxBuilder.bean() node supports an extensive set of descriptors to describe your bean for management. The JMX MBeanServer uses these descriptors to expose meta data about the bean exposed for management.

```
jmx.export {
    bean(
        target:bean instance,
        name:ObjectName,
        desc:"...",
        attributes:"*",
        attributes:[]
        attributes:[ "AttrubuteName1","AttributeName2",...,"AttributeName_n" ]
        attributes:[
            "AttributeName":"*",
            "AttributeName":[
                desc:"...",
                defaultValue:value,
                writable:true|false,
                editable:true|false,
                onChange:{event-> // event handler}
            ]
        ],

        constructors:"*",
        constructors:[
            "Constructor Name":[],
            "Constructor Name":[ "ParamType1","ParamType2,...,ParamType_n" ],
            "Constructor Name":[
                desc:"...",
                params:[
                    "ParamType1":"*",
                    "ParamType2":[desc:"...", name:"..."],...,
                    "ParamType_n":[desc:"...", name:"..."]
                ]
            ]
        ],

        operations:"*",
        operations:[ "OperationName1", "OperationName2",...,"OperationNameN" ],
        operations:[
            "OperationName1":"*",
            "OperationName2":[ "type1","type2,"type3" ]
            "OperationName3":[
                desc:"...",
                params:[
                    "ParamType1":"*"
                    "ParamType2":[desc:"...", name:"..."],...,
                    "ParamType_n":[desc:"...", name:"..."]
                ],
                onInvoked:{event-> JmxBuilder.send(event:"", to:"")}
            ]
        ],

        listeners:[
            "ListenerName1":[event: "...", from:ObjectName, call:{event->}],
            "ListenerName2":[event: "...", from:ObjectName, call:&methodPointer]
        ]

    )
}
```

Instead of describing the entire node, the following section explore each attribute separately.

###### Bean() Node - Specifying MBean ObjectName

Using the bean() node descriptors, you can specify your own MBean ObjectName.

```groovy
def ctrl = new RequestController(resource:"Hello World")
def beans = jmx.export {
    bean(target: ctrl, name: "jmx.tutorial:type=Object")
}
```

The ObjectName can be specified as a String or an instance of the ObjectName.

##### Bean() Node - Attribute Export

JMX attributes are the setters and getters on the underlying bean. The JmxBuilder.bean() node provides several ways to flexibly describe and export MBean attributes. You can combine them however you want to achieve any level of attribute visibility. Let’s take a look.

###### Export All Attributes with Wildcard "*"

The following code snippet **will describe and export all attributes** on the bean as read-only. **JmxBuilder will use default values** to describe the attributes that exported for management.

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(target: new RequestController(),
    name: objName,
    attributes: "*")
}
```

###### Export Attribute List

JmxBuilder will let you specify a list of attributes to export.

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        attributes: ["Resource", "RequestCount"]
    )
}
```

In the snippet above, **only the "Resource" and "RequestCount" attributes will be exported**. Again, since no descriptors are provided, **JmxBuilder will use sensible defaults** to describe the exported attributes.

###### Export Attribute with Explicit Descriptors

One of the strengths of JmxBuilder is its flexibility in describing MBean. With the builder you can describe all aspects of the MBeans attribute that you want to export to the MBeanServer (see syntax above).

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        attributes: [
            "Resource": [desc: "The resource to request.", readable: true, writable: true, defaultValue: "Hello"],
            "RequestCount": "*"
        ]
    )
}
```

In the snippet above, attribute **"Resource" is fully-described** using all supported descriptors (i.e. desc, readable, writable, defaultValue) for a JMX attribute. However, we use the wildcard to describe attribute **RequestCount** and it will be exported and described using defaults.

##### Bean() Node - Constructor Export

JmxBuilder **supports the explicit description and export of constructors** defined in the underlying bean. There are several options available when exporting constructors. You can combine them however you want to achieve the desired level of manageability.

###### Export all Constructors with "*"

You can use the builder’s special "*" **notation to export all constructors** declared on the underlying bean. The builder will use default values to describe the MBean constructors.

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        constructors: "*"
    )
}
```

###### Export Constructors using Parameter Descriptor

JmxBuilder lets you **target specific constructor** to export **by describing the parameter signature**. This is useful when you have several constructors with different parameter signature and you want to export specific constructors.

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        constructors: [
            "RequestController": ["Object"]
        ]
    )
}
```

Here, JmxBuilder will **export a constructor that takes one parameter of type "Object"**. Again, JmxBuilder will use default values to fill in the description of the constructor and the parameters.

###### Export Constructor with Explicit Descriptors

JmxBuilder allows you to **fully-describe** the constructor that you want to target for export (see syntax above).

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(target: new RequestController(), name: objName,
        constructors: [
            "RequestController": [
                desc: "Constructor takes param",
                params: ["Object" : [name: "Resource", desc: "Resource for controller"]]
            ]
        ]
    )
}
```

In the code above, JmxBuilder will target a constructor that takes one parameter for export to the MBeanServer. Notice how the constructor can be fully-described using all optional descriptor keys including parameter descriptors.

##### Bean() Node - Operation Export

Similar to constructors, JmxBuilder supports the description and export of MBean operations using a flexible notation (see above for syntax). You can combine these notations however you want to achieve the level of operation manageability desired.

###### Export All Operations with "*"

You can use the builder’s special "*" **notation to export all operations** defined on the bean to be exposed for management. The builder will use default descriptor values for the operations being exported.

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        operations: "*"
    )
}
```

In this snippet, JmxBuilder will **export all bean operations** and will use default values to describe them in the MBeanServer.

###### Export Operation List

JmxBuilder has a shorthand notation that lets you quickly target operations to be exported by providing a list of methods to export.

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        operations: ["start", "stop"]
    )
}
```

In the snippet above, the **builder will only export methods start() and stop()**. All other methods will be ignored. JmxBuilder will use default descriptor values to describe the operations being exported.

###### Export Operations by Signature

Using JmxBuilder, you can target methods to export for management using the methods’s parameter signature. This is useful when you want to distinguish methods with the same name that you want to export (i.e. stop() instead of stop(boolean)).

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(
        target: new RequestController(),
        name: objName,
        operations: [
            "makeRequest": ["String"]
        ]
    )
}
```

In the snippet above, JmxBuilder would **select method makeRequest(String)** to be exported instead of the other version makeRequest() which takes no parameter. In this shorthand context, the signature is specified as a list of type (i.e. "String").

###### Export Operations with Explicit Descriptors

JmxBuilder supports detailed descriptors for bean operations. You can supply deep descriptor info about any operation on your bean including a name, description, method parameters, parameter type, and parameter description.

```groovy
def objName = new ObjectName("jmx.tutorial:type=Object")
def beans = jmx.export {
    bean(target: new RequestController(), name: objName,
        operations: [
            "start": [desc: "Starts request controller"],
            "stop": [desc: "Stops the request controller"],
            "setResource": [params: ["Object"]],
            "makeRequest": [
                desc: "Executes the request.",
                params: [
                    "String": [name: "Resource", desc: "The resource to request"]
                ]
            ]
        ]
    )
}
```

The snippet above shows all of the ways JmxBuilder allows you to describe an operation targeted for management:

- Operations **start() and stop()** are described by the "desc" key (this is enough since there are no params).
- In operation **setResource()** uses of a shorthand version of **params**: to describe the parameters for the method.
- **makeRequest()** uses the extended descriptor syntax to describe all aspects of the operation.

##### Embedding Descriptor

JmxBuilder supports the ability to **embed descriptors directly in your Groovy class**. So, instead of wrapping your description around the declared object (as we’ve seen here), you can embed your JMX descriptors directly in your class.

**RequestControllerGroovy**

```groovy
class RequestControllerGroovy {
    // attributes
    boolean started
    int requestCount
    int resourceCount
    int requestLimit
    Map resources

    // operations
    void start() { }
    void stop(){ }
    void putResource(String name, Object resource) { }
    void makeRequest(String res) { }
    void makeRequest() { }

    static descriptor = [
        name: "jmx.builder:type=EmbeddedObject",
        operations: ["start", "stop", "putResource"],
        attributes: "*"
    ]
}

// export
jmx.export(
    bean(new RequestControllerGroovy())
)
```

There are two things going on in the code above:

- Groovy class RequestControllerGroovy is defined and includes a **static descriptor** member. That member is used to declare a JmxBuilder descriptor to describe member of the class targeted for JMX export.
- The second part of the code shows how to use JmxBuilder to export that class for management.

##### Timer Export

JMX standards mandate that the implementation of the API makes available a timer service. Since JMX is a component-based architecture, timers provide an excellent signalling mechanism to communicate to registered listener components in the MBeanServer. JmxBuilder supports the creation and export of timers using the same easy syntax we’ve seen so far.

###### Timer Node Syntax

```
timer(
    name:ObjectName,
    event:"...",
    message:"...",
    data:dataValue
    startDate:"now"|dateValue
    period:"99d"|"99h"|"99m"|"99s"|99
    occurrences:long
)
```

The timer() node supports several attributes:

- **name**: - Required The qualified JMX ObjectName instance (or String) for the timer.
- **event**: - The JMX event type string that will be broadcast with every timing signal (default **"jmx.builder.event"**).
- **message**: - An optional string value that can be sent to listeners.
- **data**: - An optional object that can be sent to listeners of timing signal.
- **startDate**: - When to start timer. Set of valid values [ "now", date object ]. Default is "now"
- **period**: - A timer’s period expressed as either a number of millisecond or time unit (day, hour, minute, second). See description below.
- **occurrences**: - A number indicating the number of time to repeat timer. Default is forever.

###### Exporting a Timer

```groovy
def timer = jmx.timer(name: "jmx.builder:type=Timer", event: "heartbeat", period: "1s")
timer.start()
```

This snippet above **describes, creates, and exports a standard JMX Timer** component. Here, the **timer()** node **returns a GroovyMBean** that represents the registered timer MBean in the MBeanServer.

An **alternative way of exporting timers** is within the JmxBuilder.export() node.

```groovy
def beans = jmx.export {
    timer(name: "jmx.builder:type=Timer1", event: "event.signal", period: "1s")
    timer(name: "jmx.builder:type=Timer2", event: "event.log", period: "1s")
}
beans[0].start()
beans[1].start()
```

###### Timer Period

The **timer() node supports a flexible notation** for specifying the **timer period values**. You can specify the time in second, minutes, hour, and day. The default is millisecond.

- timer(**period: 100**) = 100 millisecond
- timer(**period: "1s"**) = 1 second
- timer(**period: "1m"**) = 1 minute
- timer(**period: "1h"**) = 1 hour
- timer(**period: "1d"**) = 1 day

The node will automatically translate.

##### JmxBuilder and Events

An integral part of **JMX** is its **event model**. Registered management beans can **communicate with each other by broadcasting events** on the MBeanServer’s event bus. **JmxBuilder provides several ways to easily listen and react to events** broadcasted on the MBeanServer’s event bus. Developers can **capture any event on the bus or throw their own** to be consumed by other components registered on the MBeanServer.

###### Event Handling Closures

JmxBuilder leverages Groovy’s use of closures to provide simple, yet elegant, mean of reacting to JMX events. JmxBuilder supports two closure signatures:

Parameterless

```groovy
callback = { ->
    // event handling code here.
}
```

JmxBuilder executes the closure and passes no information about the event that was captured on the bus.

With Event Parameter

```groovy
callback = { event ->
    // event handling code
}
```

JmxBuilder will pass an **"event" object to the closure** using this format. The event object contains information about the event was intercepted so that it can be handled by the handler. The parameter will contain different set of info depending on the event that was captured.

###### Handling Attribute onChange Event

When describing attributes (see bean() node section above), you can **provide a closure (or method pointer) for callback to be executed when the value of the attribute is updated** on the exported MBean. This gives developers an opportunity to listen to and react to state changes on the MBean.

```groovy
jmx.export {
    bean(
        target: new RequestController(), name: "jmx.tutorial:type=Object",
        attributes: [
            "Resource": [
                readable: true, writable: true,
                onChange: { e ->
                    println e.oldValue
                    println e.newValue
                }
            ]
        ]
    )
}
```

The sample snippet above shows how to **specify an "onChange" callback closure** when describing MBean attributes. In this sample code, whenever attribute "Resource" is updated via the exported MBean, the **onChange event will be executed**.

###### Attribute onChange Event Object

When handling the attribute onChange event, the handler closure will receive an event object with the following info:

- event.**oldValue** - the previous attribute value before the change event.
- event.**newValue** - the new value of the attribute after the change.
- event.**attribute** - the name of the attribute on which the event occurred.
- event.**attributeType** - the data type of the attribute that causes the event.
- event.**sequenceNumber** - a numeric value representing the sequence number of event.
- event.**timeStamp** - a time stamp for the event occurrence.

###### Handling Operation onCall Event

Similar to mbean attributes, JmxBuilder affords developers the **ability to listen for operation invocation** on an MBean registered in the MBeaServer. JmxBuilder accepts a **callback closure that will be executed after the MBean method has invoked**.

```groovy
class EventHandler {
    void handleStart(e){
        println e
    }
}
def handler = new EventHandler()

def beans = jmx.export {
    bean(target: new RequestController(), name: "jmx.tutorial:type=Object",
        operations: [
            "start": [
                desc:"Starts request controller",
                onCall:handler.&handleStart
            ]
        ]
    )
}
```

The snippet above **shows how to declare an "onCall" closure to be used as listener** when operation "start()" is invoked on the MBean. This sample **uses the method pointer syntax** to illustrate the versatility of JmxBuilder.

###### Operation onCall Event Object

When handling the operation onCall event, the callback closure will receive an event object with the following info:

- event.**event** - the event type string that was broadcasted.
- event.**source** - The object on which the method was invoked.
- event.**data** - the data type of the attribute that causes the event.
- event.**sequenceNumber** - a numeric value representing the sequence number of event.
- event.**timeStamp** - a time stamp for the event occurrence.

##### Listener MBean

When you export an MBean with the bean() node, you can define events the MBean can listen and react to. The bean() node provides a "listeners:" attribute that lets you define event listeners that your bean can react to.

```groovy
def beans = jmx.export {
    timer(name: "jmx.builder:type=Timer", event: "heartbeat", period: "1s").start()
    bean(target: new RequestController(), name: "jmx.tutorial:type=Object",
        operations: "*",
        listeners: [
            heartbeat: [
                from: "jmx.builder:type=Timer",
                call: { e ->
                    println e
                }
            ]
        ]
    )
}
```

In the sample above, we see the **syntax for adding listeners to an exported MBean**.

- Fist, a **timer is exported** and started.
- Then an **MBean is declared that will listen to the timer** event and do something meaningful.
- The **"heartbeat:"** name is arbitrary and has no correlation to the timer declared above.
- The **source** of the event **is specified using the "from:" attribute**.

You can also specify an **event type** you are interested in receiving from a broadcaster (since a broadcaster can be emitting multiple events).

###### Listening to JMX Events

In some cases, you will want to create stand-alone event listeners (not attached to exported MBeans). JmxBuilder provides the Listener() node to let you create JMX listeners that can listen to MBeanServer events. This is useful when creating JMX client applications to monitor/manage JMX agents on remote JMX MBeanServers.

###### Listener Node Syntax

```
jmx.listener(
    event: "...",
    from: "object name" | ObjectName,
    call: { event-> }
)
```

Here is the description of the **listener()** node attributes:

- event: An optional string that identifies the JMX event type to listen for.
- from (required): The JMX ObjectName of the component to listen to. This can be specified as a string or an instance of ObjectName
- call: The closure to execute when the event is captured. This can also be specified as a Groovy method pointer.

Here is an example of JmxBuilder’s listener node:

```groovy
jmx.timer(name: "jmx.builder:type=Timer", period: "1s").start()

jmx.listener(
    from: "jmx.builder:type=Timer",
    call: { e ->
        println "beep..."
    }
)
```

This example shows how you can use a stand alone listener (outside of an MBean export). Here, we **export a timer with a 1 second** resolution. Then, we specify a listener to that timer that will print "beep" every second.

##### Emitting JMX Events

JmxBuilder provides the **tools needed to broadcast your own events** on the MBeanServer’s event bus. There are no restrictions on the event type you can broadcast. You simply **declare your emitter** and the event type that you want to send, then **broadcast your event** at any time. Any registered component in the MBeanServer can register themselves to listen to your events.

###### Emitter Syntax

```
jmx.emitter(name:"Object:Name", event:"type")
```

The attributes for the node Emitter() can be summarized as follows:

- name: an optional JMX ObjectName used to register your emitter in the MBeanServer. Default is jmx.builder:type=Emitter,name=Emitter@OBJECT_HASH_VALUE
- event: an option string value that describes the JMX event type. Default is **"jmx.builder.event.emitter"**.

###### Declare the Emitter

```groovy
def emitter = jmx.emitter()
```

The snippet **declares the emitter using implicit descriptor syntax**. JmxBuilder will do the followings:

- Create and register an emitter MBean with a default ObjectName.
- Setup a **default event type** with value **"jmx.builder.event.emitter"**.
- Return a GroovyMBean representing the emitter.

As with other nodes in the builder, **you can override all keys in the emitter() node**. You can specify the **ObjectName** and the **event type**.

###### Broadcast Event

Once you have declared your emitter, you can broadcast your event.

```groovy
emitter.send()
```

The sample above shows the **emitter sending an event**, once it has been declared. Any JMX component registered in the MBeanServer can register to receive message from this emitter.

###### Sending Event Objects

You can optionally pass data to the receiver when you send the message.

```groovy
emitter.send("Hello!")
```

If you use an **event listener closure (see above) that accepts a parameter**, you can access that value.

#### 3.16.9. Further JMX Information

- [Monitoring the Java Virtual Machine](http://www.ddj.com/dept/java/184406481?pgno=1)
- [Using Groovy for System Management](http://buttso.blogspot.com/2006/05/using-groovy-for-system-management.html)
- [Groovier jconsole!](https://blogs.oracle.com/sundararajan/entry/groovier_jconsole)
- [JMX Scripts with Eclipse Monkey](http://jmesnil.net/weblog/2007/05/23/jmx-scripts-with-eclipse-monkey)
- [Using JMX to monitor Apache ActiveMQ](http://activemq.apache.org/jmx.html)

### 3.17. Creating Swing UIs

Creating Swing UIs is made easy thanks to the use of [SwingBuilder](https://docs.groovy-lang.org/latest/html/documentation/#swingbuilder).

### 3.18. Security

(TBD)

### 3.19. Design patterns in Groovy

Using [design patterns](http://en.wikipedia.org/wiki/Design_pattern_(computer_science)) with Java is a well-established topic. Design patterns also apply to Groovy:

- some patterns carry over directly (and can make use of normal Groovy syntax improvements for greater readability)
- some patterns are no longer required because they are built right into the language or because Groovy supports a better way of achieving the intent of the pattern
- some patterns that have to be expressed at the design level in other languages can be implemented directly in Groovy (due to the way Groovy can blur the distinction between design and implementation)

#### 3.19.1. Patterns

##### Abstract Factory Pattern

The [Abstract Factory Pattern](http://en.wikipedia.org/wiki/Abstract_factory_pattern) provides a way to encapsulate a group of individual factories that have a common theme. It embodies the intent of a normal factory, i.e. remove the need for code using an interface to know the concrete implementation behind the interface, but applies to a set of interfaces and selects an entire family of concrete classes which implement those interfaces.

As an example, I might have interfaces Button, TextField and Scrollbar. I might have WindowsButton, MacButton, FlashButton as concrete classes for Button. I might have WindowsScrollBar, MacScrollBar and FlashScrollBar as concrete implementations for ScrollBar. Using the Abstract Factory Pattern should allow me to select which windowing system (i.e. Windows, Mac, Flash) I want to use once and from then on should be able to write code that references the interfaces but is always using the appropriate concrete classes (all from the one windowing system) under the covers.

###### Example

Suppose we want to write a game system. We might note that many games have very similar features and control.

We decide to try to split the common and game-specific code into separate classes.

First let’s look at the game-specific code for a [Two-up](http://en.wikipedia.org/wiki/Two-Up) game:

```groovy
class TwoupMessages {
    def welcome = 'Welcome to the twoup game, you start with $1000'
    def done = 'Sorry, you have no money left, goodbye'
}

class TwoupInputConverter {
    def convert(input) { input.toInteger() }
}

class TwoupControl {
    private money = 1000
    private random = new Random()
    private tossWasHead() {
        def next = random.nextInt()
        return next % 2 == 0
    }
    def moreTurns() {
        if (money > 0) {
            println "You have $money, how much would you like to bet?"
            return true
        }

        false
    }
    def play(amount) {
        def coin1 = tossWasHead()
        def coin2 = tossWasHead()
        if (coin1 && coin2) {
            money += amount
            println 'You win'
        } else if (!coin1 && !coin2) {
            money -= amount
            println 'You lose'
        } else {
            println 'Draw'
        }
    }
}
```

Now, let’s look at the game-specific code for a number guessing game:

```groovy
class GuessGameMessages {
    def welcome = 'Welcome to the guessing game, my secret number is between 1 and 100'
    def done = 'Correct'
}

class GuessGameInputConverter {
    def convert(input) { input.toInteger() }
}

class GuessGameControl {
    private lower = 1
    private upper = 100
    private guess = new Random().nextInt(upper - lower) + lower
    def moreTurns() {
        def done = (lower == guess || upper == guess)
        if (!done) {
            println "Enter a number between $lower and $upper"
        }

        !done
    }
    def play(nextGuess) {
        if (nextGuess <= guess) {
            lower = [lower, nextGuess].max()
        }
        if (nextGuess >= guess) {
            upper = [upper, nextGuess].min()
        }
    }
}
```

Now, let’s write our factory code:

```groovy
def guessFactory = [messages: GuessGameMessages, control: GuessGameControl, converter: GuessGameInputConverter]
def twoupFactory = [messages: TwoupMessages, control: TwoupControl, converter: TwoupInputConverter]

class GameFactory {
    def static factory
    def static getMessages() { return factory.messages.newInstance() }
    def static getControl() { return factory.control.newInstance() }
    def static getConverter() { return factory.converter.newInstance() }
}
```

The important aspect of this factory is that it allows selection of an entire family of concrete classes.

Here is how we would use the factory:

```groovy
GameFactory.factory = twoupFactory
def messages = GameFactory.messages
def control = GameFactory.control
def converter = GameFactory.converter
println messages.welcome
def reader = new BufferedReader(new InputStreamReader(System.in))
while (control.moreTurns()) {
    def input = reader.readLine().trim()
    control.play(converter.convert(input))
}
println messages.done
```

Note that the first line configures which family of concrete game classes we will use. It’s not important that we selected which family to use by using the factory property as shown in the first line. Other ways would be equally valid examples of this pattern. For example, we may have asked the user which game they wanted to play or determined which game from an environment setting.

With the code as shown, the game might look like this when run:

```
Welcome to the twoup game, you start with $1000
You have 1000, how much would you like to bet?
300
Draw
You have 1000, how much would you like to bet?
700
You win
You have 1700, how much would you like to bet?
1700
You lose
Sorry, you have no money left, goodbye
```

If we change the first line of the script to GameFactory.factory = guessFactory, then the sample run might look like this:

```
Welcome to the guessing game, my secret number is between 1 and 100
Enter a number between 1 and 100
75
Enter a number between 1 and 75
35
Enter a number between 1 and 35
15
Enter a number between 1 and 15
5
Enter a number between 5 and 15
10
Correct
```

##### Adapter Pattern

The [Adapter Pattern](http://en.wikipedia.org/wiki/Adapter_pattern) (sometimes called the wrapper pattern) allows objects satisfying one interface to be used where another type of interface is expected. There are two typical flavours of the pattern: the *delegation* flavour and the *inheritance* flavour.

###### Delegation Example

Suppose we have the following classes:

```groovy
class SquarePeg {
    def width
}

class RoundPeg {
    def radius
}

class RoundHole {
    def radius
    def pegFits(peg) {
        peg.radius <= radius
    }
    String toString() { "RoundHole with radius $radius" }
}
```

We can ask the `RoundHole` class if a `RoundPeg` fits in it, but if we ask the same question for a `SquarePeg`, then it will fail because the `SquarePeg` class doesn’t have a `radius` property (i.e. doesn’t satisfy the required interface).

To get around this problem, we can create an adapter to make it appear to have the correct interface. It would look like this:

```groovy
class SquarePegAdapter {
    def peg
    def getRadius() {
        Math.sqrt(((peg.width / 2) ** 2) * 2)
    }
    String toString() {
        "SquarePegAdapter with peg width $peg.width (and notional radius $radius)"
    }
}
```

We can use the adapter like this:

```groovy
def hole = new RoundHole(radius: 4.0)
(4..7).each { w ->
    def peg = new SquarePegAdapter(peg: new SquarePeg(width: w))
    if (hole.pegFits(peg)) {
        println "peg $peg fits in hole $hole"
    } else {
        println "peg $peg does not fit in hole $hole"
    }
}
```

Which results in the following output:

```
peg SquarePegAdapter with peg width 4 (and notional radius 2.8284271247461903) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 5 (and notional radius 3.5355339059327378) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 6 (and notional radius 4.242640687119285) does not fit in hole RoundHole with radius 4.0
peg SquarePegAdapter with peg width 7 (and notional radius 4.949747468305833) does not fit in hole RoundHole with radius 4.0
```

###### Inheritance Example

Let’s consider the same example again using inheritance. First, here are the original classes (unchanged):

```groovy
class SquarePeg {
    def width
}

class RoundPeg {
    def radius
}

class RoundHole {
    def radius
    def pegFits(peg) {
        peg.radius <= radius
    }
    String toString() { "RoundHole with radius $radius" }
}
```

An adapter using inheritance:

```groovy
class SquarePegAdapter extends SquarePeg {
    def getRadius() {
        Math.sqrt(((width / 2) ** 2) * 2)
    }
    String toString() {
        "SquarePegAdapter with width $width (and notional radius $radius)"
    }
}
```

Using the adapter:

```groovy
def hole = new RoundHole(radius: 4.0)
(4..7).each { w ->
    def peg = new SquarePegAdapter(width: w)
    if (hole.pegFits(peg)) {
        println "peg $peg fits in hole $hole"
    } else {
        println "peg $peg does not fit in hole $hole"
    }
}
```

The output:

```
peg SquarePegAdapter with width 4 (and notional radius 2.8284271247461903) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 5 (and notional radius 3.5355339059327378) fits in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 6 (and notional radius 4.242640687119285) does not fit in hole RoundHole with radius 4.0
peg SquarePegAdapter with width 7 (and notional radius 4.949747468305833) does not fit in hole RoundHole with radius 4.0
```

###### Adapting using Closures

As a variation of the previous examples, we could instead define the following interface:

```groovy
interface RoundThing {
    def getRadius()
}
```

We can then define an adapter as a closure as follows:

```groovy
def adapter = {
    p -> [getRadius: { Math.sqrt(((p.width / 2) ** 2) * 2) }] as RoundThing
}
```

And use it like this:

```groovy
def peg = new SquarePeg(width: 4)
if (hole.pegFits(adapter(peg))) {
    // ... as before
}
```

###### Adapting using the ExpandoMetaClass

As of Groovy 1.1, there is a built-in MetaClass which can automatically add properties and methods dynamically.

Here is how the example would work using that feature:

```groovy
def peg = new SquarePeg(width: 4)
peg.metaClass.radius = Math.sqrt(((peg.width / 2) ** 2) * 2)
```

After you create a peg object, you can simply add a property to it on the fly. No need to change the original class and no need for an adapter class.

##### Bouncer Pattern

The [Bouncer Pattern](http://www.c2.com/cgi/wiki?BouncerPattern) describes usage of a method whose sole purpose is to either throw an exception (when particular conditions hold) or do nothing. Such methods are often used to defensively guard pre-conditions of a method.

When writing utility methods, you should always guard against faulty input arguments. When writing internal methods, you may be able to ensure that certain pre-conditions always hold by having sufficient unit tests in place. Under such circumstances, you may reduce the desirability to have guards on your methods.

Groovy differs from other languages in that you frequently use the `assert` method within your methods rather than having a large number of utility checker methods or classes.

###### Null Checking Example

We might have a utility method such as:

```groovy
class NullChecker {
    static check(name, arg) {
        if (arg == null) {
            throw new IllegalArgumentException(name + ' is null')
        }
    }
}
```

And we would use it like this:

```groovy
void doStuff(String name, Object value) {
    NullChecker.check('name', name)
    NullChecker.check('value', value)
    // do stuff
}
```

But a more Groovy way to do this would simply be like this:

```groovy
void doStuff(String name, Object value) {
    assert name != null, 'name should not be null'
    assert value != null, 'value should not be null'
    // do stuff
}
```

###### Validation Example

As an alternative example, we might have this utility method:

```groovy
class NumberChecker {
    static final String NUMBER_PATTERN = "\\\\d+(\\\\.\\\\d+(E-?\\\\d+)?)?"
    static isNumber(str) {
        if (!str ==~ NUMBER_PATTERN) {
            throw new IllegalArgumentException("Argument '$str' must be a number")
        }
    }
    static isNotZero(number) {
        if (number == 0) {
            throw new IllegalArgumentException('Argument must not be 0')
        }
    }
}
```

And we would use it like this:

```groovy
def stringDivide(String dividendStr, String divisorStr) {
    NumberChecker.isNumber(dividendStr)
    NumberChecker.isNumber(divisorStr)
    def dividend = dividendStr.toDouble()
    def divisor = divisorStr.toDouble()
    NumberChecker.isNotZero(divisor)
    dividend / divisor
}

println stringDivide('1.2E2', '3.0')
// => 40.0
```

But with Groovy we could just as easily use:

```groovy
def stringDivide(String dividendStr, String divisorStr) {
    assert dividendStr =~ NumberChecker.NUMBER_PATTERN
    assert divisorStr =~ NumberChecker.NUMBER_PATTERN
    def dividend = dividendStr.toDouble()
    def divisor = divisorStr.toDouble()
    assert divisor != 0, 'Divisor must not be 0'
    dividend / divisor
}
```

##### Chain of Responsibility Pattern

In the Chain of Responsibility Pattern, objects using and implementing an interface (one or more methods) are intentionally loosely coupled. A set of objects that *implement* the interface are organised in a list (or in rare cases a tree). Objects using the interface make requests from the first *implementor* object. It will decide whether to perform any action itself and whether to pass the request further down the line in the list (or tree). Sometimes a default implementation for some request is also coded into the pattern if none of the implementors respond to the request.

###### Example

In this example, the script sends requests to the `lister` object. The `lister` points to a `UnixLister` object. If it can’t handle the request, it sends the request to the `WindowsLister`. If it can’t handle the request, it sends the request to the `DefaultLister`.

```groovy
class UnixLister {
    private nextInLine
    UnixLister(next) { nextInLine = next }
    def listFiles(dir) {
        if (System.getProperty('os.name') == 'Linux') {
            println "ls $dir".execute().text
        } else {
            nextInLine.listFiles(dir)
        }
    }
}

class WindowsLister {
    private nextInLine
    WindowsLister(next) { nextInLine = next }
    def listFiles(dir) {
        if (System.getProperty('os.name') == 'Windows XP') {
            println "cmd.exe /c dir $dir".execute().text
        } else {
            nextInLine.listFiles(dir)
        }
    }
}

class DefaultLister {
    def listFiles(dir) {
        new File(dir).eachFile { f -> println f }
    }
}

def lister = new UnixLister(new WindowsLister(new DefaultLister()))

lister.listFiles('Downloads')
```

The output will be a list of files (with slightly different format depending on the operating system).

Here is a UML representation:

![ChainOfResponsibilityClasses](https://docs.groovy-lang.org/latest/html/documentation/assets/img/ChainOfResponsibilityClasses.gif)

Variations to this pattern:

- we could have an explicit interface, e.g. `Lister`, to statically type the implementations but because of *duck-typing* this is optional
- we could use a chain tree instead of a list, e.g. `if (animal.hasBackbone())` delegate to `VertebrateHandler` else delegate to `InvertebrateHandler`
- we could always pass down the chain even if we processed a request
- we could decide at some point to not respond and not pass down the chain
- we could use Groovy’s meta-programming capabilities to pass unknown methods down the chain

##### Composite Pattern

The [Composite Pattern](http://en.wikipedia.org/wiki/Composite_pattern) allows you to treat single instances of an object the same way as a group of objects. The pattern is often used with hierarchies of objects. Typically, one or more methods should be callable in the same way for either *leaf* or *composite* nodes within the hierarchy. In such a case, composite nodes typically invoke the same named method for each of their children nodes.

###### Example

Consider this usage of the composite pattern where we want to call `toString()` on either `Leaf` or `Composite` objects.

![CompositeClasses](https://docs.groovy-lang.org/latest/html/documentation/assets/img/CompositeClasses.gif)

In Java, the `Component` class is essential as it provides the type used for both leaf and composite nodes. In Groovy, because of duck-typing, we don’t need it for that purpose, however, it can still serve as a useful place to place common behaviour between the leaf and composite nodes.

For our purposes, we will assemble the following hierarchy of components.

![CompositeComponents](https://docs.groovy-lang.org/latest/html/documentation/assets/img/CompositeComponents.gif)

Here is the code:

```groovy
abstract class Component {
    def name
    def toString(indent) {
        ("-" * indent) + name
    }
}

class Composite extends Component {
    private children = []
    def toString(indent) {
        def s = super.toString(indent)
        children.each { child ->
            s += "\\n" + child.toString(indent + 1)
        }
        s
    }
    def leftShift(component) {
        children << component
    }
}

class Leaf extends Component { }

def root = new Composite(name: "root")
root << new Leaf(name: "leaf A")
def comp = new Composite(name: "comp B")
root << comp
root << new Leaf(name: "leaf C")
comp << new Leaf(name: "leaf B1")
comp << new Leaf(name: "leaf B2")
println root.toString(0)
```

Here is the resulting output:

```
root
-leaf A
-comp B
--leaf B1
--leaf B2
-leaf C
```

##### Decorator Pattern

The [Decorator Pattern](http://en.wikipedia.org/wiki/Decorator_pattern) provides a mechanism to embellish the behaviour of an object without changing its essential interface. A decorated object should be able to be substituted wherever the original (non-decorated) object was expected. Decoration typically does not involve modifying the source code of the original object and decorators should be able to be combined in flexible ways to produce objects with several embellishments.

###### Traditional Example

Suppose we have the following `Logger` class.

```groovy
class Logger {
    def log(String message) {
        println message
    }
}
```

There might be times when it is useful to timestamp a log message, or times when we might want to change the case of the message. We could try to build all of this functionality into our `Logger` class. If we did that, the `Logger` class would start to be very complex. Also, everyone would obtain all of features even when they might not want a small subset of the features. Finally, feature interaction would become quite difficult to control.

To overcome these drawbacks, we instead define two decorator classes. Uses of the `Logger` class are free to embellish their base logger with zero or more decorator classes in whatever order they desire. The classes look like this:

```groovy
class TimeStampingLogger extends Logger {
    private Logger logger
    TimeStampingLogger(logger) {
        this.logger = logger
    }
    def log(String message) {
        def now = Calendar.instance
        logger.log("$now.time: $message")
    }
}

class UpperLogger extends Logger {
    private Logger logger
    UpperLogger(logger) {
        this.logger = logger
    }
    def log(String message) {
        logger.log(message.toUpperCase())
    }
}
```

We can use the decorators like so:

```groovy
def logger = new UpperLogger(new TimeStampingLogger(new Logger()))
logger.log("G'day Mate")
// => Tue May 22 07:13:50 EST 2007: G'DAY MATE
```

You can see that we embellish the logger behaviour with both decorators. Because of the order we chose to apply the decorators, our log message comes out capitalised and the timestamp is in normal case. If we swap the order around, let’s see what happens:

```groovy
logger = new TimeStampingLogger(new UpperLogger(new Logger()))
logger.log('Hi There')
// => TUE MAY 22 07:13:50 EST 2007: HI THERE
```

Now the timestamp itself has also been changed to be uppercase.

###### A touch of dynamic behaviour

Our previous decorators were specific to `Logger` objects. We can use Groovy’s Meta-Object Programming capabilities to create a decorator which is far more general purpose in nature. Consider this class:

```groovy
class GenericLowerDecorator {
    private delegate
    GenericLowerDecorator(delegate) {
        this.delegate = delegate
    }
    def invokeMethod(String name, args) {
        def newargs = args.collect { arg ->
            if (arg instanceof String) {
                return arg.toLowerCase()
            } else {
                return arg
            }
        }
        delegate.invokeMethod(name, newargs)
    }
}
```

It takes any class and decorates it so that any `String` method parameter will automatically be changed to lower case.

```groovy
logger = new GenericLowerDecorator(new TimeStampingLogger(new Logger()))
logger.log('IMPORTANT Message')
// => Tue May 22 07:27:18 EST 2007: important message
```

Just be careful with ordering here. The original decorators were restricted to decorating `Logger` objects. This decorator works with any object type, so we can’t swap the ordering around, i.e. this won’t work:

```
// Can't mix and match Interface-Oriented and Generic decorators
// logger = new TimeStampingLogger(new GenericLowerDecorator(new Logger()))
```

We could overcome this limitation be generating an appropriate Proxy type at runtime but we won’t complicate the example here.

###### Runtime behaviour embellishment

You can also consider using the `ExpandoMetaClass` from Groovy 1.1 to dynamically embellish a class with behaviour. This isn’t the normal style of usage of the decorator pattern (it certainly isn’t nearly as flexible) but may help you to achieve similar results in some cases without creating a new class.

Here’s what the code looks like:

```groovy
// current mechanism to enable ExpandoMetaClass
GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()

def logger = new Logger()
logger.metaClass.log = { String m -> println 'message: ' + m.toUpperCase() }
logger.log('x')
// => message: X
```

This achieves a similar result to applying a single decorator but we have no way to easily apply and remove embellishments on the fly.

###### More dynamic decorating

Suppose we have a calculator class (Actually any class would do).

```groovy
class Calc {
    def add(a, b) { a + b }
}
```

We might be interested in observing usage of the class over time. If it is buried deep within our codebase, it might be hard to determine when it is being called and with what parameters. Also, it might be hard to know if it is performing well. We can easily make a generic tracing decorator that prints out tracing information whenever any method on the `Calc` class is called and also provide timing information about how long it took to execute. Here is the code for the tracing decorator:

```groovy
class TracingDecorator {
    private delegate
    TracingDecorator(delegate) {
        this.delegate = delegate
    }
    def invokeMethod(String name, args) {
        println "Calling $name$args"
        def before = System.currentTimeMillis()
        def result = delegate.invokeMethod(name, args)
        println "Got $result in ${System.currentTimeMillis()-before} ms"
        result
    }
}
```

Here is how to use the class in a script:

```groovy
def tracedCalc = new TracingDecorator(new Calc())
assert 15 == tracedCalc.add(3, 12)
```

And here is what you would see after running this script:

```
Calling add{3, 12}
Got 15 in 31 ms
```

###### Decorating with an Interceptor

The above timing example hooks into the lifecycle of Groovy objects (via `invokeMethod`). This is such an important style performing meta-programming that Groovy has special support for this style of decorating using *interceptors*.

Groovy even comes with a built-in `TracingInterceptor`. We can extend the built-in class like this:

```groovy
class TimingInterceptor extends TracingInterceptor {
    private beforeTime
    def beforeInvoke(object, String methodName, Object[] arguments) {
        super.beforeInvoke(object, methodName, arguments)
        beforeTime = System.currentTimeMillis()
    }
    Object afterInvoke(Object object, String methodName, Object[] arguments, Object result) {
        super.afterInvoke(object, methodName, arguments, result)
        def duration = System.currentTimeMillis() - beforeTime
        writer.write("Duration: $duration ms\\n")
        writer.flush()
        result
    }
}
```

Here is an example of using this new class:

```groovy
def proxy = ProxyMetaClass.getInstance(Calc)
proxy.interceptor = new TimingInterceptor()
proxy.use {
    assert 7 == new Calc().add(1, 6)
}
```

And here is the output:

```
before Calc.ctor()
after  Calc.ctor()
Duration: 0 ms
before Calc.add(java.lang.Integer, java.lang.Integer)
after  Calc.add(java.lang.Integer, java.lang.Integer)
Duration: 2 ms
```

###### Decorating with java.lang.reflect.Proxy

If you are trying to decorate an object (i.e. just a particular instance of the class, not the class generally), then you can use Java’s `java.lang.reflect.Proxy`. Groovy makes working with this easier than just Java. Below is a code sample taken out of a grails project that wraps a `java.sql.Connection` so that it’s close method is a no-op:

```groovy
protected Sql getGroovySql() {
    final Connection con = session.connection()
    def invoker = { object, method, args ->
        if (method.name == "close") {
            log.debug("ignoring call to Connection.close() for use by groovy.sql.Sql")
        } else {
            log.trace("delegating $method")
            return con.invokeMethod(method.name, args)
        }
    } as InvocationHandler;
    def proxy = Proxy.newProxyInstance( getClass().getClassLoader(), [Connection] as Class[], invoker )
    return new Sql(proxy)
}
```

If there were many methods to intercept, then this approach could be modified to look up closure in a map by method name and invoke it.

###### Decorating with Spring

The [Spring Framework](http://www.springframework.org/) allows decorators to be applied with *interceptors* (you may have heard the terms *advice* or *aspect*). You can leverage this mechanism from Groovy as well.

First define a class that you want to decorate (we’ll also use an interface as is normal Spring practice):

Here’s the interface:

```groovy
interface Calc {
    def add(a, b)
}
```

Here’s the class:

```groovy
class CalcImpl implements Calc {
    def add(a, b) { a + b }
}
```

Now, we define our wiring in a file called `beans.xml` as follows:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:lang="http://www.springframework.org/schema/lang"
	xsi:schemaLocation="
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd">

    <bean id="performanceInterceptor" autowire="no"
          class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor">
        <property name="loggerName" value="performance"/>
    </bean>
    <bean id="calc" class="util.CalcImpl"/>
    <bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
        <property name="beanNames" value="calc"/>
        <property name="interceptorNames" value="performanceInterceptor"/>
    </bean>
</beans>
```

Now, our script looks like this:

```groovy
@Grab('org.springframework:spring-context:3.2.2.RELEASE')
import org.springframework.context.support.ClassPathXmlApplicationContext

def ctx = new ClassPathXmlApplicationContext('beans.xml')
def calc = ctx.getBean('calc')
println calc.add(3, 25)
```

And when we run it, we see the results:

```
21/05/2007 23:02:35 org.springframework.aop.interceptor.PerformanceMonitorInterceptor invokeUnderTrace
FINEST: StopWatch 'util.Calc.add': running time (millis) = 16
```

You may have to adjust your `logging.properties` file for messages at log level `FINEST` to be displayed.

###### Asynchronous Decorators using GPars

The following example is inspired by some of the early example code for the [Panini](http://design.cs.iastate.edu/~panini/) programming language. These days, you’ll see this style used with async functions in JavaScript.

```groovy
@Grab('org.codehaus.gpars:gpars:0.10')
import static groovyx.gpars.GParsPool.withPool

interface Document {
    void print()
    String getText()
}

class DocumentImpl implements Document {
    def document
    void print() { println document }
    String getText() { document }
}

def words(String text) {
    text.replaceAll('[^a-zA-Z]', ' ').trim().split("\\\\s+")*.toLowerCase()
}

def avgWordLength = {
    def words = words(it.text)
    sprintf "Avg Word Length: %4.2f", words*.size().sum() / words.size()
}
def modeWord = {
    def wordGroups = words(it.text).groupBy {it}.collectEntries { k, v -> [k, v.size()] }
    def maxSize = wordGroups*.value.max()
    def maxWords = wordGroups.findAll { it.value == maxSize }
    "Mode Word(s): ${maxWords*.key.join(', ')} ($maxSize occurrences)"
}
def wordCount = { d -> "Word Count: " + words(d.text).size() }

def asyncDecorator(Document d, Closure c) {
    ProxyGenerator.INSTANCE.instantiateDelegate([print: {
        withPool {
            def result = c.callAsync(d)
            d.print()
            println result.get()
        }
    }], [Document], d)
}

Document d = asyncDecorator(asyncDecorator(asyncDecorator(
        new DocumentImpl(document:"This is the file with the words in it\\n\\t\\nDo you see the words?\\n"),
//        new DocumentImpl(document: new File('AsyncDecorator.groovy').text),
        wordCount), modeWord), avgWordLength)
d.print()
```

##### Delegation Pattern

The [Delegation Pattern](http://en.wikipedia.org/wiki/Delegation_pattern) is a technique where an object’s behavior (public methods) is implemented by delegating responsibility to one or more associated objects.

Groovy allows the traditional style of applying the delegation pattern, e.g. see [Replace Inheritance with Delegation](https://docs.groovy-lang.org/latest/html/documentation/#_replace_inheritance_with_delegation).

###### Implement Delegation Pattern using ExpandoMetaClass

The [groovy.lang.ExpandoMetaClass](https://docs.groovy-lang.org/3.0.3/html/gapi/index.html?groovy/lang/ExpandoMetaClass.html) allows usage of this pattern to be encapsulated in a library. This allows Groovy to emulate similar libraries available for the Ruby language.

Consider the following library class:

```groovy
class Delegator {
    private targetClass
    private delegate
    Delegator(targetClass, delegate) {
        this.targetClass = targetClass
        this.delegate = delegate
    }
    def delegate(String methodName) {
        delegate(methodName, methodName)
    }
    def delegate(String methodName, String asMethodName) {
        targetClass.metaClass."$asMethodName" = delegate.&"$methodName"
    }
    def delegateAll(String[] names) {
        names.each { delegate(it) }
    }
    def delegateAll(Map names) {
        names.each { k, v -> delegate(k, v) }
    }
    def delegateAll() {
        delegate.class.methods*.name.each { delegate(it) }
    }
}
```

With this in your classpath, you can now apply the delegation pattern dynamically as shown in the following examples. First, consider we have the following classes:

```groovy
class Person {
    String name
}

class MortgageLender {
    def borrowAmount(amount) {
       "borrow \\$$amount"
    }
    def borrowFor(thing) {
       "buy \\$thing"
    }
}

def lender = new MortgageLender()

def delegator = new Delegator(Person, lender)
```

We can now use the *delegator* to automatically borrow methods from the *lender* object to extend the *Person* class. We can borrow the methods as is or with a rename:

```groovy
delegator.delegate 'borrowFor'
delegator.delegate 'borrowAmount', 'getMoney'

def p = new Person()

println p.borrowFor('present')   // => buy present
println p.getMoney(50)
```

The first line above, adds the *borrowFor* method to the *Person* class by delegating to the *lender* object. The second line adds a *getMoney* method to the *Person* class by delegating to the *lender* object’s *borrowAmount* method.

Alternatively, we could borrow multiple methods like this:

```groovy
delegator.delegateAll 'borrowFor', 'borrowAmount'
```

Which adds these two methods to the *Person* class.

Or if we want all the methods, like this:

```groovy
delegator.delegateAll()
```

Which will make all the methods in the delegate object available in the *Person* class.

Alternatively, we can use a map notation to rename multiple methods:

```groovy
delegator.delegateAll borrowAmount:'getMoney', borrowFor:'getThing'
```

###### Implement Delegation Pattern using @Delegate annotation

Since version 1.6 you can use the built-in delegation mechanism which is based on AST transformation.

This make delegation even easier:

```groovy
class Person {
    def name
    @Delegate MortgageLender mortgageLender = new MortgageLender()
}

class MortgageLender {
    def borrowAmount(amount) {
       "borrow \\$$amount"
    }
    def borrowFor(thing) {
       "buy $thing"
    }
}

def p = new Person()

assert "buy present" == p.borrowFor('present')
assert "borrow \\$50" == p.borrowAmount(50)
```

##### Flyweight Pattern

The [Flyweight Pattern](http://en.wikipedia.org/wiki/Flyweight_pattern) is a pattern for greatly reducing memory requirements by not requiring that heavy-weight objects be created in large numbers when dealing with systems that contain many things that are mostly the same. If for instance, a document was modelled using a complex character class that knew about unicode, fonts, positioning, etc., then the memory requirements could be quite large for large documents if each physical character in the document required its own character class instance. Instead, characters themselves might be kept within Strings and we might have one character class (or a small number such as one character class for each font type) that knew the specifics of how to deal with characters.

In such circumstances, we call the state that is shared with many other things (e.g. the character type) *instrinsic* state. It is captured within the heavy-weight class. The state which distinguishes the physical character (maybe just its ASCII code or Unicode) is called its *extrinsic* state.

###### Example

First we are going to model some complex aircraft (the first being a hoax competitor of the second - not that is relevant to the example).

```groovy
class Boeing797 {
    def wingspan = '80.8 m'
    def capacity = 1000
    def speed = '1046 km/h'
    def range = '14400 km'
    // ...
}
```

![b797 hoax](https://docs.groovy-lang.org/latest/html/documentation/assets/img/b797-hoax.jpg)

```groovy
class Airbus380 {
    def wingspan = '79.8 m'
    def capacity = 555
    def speed = '912 km/h'
    def range = '10370 km'
    // ...
}
```

![a380](https://docs.groovy-lang.org/latest/html/documentation/assets/img/a380.jpg)

If we want to model our fleet, our first attempt might involve using many instances of these heavy-weight objects. It turns out though that only a few small pieces of state (our extrinsic state) change for each aircraft, so we will have singletons for the heavy-weight objects and capture the extrinsic state (bought date and asset number in the code below) separately.

```groovy
class FlyweightFactory {
    static instances = [797: new Boeing797(), 380: new Airbus380()]
}

class Aircraft {
    private type         // instrinsic state
    private assetNumber  // extrinsic state
    private bought       // extrinsic state
    Aircraft(typeCode, assetNumber, bought) {
        type = FlyweightFactory.instances[typeCode]
        this.assetNumber = assetNumber
        this.bought = bought
    }
    def describe() {
        println """
        Asset Number: $assetNumber
        Capacity: $type.capacity people
        Speed: $type.speed
        Range: $type.range
        Bought: $bought
        """
    }
}

def fleet = [
    new Aircraft(380, 1001, '10-May-2007'),
    new Aircraft(380, 1002, '10-Nov-2007'),
    new Aircraft(797, 1003, '10-May-2008'),
    new Aircraft(797, 1004, '10-Nov-2008')
]

fleet.each { p -> p.describe() }
```

So here, even if our fleet contained hundreds of planes, we would only have one heavy-weight object for each type of aircraft.

As a further efficiency measure, we might use lazy creation of the flyweight objects rather than create the initial map up front as in the above example.

Running this script results in:

```
Asset Number: 1001
Capacity: 555 people
Speed: 912 km/h
Range: 10370 km
Bought: 10-May-2007

Asset Number: 1002
Capacity: 555 people
Speed: 912 km/h
Range: 10370 km
Bought: 10-Nov-2007

Asset Number: 1003
Capacity: 1000 people
Speed: 1046 km/h
Range: 14400 km
Bought: 10-May-2008

Asset Number: 1004
Capacity: 1000 people
Speed: 1046 km/h
Range: 14400 km
Bought: 10-Nov-2008
```

##### Iterator Pattern

The [Iterator Pattern](http://en.wikipedia.org/wiki/Iterator_pattern) allows sequential access to the elements of an aggregate object without exposing its underlying representation.

Groovy has the iterator pattern built right in to many of its closure operators, e.g. `each` and `eachWithIndex` as well as the `for .. in` loop.

For example:

```groovy
def printAll(container) {
    for (item in container) { println item }
}

def numbers = [ 1,2,3,4 ]
def months = [ Mar:31, Apr:30, May:31 ]
def colors = [ java.awt.Color.BLACK, java.awt.Color.WHITE ]
printAll numbers
printAll months
printAll colors
```

Results in the output:

```
1
2
3
4
May=31
Mar=31
Apr=30
java.awt.Color[r=0,g=0,b=0]
java.awt.Color[r=255,g=255,b=255]
```

Another example:

```groovy
colors.eachWithIndex { item, pos ->
    println "Position $pos contains '$item'"
}
```

Results in:

```
Position 0 contains 'java.awt.Color[r=0,g=0,b=0]'
Position 1 contains 'java.awt.Color[r=255,g=255,b=255]'
```

The iterator pattern is also built in to other special operators such as the `eachByte`, `eachFile`, `eachDir`, `eachLine`, `eachObject`, `eachMatch` operators for working with streams, URLs, files, directories and regular expressions matches.

##### Loan my Resource Pattern

The [Loan my Resource](https://wiki.scala-lang.org/display/SYGN/Loan) pattern ensures that a resource is deterministically disposed of once it goes out of scope.

This pattern is built in to many Groovy helper methods. You should consider using it yourself if you need to work with resources in ways beyond what Groovy supports.

###### Example

Consider the following code which works with a file. First we might write some line to the file and then print its size:

```groovy
def f = new File('junk.txt')
f.withPrintWriter { pw ->
    pw.println(new Date())
    pw.println(this.class.name)
}
println f.size()
// => 42
```

We could also read back the contents of the file a line at a time and print each line out:

```groovy
f.eachLine { line ->
    println line
}
// =>
// Mon Jun 18 22:38:17 EST 2007
// RunPattern
```

Note that normal Java `Reader` and `PrintWriter` objects were used under the covers by Groovy but the code writer did not have to worry about explicitly creating or closing those resources. The built-in Groovy methods loan the respective reader or writer to the closure code and then tidy up after themselves. So, you are using this pattern without having to do any work.

Sometimes however, you wish to do things slightly differently to what you can get for free using Groovy’s built-in mechanisms. You should consider utilising this pattern within your own resource-handling operations.

Consider how you might process the list of words on each line within the file. We could actually do this one too using Groovy’s built-in functions, but bear with us and assume we have to do some resource handling ourselves. Here is how we might write the code without using this pattern:

```groovy
def reader = f.newReader()
reader.splitEachLine(' ') { wordList ->
    println wordList
}
reader.close()
// =>
// [ "Mon", "Jun", "18", "22:38:17", "EST", "2007" ]
// [ "RunPattern" ]
```

Notice that we now have an explicit call to `close()` in our code. If we didn’t code it just right (here we didn’t surround the code in a `try … finally` block, we run the risk of leaving the file handle open.

Let’s now apply the loan pattern. First, we’ll write a helper method:

```groovy
def withListOfWordsForEachLine(File f, Closure c) {
    def r = f.newReader()
    try {
        r.splitEachLine(' ', c)
    } finally {
        r?.close()
    }
}
```

Now, we can re-write our code as follows:

```groovy
withListOfWordsForEachLine(f) { wordList ->
    println wordList
}
// =>
// [ "Mon", "Jun", "18", "22:38:17", "EST", "2007" ]
// [ "RunPattern" ]
```

This is much simpler and has removed the explicit `close()`. This is now catered for in one spot so we can apply the appropriate level of testing or reviewing in just one spot to be sure we have no problems.

##### Null Object Pattern

The [Null Object Pattern](http://en.wikipedia.org/wiki/Null_Object_pattern) involves using a special object place-marker object representing null. Typically, if you have a reference to null, you can’t invoke `reference.field` or `reference.method()` You receive the dreaded `NullPointerException`. The null object pattern uses a special object representing null, instead of using an actual `null`. This allows you to invoke field and method references on the null object. The result of using the null object should semantically be equivalent to *doing nothing*.

###### Simple Example

Suppose we have the following system:

```groovy
class Job {
    def salary
}

class Person {
    def name
    def Job job
}

def people = [
    new Person(name: 'Tom', job: new Job(salary: 1000)),
    new Person(name: 'Dick', job: new Job(salary: 1200)),
]

def biggestSalary = people.collect { p -> p.job.salary }.max()
println biggestSalary
```

When run, this prints out `1200`. Suppose now that we now invoke:

```groovy
people << new Person(name: 'Harry')
```

If we now try to calculate `biggestSalary` again, we receive a null pointer exception.

To overcome this problem, we can introduce a `NullJob` class and change the above statement to become:

```groovy
class NullJob extends Job { def salary = 0 }

people << new Person(name: 'Harry', job: new NullJob())
biggestSalary = people.collect { p -> p.job.salary }.max()
println biggestSalary
```

This works as we require but it’s not always the best way to do this with Groovy. Groovy’s safe-dereference operator (`?.`) operator and null aware closures often allow Groovy to avoid the need to create a special null object or null class. This is illustrated by examining a groovier way to write the above example:

```groovy
people << new Person(name:'Harry')
biggestSalary = people.collect { p -> p.job?.salary }.max()
println biggestSalary
```

Two things are going on here to allow this to work. First of all, `max()` is *'null aware'* so that [300, null, 400].max() == 400. Secondly, with the `?.` operator, an expression like `p?.job?.salary` will be equal to null if `salary` is equal to null, or if `job` is equal ` null or if `p` is equal to null. You don’t need to code a complex nested if ... then ... else to avoid a `NullPointerException`.

###### Tree Example

Consider the following example where we want to calculate size, cumulative sum and cumulative product of all the values in a tree structure.

Our first attempt has special logic within the calculation methods to handle null values.

```groovy
class NullHandlingTree {
    def left, right, value

    def size() {
        1 + (left ? left.size() : 0) + (right ? right.size() : 0)
    }

    def sum() {
       value + (left ? left.sum() : 0) + (right ? right.sum() : 0)
    }

    def product() {
       value * (left ? left.product() : 1) * (right ? right.product() : 1)
    }
}

def root = new NullHandlingTree(
    value: 2,
    left: new NullHandlingTree(
        value: 3,
        right: new NullHandlingTree(value: 4),
        left: new NullHandlingTree(value: 5)
    )
)

println root.size()
println root.sum()
println root.product()
```

If we introduce the null object pattern (here by defining the `NullTree` class), we can now simplify the logic in the `size()`, `sum()` and`product()` methods. These methods now much more clearly represent the logic for the normal (and now universal) case. Each of the methods within `NullTree` returns a value which represents doing nothing.

```groovy
class Tree {
    def left = new NullTree(), right = new NullTree(), value

    def size() {
        1 + left.size() + right.size()
    }

    def sum() {
       value + left.sum() + right.sum()
    }

    def product() {
       value * left.product() * right.product()
    }
}

class NullTree {
    def size() { 0 }
    def sum() { 0 }
    def product() { 1 }
}

def root = new Tree(
    value: 2,
    left: new Tree(
        value: 3,
        right: new Tree(value: 4),
        left: new Tree(value: 5)
    )
)

println root.size()
println root.sum()
println root.product()
```

The result of running either of these examples is:

```
4
14
120
```

Note: a slight variation with the null object pattern is to combine it with the singleton pattern. So, we wouldn’t write new NullTree() wherever we needed a null object as shown above. Instead we would have a single null object instance which we would place within our data structures as needed.

##### Pimp my Library Pattern

The [Pimp my Library](http://www.artima.com/weblogs/viewpost.jsp?thread=179766) Pattern suggests an approach for extending a library that nearly does everything that you need but just needs a little more. It assumes that you do not have source code for the library of interest.

###### Example

Suppose we want to make use of the built-in Integer facilities in Groovy (which build upon the features already in Java). Those libraries have nearly all of the features we want but not quite everything. We may not have all of the source code to the Groovy and Java libraries so we can’t just change the library. Instead we augment the library. Groovy has a number of ways to do this. One way is to use a Category.

First, we’ll define a suitable category.

```groovy
class EnhancedInteger {
    static boolean greaterThanAll(Integer self, Object[] others) {
        greaterThanAll(self, others)
    }
    static boolean greaterThanAll(Integer self, others) {
        others.every { self > it }
    }
}
```

We have added two methods which augment the Integer methods by providing the `greaterThanAll` method. Categories follow conventions where they are defined as static methods with a special first parameter representing the class we wish to extend. The greaterThanAll(Integer self, others) static method becomes the `greaterThanAll(other)` instance method.

We defined two versions of `greaterThanAll`. One which works for collections, ranges etc. The other which works with a variable number of `Integer` arguments.

Here is how you would use the category.

```groovy
use(EnhancedInteger) {
    assert 4.greaterThanAll(1, 2, 3)
    assert !5.greaterThanAll(2, 4, 6)
    assert 5.greaterThanAll(-4..4)
    assert 5.greaterThanAll([])
    assert !5.greaterThanAll([4, 5])
}
```

As you can see, using this technique you can effectively enrich an original class without having access to its source code. Moreover, you can apply different enrichments in different parts of the system as well as work with un-enriched objects if we need to.

##### Proxy Pattern

The [Proxy Pattern](http://en.wikipedia.org/wiki/Proxy_pattern) allows one object to act as a pretend replacement for some other object. In general, whoever is using the proxy, doesn’t realise that they are not using the real thing. The pattern is useful when the real object is hard to create or use: it may exist over a network connection, or be a large object in memory, or be a file, database or some other resource that is expensive or impossible to duplicate.

###### Example

One common use of the proxy pattern is when talking to remote objects in a different JVM. Here is the client code for creating a proxy that talks via sockets to a server object as well as an example usage:

```groovy
class AccumulatorProxy {
    def accumulate(args) {
        def result
        def s = new Socket("localhost", 54321)
        s.withObjectStreams { ois, oos ->
            oos << args
            result = ois.readObject()
        }
        s.close()
        return result
    }
}

println new AccumulatorProxy().accumulate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
// => 55
```

Here is what your server code might look like (start this first):

```groovy
class Accumulator {
    def accumulate(args) {
        args.inject(0) { total, arg -> total += arg }
    }
}

def port = 54321
def accumulator = new Accumulator()
def server = new ServerSocket(port)
println "Starting server on port $port"
while(true) {
    server.accept() { socket ->
        socket.withObjectStreams { ois, oos ->
            def args = ois.readObject()
            oos << accumulator.accumulate(args)
        }
    }
}
```

##### Singleton Pattern

The [Singleton Pattern](http://en.wikipedia.org/wiki/Singleton_pattern) is used to make sure only one object of a particular class is ever created. This can be useful when when exactly one object is needed to coordinate actions across a system; perhaps for efficiency where creating lots of identical objects would be wasteful, perhaps because a particular algorithm needing a single point of control is required or perhaps when an object is used to interact with a non-shareable resource.

Weaknesses of the Singleton pattern include:

- It can reduce reuse. For instance, there are issues if you want to use inheritance with Singletons. If `SingletonB` extends `SingletonA`, should there be exactly (at most) one instance of each or should the creation of an object from one of the classes prohibit creation from the other. Also, if you decide both classes can have an instance, how do you override the `getInstance()` method which is static?
- It is also hard to test singletons in general because of the static methods but Groovy can support that if required.

###### Example: The Classic Java Singleton

Suppose we wish to create a class for collecting votes. Because getting the right number of votes may be very important, we decide to use the singleton pattern. There will only ever be one `VoteCollector` object, so it makes it easier for us to reason about that objects creation and use.

```groovy
class VoteCollector {
    def votes = 0
    private static final INSTANCE = new VoteCollector()
    static getInstance() { return INSTANCE }
    private VoteCollector() { }
    def display() { println "Collector:${hashCode()}, Votes:$votes" }
}
```

Some points of interest about this code:

- it has a private constructor, so no `VoteCollector` objects can be created in our system (except for the `INSTANCE` we create)
- the `INSTANCE` is also private, so it can’t be changed once set
- we haven’t made the updating of votes thread-safe at this point (it doesn’t add to this example)
- the vote collector instance is not lazily created (if we never reference the class, the instance won’t be created; however, as soon as we reference the class, the instance will be created even if not needed initially)

We can use this singleton class in some script code as follows:

```groovy
def collector = VoteCollector.instance
collector.display()
collector.votes++
collector = null

Thread.start{
    def collector2 = VoteCollector.instance
    collector2.display()
    collector2.votes++
    collector2 = null
}.join()

def collector3 = VoteCollector.instance
collector3.display()
```

Here we used the instance 3 times. The second usage was even in a different thread (but don’t try this in a scenario with a new class loader).

Running this script yields (your hashcode value will vary):

```
Collector:15959960, Votes:0
Collector:15959960, Votes:1
Collector:15959960, Votes:2
```

Variations to this pattern:

- To support lazy-loading and multi-threading, we could just use the `synchronized` keyword with the `getInstance()` method. This has a performance hit but will work.
- We can consider variations involving double-checked locking and the `volatile` keyword, but see the limitations of this approach [here](http://www.ibm.com/developerworks/java/library/j-dcl/index.html).

###### Example: Singleton via MetaProgramming

Groovy’s meta-programming capabilities allow concepts like the singleton pattern to be enacted in a far more fundamental way. This example illustrates a simple way to use Groovy’s meta-programming capabilities to achieve the singleton pattern but not necessarily the most efficient way.

Suppose we want to keep track of the total number of calculations that a calculator performs. One way to do that is to use a singleton for the calculator class and keep a variable in the class with the count.

First we define some base classes. A `Calculator` class which performs calculations and records how many such calculations it performs and a `Client` class which acts as a facade to the calculator.

```groovy
class Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    def calc = new Calculator()
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}
```

Now we can define and register a *MetaClass* which intercepts all attempts to create a `Calculator` object and always provides a pre-created instance instead. We also register this MetaClass with the Groovy system:

```groovy
class CalculatorMetaClass extends MetaClassImpl {
    private static final INSTANCE = new Calculator()
    CalculatorMetaClass() { super(Calculator) }
    def invokeConstructor(Object[] arguments) { return INSTANCE }
}

def registry = GroovySystem.metaClassRegistry
registry.setMetaClass(Calculator, new CalculatorMetaClass())
```

Now we use instances of our `Client` class from within a script. The client class will attempt to create new instances of the calculator but will always get the singleton.

```groovy
def client = new Client()
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = new Client()
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"
```

Here is the result of running this script (your hashcode values may vary):

```
Client: 7306473, Calc: 24230857, Total Calculations: 1
Client: 31436753, Calc: 24230857, Total Calculations: 2
```

###### Guice Example

We can also implement the Singleton Pattern using [Guice](https://github.com/google/guice).

Consider the Calculator example again.

Guice is a Java-oriented framework that supports Interface-Oriented design. Hence we create a `Calculator` interface first. We can then create our `CalculatorImpl` implementation and a `Client` object which our script will interact with. The `Client` class isn’t strictly needed for this example but allows us to show that non-singleton instances are the default. Here is the code:

```groovy
@Grapes([@Grab('aopalliance:aopalliance:1.0'), @Grab('com.google.code.guice:guice:1.0')])
import com.google.inject.*

interface Calculator {
    def add(a, b)
}

class CalculatorImpl implements Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    @Inject Calculator calc
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}

def injector = Guice.createInjector (
    [configure: { binding ->
        binding.bind(Calculator)
               .to(CalculatorImpl)
               .asEagerSingleton() } ] as Module
)

def client = injector.getInstance(Client)
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = injector.getInstance(Client)
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"
```

Note the `@Inject` annotation in the `Client` class. We can always tell right in the source code which fields will be injected.

In this example we chose to use an *explicit* binding. All of our dependencies (ok, only one in this example at the moment) are configured in the binding. The Guide injector knows about the binding and injects the dependencies as required when we create objects. For the singleton pattern to hold, you must always use Guice to create your instances. Nothing shown so far would stop you creating another instance of the calculator manually using new CalculatorImpl() which would of course violate the desired singleton behaviour.

In other scenarios (though probably not in large systems), we could choose to express dependencies using annotations, such as the following example shows:

```groovy
@Grapes([@Grab('aopalliance:aopalliance:1.0'), @Grab('com.google.code.guice:guice:1.0')])
import com.google.inject.*

@ImplementedBy(CalculatorImpl)
interface Calculator {
    // as before ...
}

@Singleton
class CalculatorImpl implements Calculator {
    // as before ...
}

class Client {
    // as before ...
}

def injector = Guice.createInjector()

// ...
```

Note the `@Singleton` annotation on the `CalculatorImpl` class and the `@ImplementedBy` annotation in the `Calculator` interface.

When run, the above example (using either approach) yields (your hashcode values will vary):

```
Client: 8897128, Calc: 17431955, Total Calculations: 1
Client: 21145613, Calc: 17431955, Total Calculations: 2
```

You can see that we obtained a new client object whenever we asked for an instance but it was injected with the same calculator object.

###### Spring Example

We can do the Calculator example again using Spring as follows:

```groovy
@Grapes([@Grab('org.springframework:spring-core:3.2.2.RELEASE'), @Grab('org.springframework:spring-beans:3.2.2.RELEASE')])
import org.springframework.beans.factory.support.*

interface Calculator {
    def add(a, b)
}

class CalculatorImpl implements Calculator {
    private total = 0
    def add(a, b) { total++; a + b }
    def getTotalCalculations() { 'Total Calculations: ' + total }
    String toString() { 'Calc: ' + hashCode() }
}

class Client {
    Client(Calculator calc) { this.calc = calc }
    def calc
    def executeCalc(a, b) { calc.add(a, b) }
    String toString() { 'Client: ' + hashCode() }
}

// Here we 'wire' up our dependencies through the API. Alternatively,
// we could use XML-based configuration or the Grails Bean Builder DSL.
def factory = new DefaultListableBeanFactory()
factory.registerBeanDefinition('calc', new RootBeanDefinition(CalculatorImpl))
def beanDef = new RootBeanDefinition(Client, false)
beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_AUTODETECT)
factory.registerBeanDefinition('client', beanDef)

def client = factory.getBean('client')
assert 3 == client.executeCalc(1, 2)
println "$client, $client.calc, $client.calc.totalCalculations"

client = factory.getBean('client')
assert 4 == client.executeCalc(2, 2)
println "$client, $client.calc, $client.calc.totalCalculations"
```

And here is the result (your hashcode values will vary):

```
Client: 29418586, Calc: 10580099, Total Calculations: 1
Client: 14800362, Calc: 10580099, Total Calculations: 2
```

###### Further information

- [Simply Singleton](http://www.javaworld.com/javaworld/jw-04-2003/jw-0425-designpatterns.html?page=1)
- [Use your singletons wisely](http://www.ibm.com/developerworks/webservices/library/co-single/index.html)
- [Double-checked locking and the Singleton pattern](http://www.ibm.com/developerworks/java/library/j-dcl/index.html)
- [Lazy Loading Singletons](https://web.archive.org/web/20160807234810/http://blog.crazybob.org/2007/01/lazy-loading-singletons.html)
- [Implementing the Singleton Pattern in C#](https://csharpindepth.com/Articles/Singleton)

##### State Pattern

The [State Pattern](http://en.wikipedia.org/wiki/State_pattern) provides a structured approach to partitioning the behaviour within complex systems. The overall behaviour of a system is partitioned into well-defined states. Typically, each state is implemented by a class. The overall system behaviour can be determined firstly by knowing the *current state* of the system; secondly, by understanding the behaviour possible while in that state (as embodied in the methods of the class corresponding to that state).

###### Example

Here is an example:

```groovy
class Client {
    def context = new Context()
    def connect() {
        context.state.connect()
    }
    def disconnect() {
        context.state.disconnect()
    }
    def send_message(message) {
        context.state.send_message(message)
    }
    def receive_message() {
        context.state.receive_message()
    }
}

class Context {
    def state = new Offline(this)
}

class ClientState {
    def context
    ClientState(context) {
        this.context = context
        inform()
    }
}

class Offline extends ClientState {
    Offline(context) {
        super(context)
    }
    def inform() {
        println "offline"
    }
    def connect() {
        context.state = new Online(context)
    }
    def disconnect() {
        println "error: not connected"
    }
    def send_message(message) {
        println "error: not connected"
    }
    def receive_message() {
        println "error: not connected"
    }
}

class Online extends ClientState {
    Online(context) {
        super(context)
    }
    def inform() {
        println "connected"
    }
    def connect() {
        println "error: already connected"
    }
    def disconnect() {
        context.state = new Offline(context)
    }
    def send_message(message) {
        println "\"$message\" sent"
    }
    def receive_message() {
        println "message received"
    }
}

client = new Client()
client.send_message("Hello")
client.connect()
client.send_message("Hello")
client.connect()
client.receive_message()
client.disconnect()
```

Here is the output:

```
offline
error: not connected
connected
"Hello" sent
error: already connected
message received
offline
```

One of the great things about a dynamic language like Groovy though is that we can take this example and express it in many different ways depending on our particular needs. Some potential variations for this example are shown below.

###### Variation 1: Leveraging Interface-Oriented Design

One approach we could take is to leverage [Interface-Oriented Design](http://www.pragmaticprogrammer.com/titles/kpiod/index.html). To do this, we could introduce the following interface:

```groovy
interface State {
    def connect()
    def disconnect()
    def send_message(message)
    def receive_message()
}
```

Then our `Client`, `Online` and 'Offline` classes could be modified to implement that interface, e.g.:

```groovy
class Client implements State {
  // ... as before ...
}

class Online implements State {
  // ... as before ...
}

class Offline implements State {
  // ... as before ...
}
```

You might ask: Haven’t we just introduced additional boilerplate code? Can’t we rely on duck-typing for this? The answer is 'yes' and 'no'. We can get away with duck-typing but one of the key intentions of the state pattern is to partition complexity. If we know that the *client* class and each *state* class all satisfy one interface, then we have placed some key boundaries around the complexity. We can look at any state class in isolation and know the bounds of behaviour possible for that state.

We don’t have to use interfaces for this, but it helps express the intent of this particular style of partitioning and it helps reduce the size of our unit tests (we would have to have additional tests in place to express this intent in languages which have less support for interface-oriented design).

###### Variation 2: Extract State Pattern Logic

Alternatively, or in combination with other variations, we might decide to extract some of our State Pattern logic into helper classes. For example, we could define the following classes in a state pattern package/jar/script:

```groovy
abstract class InstanceProvider {
    static def registry = GroovySystem.metaClassRegistry
    static def create(objectClass, param) {
        registry.getMetaClass(objectClass).invokeConstructor([param] as Object[])
    }
}

abstract class Context {
    private context
    protected setContext(context) {
        this.context = context
    }
    def invokeMethod(String name, Object arg) {
        context.invokeMethod(name, arg)
    }
    def startFrom(initialState) {
        setContext(InstanceProvider.create(initialState, this))
    }
}

abstract class State {
    private client

    State(client) { this.client = client }

    def transitionTo(nextState) {
        client.setContext(InstanceProvider.create(nextState, client))
    }
}
```

This is all quite generic and can be used wherever we want to introduce the state pattern. Here is what our code would look like now:

```groovy
class Client extends Context {
    Client() {
        startFrom(Offline)
    }
}

class Offline extends State {
    Offline(client) {
        super(client)
        println "offline"
    }
    def connect() {
        transitionTo(Online)
    }
    def disconnect() {
        println "error: not connected"
    }
    def send_message(message) {
        println "error: not connected"
    }
    def receive_message() {
        println "error: not connected"
    }
}

class Online extends State {
    Online(client) {
        super(client)
        println "connected"
    }
    def connect() {
        println "error: already connected"
    }
    def disconnect() {
        transitionTo(Offline)
    }
    def send_message(message) {
        println "\"$message\" sent"
    }
    def receive_message() {
        println "message received"
    }
}

client = new Client()
client.send_message("Hello")
client.connect()
client.send_message("Hello")
client.connect()
client.receive_message()
client.disconnect()
```

You can see here the `startFrom` and `transitionTo` methods begin to give our example code a DSL feel.

###### Variation 3: Bring on the DSL

Alternatively, or in combination with other variations, we might decide to fully embrace a Domain Specific Language (DSL) approach to this example.

We can define the following generic helper functions (first discussed [here](http://www.bytemycode.com/snippets/snippet/640/)):

```groovy
class Grammar {
    def fsm

    def event
    def fromState
    def toState

    Grammar(a_fsm) {
        fsm = a_fsm
    }

    def on(a_event) {
        event = a_event
        this
    }

    def on(a_event, a_transitioner) {
        on(a_event)
        a_transitioner.delegate = this
        a_transitioner.call()
        this
    }

    def from(a_fromState) {
        fromState = a_fromState
        this
    }

    def to(a_toState) {
        assert a_toState, "Invalid toState: $a_toState"
        toState = a_toState
        fsm.registerTransition(this)
        this
    }

    def isValid() {
        event && fromState && toState
    }

    public String toString() {
        "$event: $fromState=>$toState"
    }
}
class FiniteStateMachine {
    def transitions = [:]

    def initialState
    def currentState

    FiniteStateMachine(a_initialState) {
        assert a_initialState, "You need to provide an initial state"
        initialState = a_initialState
        currentState = a_initialState
    }

    def record() {
        Grammar.newInstance(this)
    }

    def reset() {
        currentState = initialState
    }

    def isState(a_state) {
        currentState == a_state
    }

    def registerTransition(a_grammar) {
        assert a_grammar.isValid(), "Invalid transition ($a_grammar)"
        def transition
        def event = a_grammar.event
        def fromState = a_grammar.fromState
        def toState = a_grammar.toState

        if (!transitions[event]) {
            transitions[event] = [:]
        }

        transition = transitions[event]
        assert !transition[fromState], "Duplicate fromState $fromState for transition $a_grammar"
        transition[fromState] = toState
    }

    def fire(a_event) {
        assert currentState, "Invalid current state '$currentState': passed into constructor"
        assert transitions.containsKey(a_event), "Invalid event '$a_event', should be one of ${transitions.keySet()}"
        def transition = transitions[a_event]
        def nextState = transition[currentState]
        assert nextState, "There is no transition from '$currentState' to any other state"
        currentState = nextState
        currentState
    }
}
```

Now we can define and test our state machine like this:

```groovy
class StatePatternDslTest extends GroovyTestCase {
    private fsm

    protected void setUp() {
        fsm = FiniteStateMachine.newInstance('offline')
        def recorder = fsm.record()
        recorder.on('connect').from('offline').to('online')
        recorder.on('disconnect').from('online').to('offline')
        recorder.on('send_message').from('online').to('online')
        recorder.on('receive_message').from('online').to('online')
    }

    void testInitialState() {
        assert fsm.isState('offline')
    }

    void testOfflineState() {
        shouldFail{
            fsm.fire('send_message')
        }
        shouldFail{
            fsm.fire('receive_message')
        }
        shouldFail{
            fsm.fire('disconnect')
        }
        assert 'online' == fsm.fire('connect')
    }

    void testOnlineState() {
        fsm.fire('connect')
        fsm.fire('send_message')
        fsm.fire('receive_message')
        shouldFail{
            fsm.fire('connect')
        }
        assert 'offline' == fsm.fire('disconnect')
    }
}
```

This example isn’t an exact equivalent of the others. It doesn’t use predefined `Online` and `Offline` classes. Instead it defines the entire state machine on the fly as needed. See the [previous reference](http://www.bytemycode.com/snippets/snippet/640/) for more elaborate examples of this style.

See also: [Model-based testing using ModelJUnit](https://docs.groovy-lang.org/latest/html/documentation/#_model_based_testing_using_modeljunit)

##### Strategy Pattern

The [Strategy Pattern](http://en.wikipedia.org/wiki/Strategy_pattern) allows you to abstract away particular algorithms from their usage. This allows you to easily swap the algorithm being used without having to change the calling code. The general form of the pattern is:

![StrategyClasses](https://docs.groovy-lang.org/latest/html/documentation/assets/img/StrategyClasses.gif)

In Groovy, because of its ability to treat code as a first class object using anonymous methods (which we loosely call *Closures*), the need for the strategy pattern is greatly reduced. You can simply place algorithms inside Closures.

###### Example

First let’s look at the traditional way of encapsulating the Strategy Pattern.

```groovy
interface Calc {
    def execute(n, m)
}

class CalcByMult implements Calc {
    def execute(n, m) { n * m }
}

class CalcByManyAdds implements Calc {
    def execute(n, m) {
        def result = 0
        n.times{
            result += m
        }

        result
    }
}

def sampleData = [
    [3, 4, 12],
    [5, -5, -25]
]

Calc[] multiplicationStrategies = [
    new CalcByMult(),
    new CalcByManyAdds()
]

sampleData.each{ data ->
    multiplicationStrategies.each { calc ->
        assert data[2] == calc.execute(data[0], data[1])
    }
}
```

Here we have defined an interface `Calc` which our concrete strategy classes will implement (we could also have used an abstract class). We then defined two algorithms for doing simple multiplication: `CalcByMult` the normal way, and CalcByManyAdds using only addition (don’t try this one using negative numbers - yes we could fix this but it would just make the example longer). We then use normal [polymorphism](http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming) to invoke the algorithms.

Here is the Groovier way to achieve the same thing using Closures:

```groovy
def multiplicationStrategies = [
    { n, m -> n * m },
    { n, m -> def result = 0; n.times{ result += m }; result }
]

def sampleData = [
    [3, 4, 12],
    [5, -5, -25]
]

sampleData.each{ data ->
    multiplicationStrategies.each { calc ->
        assert data[2] == calc(data[0], data[1])
    }
}
```

##### Template Method Pattern

The [Template Method Pattern](http://en.wikipedia.org/wiki/Template_method_pattern) abstracts away the details of several algorithms. The generic part of an algorithm is contained within a base class. Particular implementation details are captured within base classes. The generic pattern of classes involved looks like this:

![TemplateMethodClasses](https://docs.groovy-lang.org/latest/html/documentation/assets/img/TemplateMethodClasses.gif)

###### Example

In this example, `Accumulator` captures the essence of the accumulation algorithm. The base classes `Sum` and `Product` provide particular customised ways to use the generic accumulation algorithm.

```groovy
abstract class Accumulator {
    protected initial
    abstract doAccumulate(total, v)
    def accumulate(values) {
        def total = initial
        values.each { v -> total = doAccumulate(total, v) }
        total
    }
}

class Sum extends Accumulator {
    def Sum() { initial = 0 }
    def doAccumulate(total, v) { total + v }
}

class Product extends Accumulator {
    def Product() { initial = 1 }
    def doAccumulate(total, v) { total * v }
}

println new Sum().accumulate([1,2,3,4])
println new Product().accumulate([1,2,3,4])
```

The resulting output is:

```
10
24
```

In this particular case, you could use Groovy’s inject method to achieve a similar result using Closures:

```groovy
Closure addAll = { total, item -> total += item }
def accumulated = [1, 2, 3, 4].inject(0, addAll)
println accumulated    // => 10
```

Thanks to duck-typing, this would also work with other objects which support an add (plus() in Groovy) method, e.g.:

In this particular case, you could use Groovy’s inject method to achieve a similar result using Closures:

```groovy
accumulated = [ "1", "2", "3", "4" ].inject("", addAll)
println accumulated    // => "1234"
```

We could also do the multiplication case as follows:

```groovy
Closure multAll = { total, item -> total *= item }
accumulated = [1, 2, 3, 4].inject(1, multAll)
println accumulated    // => 24
```

Using closures this way looks more like the [Strategy Pattern](https://docs.groovy-lang.org/latest/html/documentation/#_strategy_pattern) but if we realise that the built-in inject method is the generic part of the algorithm for our template method, then the Closures become the customised parts of the template method pattern.

##### Visitor Pattern

The [Visitor Pattern](http://en.wikipedia.org/wiki/Visitor_pattern) is one of those well-known but not often used patterns. I think this is strange, as it is really a nice thing.

The goal of the pattern is to separate an algorithm from an object structure. A practical result of this separation is the ability to add new operations to existing object structures without modifying those structures.

###### Simple Example

This example considers how to calculate the bounds of shapes (or collections of shapes). Our first attempt uses the traditional visitor pattern. We will see a more Groovy way to do this shortly.

```groovy
abstract class Shape { }

class Rectangle extends Shape {
    def x, y, width, height

    Rectangle(x, y, width, height) {
        this.x = x; this.y = y; this.width = width; this.height = height
    }

    def union(rect) {
        if (!rect) return this
        def minx = [rect.x, x].min()
        def maxx = [rect.x + width, x + width].max()
        def miny = [rect.y, y].min()
        def maxy = [rect.y + height, y + height].max()
        new Rectangle(minx, miny, maxx - minx, maxy - miny)
    }

    def accept(visitor) {
        visitor.visit_rectangle(this)
    }
}

class Line extends Shape {
    def x1, y1, x2, y2

    Line(x1, y1, x2, y2) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2
    }

    def accept(visitor){
        visitor.visit_line(this)
    }
}

class Group extends Shape {
    def shapes = []
    def add(shape) { shapes += shape }
    def remove(shape) { shapes -= shape }
    def accept(visitor) {
        visitor.visit_group(this)
    }
}

class BoundingRectangleVisitor {
    def bounds

    def visit_rectangle(rectangle) {
        if (bounds)
            bounds = bounds.union(rectangle)
        else
            bounds = rectangle
    }

    def visit_line(line) {
        def line_bounds = new Rectangle(line.x1, line.y1, line.x2-line.y1, line.x2-line.y2)
        if (bounds)
            bounds = bounds.union(line_bounds)
        else
            bounds = line_bounds
    }

    def visit_group(group) {
        group.shapes.each { shape -> shape.accept(this) }
    }
}

def group = new Group()
group.add(new Rectangle(100, 40, 10, 5))
group.add(new Rectangle(100, 70, 10, 5))
group.add(new Line(90, 30, 60, 5))
def visitor = new BoundingRectangleVisitor()
group.accept(visitor)
bounding_box = visitor.bounds
println bounding_box.dump()
```

That took quite a bit of code.

We can improve the clarity of our code (and make it about half the size) by making use of Groovy Closures as follows:

```groovy
abstract class Shape {
    def accept(Closure yield) { yield(this) }
}

class Rectangle extends Shape {
    def x, y, w, h
    def bounds() { this }
    def union(rect) {
        if (!rect) return this
        def minx = [ rect.x, x ].min()
        def maxx = [ rect.x + w, x + w ].max()
        def miny = [ rect.y, y ].min()
        def maxy = [ rect.y + h, y + h ].max()
        new Rectangle(x:minx, y:miny, w:maxx - minx, h:maxy - miny)
    }
}

class Line extends Shape {
    def x1, y1, x2, y2
    def bounds() {
        new Rectangle(x:[x1, x2].min(), y:[y1, y2].min(), w:(x2 - x1).abs(), h:(y2 - y1).abs())
    }
}

class Group {
    def shapes = []
    def leftShift(shape) { shapes += shape }
    def accept(Closure yield) { shapes.each{it.accept(yield)} }
}

def group = new Group()
group << new Rectangle(x:100, y:40, w:10, h:5)
group << new Rectangle(x:100, y:70, w:10, h:5)
group << new Line(x1:90, y1:30, x2:60, y2:5)
def bounds
group.accept{ bounds = it.bounds().union(bounds) }
println bounds.dump()
```

###### Advanced Example

```groovy
interface Visitor {
    void visit(NodeType1 n1)
    void visit(NodeType2 n2)
}

interface Visitable {
    void accept(Visitor visitor)
}

class NodeType1 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
        for(int i = 0; i < children.length; ++i) {
            children[i].accept(visitor)
        }
    }
}

class NodeType2 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
        for(int i = 0; i < children.length; ++i) {
            children[i].accept(visitor)
        }
    }
}

class NodeType1Counter implements Visitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
    }
    void visit(NodeType2 n2){}
}
```

If we now use `NodeType1Counter` on a tree like this:

```groovy
NodeType1 root = new NodeType1()
root.children = new Visitable[2]
root.children[0] = new NodeType1()
root.children[1] = new NodeType2()
```

Then we have one `NodeType1` object as root and one of the children is also a `NodeType1` instance. The other child is a `NodeType2` instance. That means using `NodeType1Counter` here should count 2 `NodeType1` objects.

Why to use this

As you can see here very good we have a visitor that has a state while the tree of objects is not changed. That’s pretty useful in different areas, for example you could have a visitor counting all node types, or how many different types are used, or you could use methods special to the node to gather information about the tree and much more.

What happens if we add a new type?

In this case we have to do much work.. we have to change Visitor to accept the new type, we have to write the new type itself of course and we have to change every Visitor we have already implemented. After very few changes you will modify all your Visitors to extend a default implementation of the visitor, so you don’t need to change every Visitor each time you add a new type.

What if we want to have different iteration patterns?

Then you have a problem. since the node describes how to iterate, you have no influence and stop iteration at a point or change the order. So maybe we should change this a little to this:

```groovy
interface Visitor {
    void visit(NodeType1 n1)
    void visit(NodeType2 n2)
}

class DefaultVisitor implements Visitor{
    void visit(NodeType1 n1) {
        for(int i = 0; i < n1.children.length; ++i) {
            n1.children[i].accept(this)
        }
    }
    void visit(NodeType2 n2) {
        for(int i = 0; i < n2.children.length; ++i) {
            n2.children[i].accept(this)
        }
    }
}

interface Visitable {
    void accept(Visitor visitor)
}

class NodeType1 implements Visitable {
    Visitable[] children = new Visitable[0]
    void accept(Visitor visitor) {
        visitor.visit(this)
    }
}

class NodeType2 implements Visitable {
    Visitable[] children = new Visitable[0];
    void accept(Visitor visitor) {
        visitor.visit(this)
    }
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}
```

Some small changes but with big effect… the visitor is now recursive and tells me how to iterate. The implementation in the Nodes is minimized to `visitor.visit(this)`, `DefaultVisitor` is now able to catch the new types, we can stop iteration by not delegating to super. Of course the big disadvantage now is that it is no longer iterative, but you can’t get all the benefits.

Make it Groovy

The question now is how to make that a bit more Groovy. Didn’t you find this `visitor.visit(this)` strange? Why is it there? The answer is to simulate double dispatch. In Java the compile time type is used, so when I `visitor.visit(children[i])` then the compiler won’t be able to find the correct method, because `Visitor` does not contain a method `visit(Visitable)`. And even if it would, we would like to visit the more special methods with `NodeType1` or `NodeType2`.

Now Groovy is not using the static type, Groovy uses the runtime type. This means I could do `visitor.visit(children[i])` directly. Hmm.. since we minimized the accept method to just do the double dispatch part and since the runtime type system of Groovy will already cover that.. do we need the accept method? I think you can guess that I would answer no. But we can do more. We had the disadvantage of not knowing how to handle unknown tree elements. We had to extends the interface `Visitor` for that, resulting in changes to `DefaultVisitor` and then we have the task to provide a useful default like iterating the node or not doing anything at all. Now with Groovy we can catch that case by adding a `visit(Visitable)` method that does nothing. That would be the same in Java btw.

But don’t let us stop here… do we need the `Visitor` interface? If we don’t have the accept method, then we don’t need the `Visitor` interface at all. So the new code would be:

```groovy
class DefaultVisitor {
    void visit(NodeType1 n1) {
        n1.children.each { visit(it) }
    }
    void visit(NodeType2 n2) {
        n2.children.each { visit(it) }
    }
    void visit(Visitable v) { }
}

interface Visitable { }

class NodeType1 implements Visitable {
    Visitable[] children = []
}

class NodeType2 implements Visitable {
    Visitable[] children = []
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}
```

Looks like we saved a few lines of code here. But we made more. The `Visitable` nodes now do not refer to any `Visitor` class or interface. For me this is the best level of separation you could get here. But do we really need to stop here? No. Let us change the `Visitable` interface a little and let it return the children we want to visit next. This allows us a general iteration method.

```groovy
class DefaultVisitor {
    void visit(Visitable v) {
        doIteraton(v)
    }
    void doIteraton(Visitable v) {
        v.children.each {
            visit(it)
        }
    }
}

interface Visitable {
    Visitable[] getChildren()
}

class NodeType1 implements Visitable {
    Visitable[] children = []
}

class NodeType2 implements Visitable {
    Visitable[] children = []
}

class NodeType1Counter extends DefaultVisitor {
    int count = 0
    void visit(NodeType1 n1) {
        count++
        super.visit(n1)
    }
}
```

`DefaultVisitor` now looks a bit different. I added a `doIteration` method that will get the children it should iterate over and then call visit on each element. Per default this will call `visit(Visitable)` which then iterates over the children of this child. I changed `Visitable` to ensure that any node will be able to return children (even if empty). I didn’t have to change the `NodeType1` and `NodeType2` class, because the way the children filed was defined already made them a property, which means Groovy is so nice to generate a get method for us. No the really interesting part is `NodeType1Counter`, it is interesting because we have not changed it. `super.visit(n1)` will now call `visit(Visitable)` which will call `doIteration` which will start the next level of iteration. So no change. But `visit(it)` will call `visit(NodeType1)` if it is of type `NodeType1`. In fact we don’t need the `doIteration` method, we could do that in `visit(Visitable)` too, but I thought this variant is better, because it allows us to write a new `Visitor` that overwrites visit(`Visitable`) for error cases which of course means we must not do `super.visit(n1)` but `doIteration(n1)`.

Summary

In the end we got ~40% less code, a robust and stable architecture and we completely removed the Visitor from the Visitable. I heard about visitor implementations based on Reflection to get a more generic version. Well, with this you see there is really no need to do such thing. If we add new types we don’t need to change anything. It is said that the visitor pattern doesn’t fit extreme programming techniques very well because you need to make changes to so many classes all the time. I think I proved that this is because of Java not because the pattern is bad or something.

There are variants of the Visitor pattern, like the acyclic visitor pattern, that tries to solve the problem of adding new node types with special visitors. I don’t like that very much, it works with casts, catches the `ClassCastException` and other nasty things. In the end it tries to solve something we don’t even get with the Groovy version.

One more thing. `NodeType1Counter` could be implemented in Java as well. Groovy will recognize the visit methods and call them as needed because `DefaultVisitor` is still Groovy and does all the magic.

###### Further Information

- [Componentization: the Visitor example](http://se.ethz.ch/~meyer/publications/computer/visitor.pdf)

#### 3.19.2. References

1. Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (1995). *Design Patterns: Elements of Reusable Object-Oriented Software*. Addison-Wesley. ISBN 0-201-63361-2.
   - *The canonical reference of design patterns.*
2. Martin Fowler (1999). *Refactoring: Improving the Design of Existing Code*. Addison-Wesley. ISBN 0-201-48567-2.
3. Joshua Kerievsky (2004). *Refactoring To Patterns*. Addison-Wesley. ISBN 0-321-21335-1.
4. Eric Freeman, Elisabeth Freeman, Kathy Sierra, Bert Bates (2004). *Head First Design Patterns*. O’Reilly. ISBN 0-596-00712-4. **A great book to read, informative as well as amusing.*
5. Dierk Koenig with Andrew Glover, Paul King, Guillaume Laforge and Jon Skeet (2007). *Groovy in Action*. Manning. ISBN 1-932394-84-2.
   - *Discusses Visitor, Builder and other Patterns.*
6. Brad Appleton (1999). [Pizza Inversion - a Pattern for Efficient Resource Consumption](http://www.bradapp.com/docs/pizza-inv.html).
   - *One of the most frequently used patterns by many software engineers!*
7. *Design Patterns in Dynamic Languages* by Neil Ford. Houston Java User’s Group. Examples in Groovy and Ruby. http://www.oracle.com/technetwork/server-storage/ts-4961-159222.pdf